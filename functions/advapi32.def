BOOL IsTextUnicode([Const] [MemorySize(BytesParamIndex = 1)] [In] void* lpv, [In] int iSize, [In] [Out] [Optional] IS_TEXT_UNICODE_RESULT* lpiResult);
BOOL AccessCheck([In] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] HANDLE ClientToken, [In] uint DesiredAccess, [In] GENERIC_MAPPING* GenericMapping, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] PRIVILEGE_SET* PrivilegeSet, [In] [Out] uint* PrivilegeSetLength, [Out] uint* GrantedAccess, [Out] int* AccessStatus);
BOOL AccessCheckAndAuditAlarmW([Const] [In] PWSTR SubsystemName, [In] [Optional] void* HandleId, [In] PWSTR ObjectTypeName, [In] [Optional] PWSTR ObjectName, [In] PSECURITY_DESCRIPTOR SecurityDescriptor, [In] uint DesiredAccess, [In] GENERIC_MAPPING* GenericMapping, [In] BOOL ObjectCreation, [Out] uint* GrantedAccess, [Out] int* AccessStatus, [Out] int* pfGenerateOnClose);
BOOL AccessCheckByType([In] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] [Optional] PSID PrincipalSelfSid, [In] HANDLE ClientToken, [In] uint DesiredAccess, [NativeArrayInfo(CountParamIndex = 5)] [In] [Out] [Optional] OBJECT_TYPE_LIST* ObjectTypeList, [In] uint ObjectTypeListLength, [In] GENERIC_MAPPING* GenericMapping, [MemorySize(BytesParamIndex = 8)] [Out] [Optional] PRIVILEGE_SET* PrivilegeSet, [In] [Out] uint* PrivilegeSetLength, [Out] uint* GrantedAccess, [Out] int* AccessStatus);
BOOL AccessCheckByTypeResultList([In] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] [Optional] PSID PrincipalSelfSid, [In] HANDLE ClientToken, [In] uint DesiredAccess, [NativeArrayInfo(CountParamIndex = 5)] [In] [Out] [Optional] OBJECT_TYPE_LIST* ObjectTypeList, [In] uint ObjectTypeListLength, [In] GENERIC_MAPPING* GenericMapping, [MemorySize(BytesParamIndex = 8)] [Out] [Optional] PRIVILEGE_SET* PrivilegeSet, [In] [Out] uint* PrivilegeSetLength, [NativeArrayInfo(CountParamIndex = 5)] [Out] uint* GrantedAccessList, [NativeArrayInfo(CountParamIndex = 5)] [Out] uint* AccessStatusList);
BOOL AccessCheckByTypeAndAuditAlarmW([Const] [In] PWSTR SubsystemName, [In] void* HandleId, [Const] [In] PWSTR ObjectTypeName, [Const] [In] [Optional] PWSTR ObjectName, [In] PSECURITY_DESCRIPTOR SecurityDescriptor, [In] [Optional] PSID PrincipalSelfSid, [In] uint DesiredAccess, [In] AUDIT_EVENT_TYPE AuditType, [In] uint Flags, [NativeArrayInfo(CountParamIndex = 10)] [In] [Out] [Optional] OBJECT_TYPE_LIST* ObjectTypeList, [In] uint ObjectTypeListLength, [In] GENERIC_MAPPING* GenericMapping, [In] BOOL ObjectCreation, [Out] uint* GrantedAccess, [Out] int* AccessStatus, [Out] int* pfGenerateOnClose);
BOOL AccessCheckByTypeResultListAndAuditAlarmW([Const] [In] PWSTR SubsystemName, [In] void* HandleId, [Const] [In] PWSTR ObjectTypeName, [Const] [In] [Optional] PWSTR ObjectName, [In] PSECURITY_DESCRIPTOR SecurityDescriptor, [In] [Optional] PSID PrincipalSelfSid, [In] uint DesiredAccess, [In] AUDIT_EVENT_TYPE AuditType, [In] uint Flags, [NativeArrayInfo(CountParamIndex = 10)] [In] [Out] [Optional] OBJECT_TYPE_LIST* ObjectTypeList, [In] uint ObjectTypeListLength, [In] GENERIC_MAPPING* GenericMapping, [In] BOOL ObjectCreation, [NativeArrayInfo(CountParamIndex = 10)] [Out] uint* GrantedAccessList, [NativeArrayInfo(CountParamIndex = 10)] [Out] uint* AccessStatusList, [Out] int* pfGenerateOnClose);
BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW([Const] [In] PWSTR SubsystemName, [In] void* HandleId, [In] HANDLE ClientToken, [Const] [In] PWSTR ObjectTypeName, [Const] [In] [Optional] PWSTR ObjectName, [In] PSECURITY_DESCRIPTOR SecurityDescriptor, [In] [Optional] PSID PrincipalSelfSid, [In] uint DesiredAccess, [In] AUDIT_EVENT_TYPE AuditType, [In] uint Flags, [NativeArrayInfo(CountParamIndex = 11)] [In] [Out] [Optional] OBJECT_TYPE_LIST* ObjectTypeList, [In] uint ObjectTypeListLength, [In] GENERIC_MAPPING* GenericMapping, [In] BOOL ObjectCreation, [NativeArrayInfo(CountParamIndex = 11)] [Out] uint* GrantedAccessList, [NativeArrayInfo(CountParamIndex = 11)] [Out] uint* AccessStatusList, [Out] int* pfGenerateOnClose);
BOOL AddAccessAllowedAce([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] uint AccessMask, [In] PSID pSid);
BOOL AddAccessAllowedAceEx([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] ACE_FLAGS AceFlags, [In] uint AccessMask, [In] PSID pSid);
BOOL AddAccessAllowedObjectAce([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] ACE_FLAGS AceFlags, [In] uint AccessMask, [In] [Optional] Guid* ObjectTypeGuid, [In] [Optional] Guid* InheritedObjectTypeGuid, [In] PSID pSid);
BOOL AddAccessDeniedAce([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] uint AccessMask, [In] PSID pSid);
BOOL AddAccessDeniedAceEx([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] ACE_FLAGS AceFlags, [In] uint AccessMask, [In] PSID pSid);
BOOL AddAccessDeniedObjectAce([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] ACE_FLAGS AceFlags, [In] uint AccessMask, [In] [Optional] Guid* ObjectTypeGuid, [In] [Optional] Guid* InheritedObjectTypeGuid, [In] PSID pSid);
BOOL AddAce([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] uint dwStartingAceIndex, [MemorySize(BytesParamIndex = 4)] [In] void* pAceList, [In] uint nAceListLength);
BOOL AddAuditAccessAce([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] uint dwAccessMask, [In] PSID pSid, [In] BOOL bAuditSuccess, [In] BOOL bAuditFailure);
BOOL AddAuditAccessAceEx([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] ACE_FLAGS AceFlags, [In] uint dwAccessMask, [In] PSID pSid, [In] BOOL bAuditSuccess, [In] BOOL bAuditFailure);
BOOL AddAuditAccessObjectAce([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] ACE_FLAGS AceFlags, [In] uint AccessMask, [In] [Optional] Guid* ObjectTypeGuid, [In] [Optional] Guid* InheritedObjectTypeGuid, [In] PSID pSid, [In] BOOL bAuditSuccess, [In] BOOL bAuditFailure);
BOOL AddMandatoryAce([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] ACE_FLAGS AceFlags, [In] uint MandatoryPolicy, [In] PSID pLabelSid);
BOOL AdjustTokenGroups([In] HANDLE TokenHandle, [In] BOOL ResetToDefault, [In] [Optional] TOKEN_GROUPS* NewState, [In] uint BufferLength, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] TOKEN_GROUPS* PreviousState, [Out] [Optional] uint* ReturnLength);
BOOL AdjustTokenPrivileges([In] HANDLE TokenHandle, [In] BOOL DisableAllPrivileges, [In] [Optional] TOKEN_PRIVILEGES* NewState, [In] uint BufferLength, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] TOKEN_PRIVILEGES* PreviousState, [Out] [Optional] uint* ReturnLength);
BOOL AllocateAndInitializeSid([In] SID_IDENTIFIER_AUTHORITY* pIdentifierAuthority, [In] byte nSubAuthorityCount, [In] uint nSubAuthority0, [In] uint nSubAuthority1, [In] uint nSubAuthority2, [In] uint nSubAuthority3, [In] uint nSubAuthority4, [In] uint nSubAuthority5, [In] uint nSubAuthority6, [In] uint nSubAuthority7, [Out] PSID* pSid);
BOOL AllocateLocallyUniqueId([Out] LUID* Luid);
BOOL AreAllAccessesGranted([In] uint GrantedAccess, [In] uint DesiredAccess);
BOOL AreAnyAccessesGranted([In] uint GrantedAccess, [In] uint DesiredAccess);
BOOL CheckTokenMembership([In] [Optional] HANDLE TokenHandle, [In] PSID SidToCheck, [Out] BOOL* IsMember);
BOOL ConvertToAutoInheritPrivateObjectSecurity([In] [Optional] PSECURITY_DESCRIPTOR ParentDescriptor, [In] PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, [Out] PSECURITY_DESCRIPTOR* NewSecurityDescriptor, [In] [Optional] Guid* ObjectType, [In] BOOLEAN IsDirectoryObject, [In] GENERIC_MAPPING* GenericMapping);
BOOL CopySid([In] uint nDestinationSidLength, [MemorySize(BytesParamIndex = 0)] [Out] PSID pDestinationSid, [In] PSID pSourceSid);
BOOL CreatePrivateObjectSecurity([In] [Optional] PSECURITY_DESCRIPTOR ParentDescriptor, [In] [Optional] PSECURITY_DESCRIPTOR CreatorDescriptor, [Out] PSECURITY_DESCRIPTOR* NewDescriptor, [In] BOOL IsDirectoryObject, [In] [Optional] HANDLE Token, [In] GENERIC_MAPPING* GenericMapping);
BOOL CreatePrivateObjectSecurityEx([In] [Optional] PSECURITY_DESCRIPTOR ParentDescriptor, [In] [Optional] PSECURITY_DESCRIPTOR CreatorDescriptor, [Out] PSECURITY_DESCRIPTOR* NewDescriptor, [In] [Optional] Guid* ObjectType, [In] BOOL IsContainerObject, [In] SECURITY_AUTO_INHERIT_FLAGS AutoInheritFlags, [In] [Optional] HANDLE Token, [In] GENERIC_MAPPING* GenericMapping);
BOOL CreatePrivateObjectSecurityWithMultipleInheritance([In] [Optional] PSECURITY_DESCRIPTOR ParentDescriptor, [In] [Optional] PSECURITY_DESCRIPTOR CreatorDescriptor, [Out] PSECURITY_DESCRIPTOR* NewDescriptor, [NativeArrayInfo(CountParamIndex = 4)] [In] [Optional] Guid** ObjectTypes, [In] uint GuidCount, [In] BOOL IsContainerObject, [In] SECURITY_AUTO_INHERIT_FLAGS AutoInheritFlags, [In] [Optional] HANDLE Token, [In] GENERIC_MAPPING* GenericMapping);
BOOL CreateRestrictedToken([In] HANDLE ExistingTokenHandle, [In] CREATE_RESTRICTED_TOKEN_FLAGS Flags, [In] uint DisableSidCount, [NativeArrayInfo(CountParamIndex = 2)] [In] [Optional] SID_AND_ATTRIBUTES* SidsToDisable, [In] uint DeletePrivilegeCount, [NativeArrayInfo(CountParamIndex = 4)] [In] [Optional] LUID_AND_ATTRIBUTES* PrivilegesToDelete, [In] uint RestrictedSidCount, [NativeArrayInfo(CountParamIndex = 6)] [In] [Optional] SID_AND_ATTRIBUTES* SidsToRestrict, [Out] HANDLE* NewTokenHandle);
BOOL CreateWellKnownSid([In] WELL_KNOWN_SID_TYPE WellKnownSidType, [In] [Optional] PSID DomainSid, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PSID pSid, [In] [Out] uint* cbSid);
BOOL EqualDomainSid([In] PSID pSid1, [In] PSID pSid2, [Out] BOOL* pfEqual);
BOOL DeleteAce([In] [Out] ACL* pAcl, [In] uint dwAceIndex);
BOOL DestroyPrivateObjectSecurity([In] PSECURITY_DESCRIPTOR* ObjectDescriptor);
BOOL DuplicateToken([In] HANDLE ExistingTokenHandle, [In] SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, [Out] HANDLE* DuplicateTokenHandle);
BOOL DuplicateTokenEx([In] HANDLE hExistingToken, [In] TOKEN_ACCESS_MASK dwDesiredAccess, [In] [Optional] SECURITY_ATTRIBUTES* lpTokenAttributes, [In] SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, [In] TOKEN_TYPE TokenType, [Out] HANDLE* phNewToken);
BOOL EqualPrefixSid([In] PSID pSid1, [In] PSID pSid2);
BOOL EqualSid([In] PSID pSid1, [In] PSID pSid2);
BOOL FindFirstFreeAce([In] ACL* pAcl, [Out] void** pAce);
void* FreeSid([In] PSID pSid);
BOOL GetAce([In] ACL* pAcl, [In] uint dwAceIndex, [Out] void** pAce);
BOOL GetAclInformation([In] ACL* pAcl, [MemorySize(BytesParamIndex = 2)] [Out] void* pAclInformation, [In] uint nAclInformationLength, [In] ACL_INFORMATION_CLASS dwAclInformationClass);
BOOL GetFileSecurityW([Const] [In] PWSTR lpFileName, [In] uint RequestedInformation, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] uint nLength, [Out] uint* lpnLengthNeeded);
BOOL GetKernelObjectSecurity([In] HANDLE Handle, [In] uint RequestedInformation, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] uint nLength, [Out] uint* lpnLengthNeeded);
uint GetLengthSid([In] [Out] PSID pSid);
BOOL GetPrivateObjectSecurity([In] PSECURITY_DESCRIPTOR ObjectDescriptor, [In] uint SecurityInformation, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PSECURITY_DESCRIPTOR ResultantDescriptor, [In] uint DescriptorLength, [Out] uint* ReturnLength);
BOOL GetSecurityDescriptorControl([In] PSECURITY_DESCRIPTOR pSecurityDescriptor, [Out] ushort* pControl, [Out] uint* lpdwRevision);
BOOL GetSecurityDescriptorDacl([In] PSECURITY_DESCRIPTOR pSecurityDescriptor, [Out] int* lpbDaclPresent, [Out] ACL** pDacl, [Out] int* lpbDaclDefaulted);
BOOL GetSecurityDescriptorGroup([In] PSECURITY_DESCRIPTOR pSecurityDescriptor, [Out] PSID* pGroup, [Out] int* lpbGroupDefaulted);
uint GetSecurityDescriptorLength([In] PSECURITY_DESCRIPTOR pSecurityDescriptor);
BOOL GetSecurityDescriptorOwner([In] PSECURITY_DESCRIPTOR pSecurityDescriptor, [Out] PSID* pOwner, [Out] int* lpbOwnerDefaulted);
uint GetSecurityDescriptorRMControl([In] PSECURITY_DESCRIPTOR SecurityDescriptor, [Out] byte* RMControl);
BOOL GetSecurityDescriptorSacl([In] PSECURITY_DESCRIPTOR pSecurityDescriptor, [Out] int* lpbSaclPresent, [Out] ACL** pSacl, [Out] int* lpbSaclDefaulted);
SID_IDENTIFIER_AUTHORITY* GetSidIdentifierAuthority([In] PSID pSid);
uint GetSidLengthRequired([In] byte nSubAuthorityCount);
uint* GetSidSubAuthority([In] PSID pSid, [In] uint nSubAuthority);
byte* GetSidSubAuthorityCount([In] PSID pSid);
BOOL GetTokenInformation([In] HANDLE TokenHandle, [In] TOKEN_INFORMATION_CLASS TokenInformationClass, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] void* TokenInformation, [In] uint TokenInformationLength, [Out] uint* ReturnLength);
BOOL GetWindowsAccountDomainSid([In] PSID pSid, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] PSID pDomainSid, [In] [Out] uint* cbDomainSid);
BOOL ImpersonateAnonymousToken([In] HANDLE ThreadHandle);
BOOL ImpersonateLoggedOnUser([In] HANDLE hToken);
BOOL ImpersonateSelf([In] SECURITY_IMPERSONATION_LEVEL ImpersonationLevel);
BOOL InitializeAcl([MemorySize(BytesParamIndex = 1)] [Out] ACL* pAcl, [In] uint nAclLength, [In] ACE_REVISION dwAclRevision);
BOOL InitializeSecurityDescriptor([Out] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] uint dwRevision);
BOOL InitializeSid([Out] PSID Sid, [In] SID_IDENTIFIER_AUTHORITY* pIdentifierAuthority, [In] byte nSubAuthorityCount);
BOOL IsTokenRestricted([In] HANDLE TokenHandle);
BOOL IsValidAcl([In] ACL* pAcl);
BOOL IsValidSecurityDescriptor([In] PSECURITY_DESCRIPTOR pSecurityDescriptor);
BOOL IsValidSid([In] PSID pSid);
BOOL IsWellKnownSid([In] PSID pSid, [In] WELL_KNOWN_SID_TYPE WellKnownSidType);
BOOL MakeAbsoluteSD([In] PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, [In] [Out] uint* lpdwAbsoluteSecurityDescriptorSize, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] ACL* pDacl, [In] [Out] uint* lpdwDaclSize, [MemorySize(BytesParamIndex = 6)] [Out] [Optional] ACL* pSacl, [In] [Out] uint* lpdwSaclSize, [MemorySize(BytesParamIndex = 8)] [Out] [Optional] PSID pOwner, [In] [Out] uint* lpdwOwnerSize, [MemorySize(BytesParamIndex = 10)] [Out] [Optional] PSID pPrimaryGroup, [In] [Out] uint* lpdwPrimaryGroupSize);
BOOL MakeSelfRelativeSD([In] PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, [In] [Out] uint* lpdwBufferLength);
void MapGenericMask([In] [Out] uint* AccessMask, [In] GENERIC_MAPPING* GenericMapping);
BOOL ObjectCloseAuditAlarmW([Const] [In] PWSTR SubsystemName, [In] void* HandleId, [In] BOOL GenerateOnClose);
BOOL ObjectDeleteAuditAlarmW([Const] [In] PWSTR SubsystemName, [In] void* HandleId, [In] BOOL GenerateOnClose);
BOOL ObjectOpenAuditAlarmW([Const] [In] PWSTR SubsystemName, [In] void* HandleId, [In] PWSTR ObjectTypeName, [In] [Optional] PWSTR ObjectName, [In] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] HANDLE ClientToken, [In] uint DesiredAccess, [In] uint GrantedAccess, [In] [Optional] PRIVILEGE_SET* Privileges, [In] BOOL ObjectCreation, [In] BOOL AccessGranted, [Out] int* GenerateOnClose);
BOOL ObjectPrivilegeAuditAlarmW([Const] [In] PWSTR SubsystemName, [In] void* HandleId, [In] HANDLE ClientToken, [In] uint DesiredAccess, [In] PRIVILEGE_SET* Privileges, [In] BOOL AccessGranted);
BOOL PrivilegeCheck([In] HANDLE ClientToken, [In] [Out] PRIVILEGE_SET* RequiredPrivileges, [Out] int* pfResult);
BOOL PrivilegedServiceAuditAlarmW([Const] [In] PWSTR SubsystemName, [Const] [In] PWSTR ServiceName, [In] HANDLE ClientToken, [In] PRIVILEGE_SET* Privileges, [In] BOOL AccessGranted);
void QuerySecurityAccessMask([In] uint SecurityInformation, [Out] uint* DesiredAccess);
BOOL RevertToSelf();
BOOL SetAclInformation([In] [Out] ACL* pAcl, [MemorySize(BytesParamIndex = 2)] [In] void* pAclInformation, [In] uint nAclInformationLength, [In] ACL_INFORMATION_CLASS dwAclInformationClass);
BOOL SetFileSecurityW([Const] [In] PWSTR lpFileName, [In] uint SecurityInformation, [In] PSECURITY_DESCRIPTOR pSecurityDescriptor);
BOOL SetKernelObjectSecurity([In] HANDLE Handle, [In] uint SecurityInformation, [In] PSECURITY_DESCRIPTOR SecurityDescriptor);
BOOL SetPrivateObjectSecurity([In] uint SecurityInformation, [In] PSECURITY_DESCRIPTOR ModificationDescriptor, [In] [Out] PSECURITY_DESCRIPTOR* ObjectsSecurityDescriptor, [In] GENERIC_MAPPING* GenericMapping, [In] [Optional] HANDLE Token);
BOOL SetPrivateObjectSecurityEx([In] uint SecurityInformation, [In] PSECURITY_DESCRIPTOR ModificationDescriptor, [In] [Out] PSECURITY_DESCRIPTOR* ObjectsSecurityDescriptor, [In] SECURITY_AUTO_INHERIT_FLAGS AutoInheritFlags, [In] GENERIC_MAPPING* GenericMapping, [In] [Optional] HANDLE Token);
void SetSecurityAccessMask([In] uint SecurityInformation, [Out] uint* DesiredAccess);
BOOL SetSecurityDescriptorControl([In] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] ushort ControlBitsOfInterest, [In] ushort ControlBitsToSet);
BOOL SetSecurityDescriptorDacl([In] [Out] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] BOOL bDaclPresent, [In] [Optional] ACL* pDacl, [In] BOOL bDaclDefaulted);
BOOL SetSecurityDescriptorGroup([In] [Out] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] [Optional] PSID pGroup, [In] BOOL bGroupDefaulted);
BOOL SetSecurityDescriptorOwner([In] [Out] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] [Optional] PSID pOwner, [In] BOOL bOwnerDefaulted);
uint SetSecurityDescriptorRMControl([In] [Out] PSECURITY_DESCRIPTOR SecurityDescriptor, [In] [Optional] byte* RMControl);
BOOL SetSecurityDescriptorSacl([In] [Out] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] BOOL bSaclPresent, [In] [Optional] ACL* pSacl, [In] BOOL bSaclDefaulted);
BOOL SetTokenInformation([In] HANDLE TokenHandle, [In] TOKEN_INFORMATION_CLASS TokenInformationClass, [MemorySize(BytesParamIndex = 3)] [In] void* TokenInformation, [In] uint TokenInformationLength);
BOOL AccessCheckAndAuditAlarmA([Const] [In] PSTR SubsystemName, [In] [Optional] void* HandleId, [In] PSTR ObjectTypeName, [In] [Optional] PSTR ObjectName, [In] PSECURITY_DESCRIPTOR SecurityDescriptor, [In] uint DesiredAccess, [In] GENERIC_MAPPING* GenericMapping, [In] BOOL ObjectCreation, [Out] uint* GrantedAccess, [Out] int* AccessStatus, [Out] int* pfGenerateOnClose);
BOOL AccessCheckByTypeAndAuditAlarmA([Const] [In] PSTR SubsystemName, [In] void* HandleId, [Const] [In] PSTR ObjectTypeName, [Const] [In] [Optional] PSTR ObjectName, [In] PSECURITY_DESCRIPTOR SecurityDescriptor, [In] [Optional] PSID PrincipalSelfSid, [In] uint DesiredAccess, [In] AUDIT_EVENT_TYPE AuditType, [In] uint Flags, [NativeArrayInfo(CountParamIndex = 10)] [In] [Out] [Optional] OBJECT_TYPE_LIST* ObjectTypeList, [In] uint ObjectTypeListLength, [In] GENERIC_MAPPING* GenericMapping, [In] BOOL ObjectCreation, [Out] uint* GrantedAccess, [Out] int* AccessStatus, [Out] int* pfGenerateOnClose);
BOOL AccessCheckByTypeResultListAndAuditAlarmA([Const] [In] PSTR SubsystemName, [In] void* HandleId, [Const] [In] PSTR ObjectTypeName, [Const] [In] [Optional] PSTR ObjectName, [In] PSECURITY_DESCRIPTOR SecurityDescriptor, [In] [Optional] PSID PrincipalSelfSid, [In] uint DesiredAccess, [In] AUDIT_EVENT_TYPE AuditType, [In] uint Flags, [NativeArrayInfo(CountParamIndex = 10)] [In] [Out] [Optional] OBJECT_TYPE_LIST* ObjectTypeList, [In] uint ObjectTypeListLength, [In] GENERIC_MAPPING* GenericMapping, [In] BOOL ObjectCreation, [NativeArrayInfo(CountParamIndex = 10)] [Out] uint* GrantedAccess, [NativeArrayInfo(CountParamIndex = 10)] [Out] uint* AccessStatusList, [Out] int* pfGenerateOnClose);
BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA([Const] [In] PSTR SubsystemName, [In] void* HandleId, [In] HANDLE ClientToken, [Const] [In] PSTR ObjectTypeName, [Const] [In] [Optional] PSTR ObjectName, [In] PSECURITY_DESCRIPTOR SecurityDescriptor, [In] [Optional] PSID PrincipalSelfSid, [In] uint DesiredAccess, [In] AUDIT_EVENT_TYPE AuditType, [In] uint Flags, [NativeArrayInfo(CountParamIndex = 11)] [In] [Out] [Optional] OBJECT_TYPE_LIST* ObjectTypeList, [In] uint ObjectTypeListLength, [In] GENERIC_MAPPING* GenericMapping, [In] BOOL ObjectCreation, [NativeArrayInfo(CountParamIndex = 11)] [Out] uint* GrantedAccess, [NativeArrayInfo(CountParamIndex = 11)] [Out] uint* AccessStatusList, [Out] int* pfGenerateOnClose);
BOOL ObjectOpenAuditAlarmA([Const] [In] PSTR SubsystemName, [In] void* HandleId, [In] PSTR ObjectTypeName, [In] [Optional] PSTR ObjectName, [In] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] HANDLE ClientToken, [In] uint DesiredAccess, [In] uint GrantedAccess, [In] [Optional] PRIVILEGE_SET* Privileges, [In] BOOL ObjectCreation, [In] BOOL AccessGranted, [Out] int* GenerateOnClose);
BOOL ObjectPrivilegeAuditAlarmA([Const] [In] PSTR SubsystemName, [In] void* HandleId, [In] HANDLE ClientToken, [In] uint DesiredAccess, [In] PRIVILEGE_SET* Privileges, [In] BOOL AccessGranted);
BOOL ObjectCloseAuditAlarmA([Const] [In] PSTR SubsystemName, [In] void* HandleId, [In] BOOL GenerateOnClose);
BOOL ObjectDeleteAuditAlarmA([Const] [In] PSTR SubsystemName, [In] void* HandleId, [In] BOOL GenerateOnClose);
BOOL PrivilegedServiceAuditAlarmA([Const] [In] PSTR SubsystemName, [Const] [In] PSTR ServiceName, [In] HANDLE ClientToken, [In] PRIVILEGE_SET* Privileges, [In] BOOL AccessGranted);
BOOL AddConditionalAce([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] ACE_FLAGS AceFlags, [In] byte AceType, [In] uint AccessMask, [In] PSID pSid, [NotNullTerminated] [In] PWSTR ConditionStr, [Out] uint* ReturnLength);
BOOL SetFileSecurityA([Const] [In] PSTR lpFileName, [In] uint SecurityInformation, [In] PSECURITY_DESCRIPTOR pSecurityDescriptor);
BOOL GetFileSecurityA([Const] [In] PSTR lpFileName, [In] uint RequestedInformation, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] uint nLength, [Out] uint* lpnLengthNeeded);
BOOL LookupAccountSidA([Const] [In] [Optional] PSTR lpSystemName, [In] PSID Sid, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PSTR Name, [In] [Out] uint* cchName, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PSTR ReferencedDomainName, [In] [Out] uint* cchReferencedDomainName, [Out] SID_NAME_USE* peUse);
BOOL LookupAccountSidW([Const] [In] [Optional] PWSTR lpSystemName, [In] PSID Sid, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR Name, [In] [Out] uint* cchName, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR ReferencedDomainName, [In] [Out] uint* cchReferencedDomainName, [Out] SID_NAME_USE* peUse);
BOOL LookupAccountNameA([Const] [In] [Optional] PSTR lpSystemName, [Const] [In] PSTR lpAccountName, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PSID Sid, [In] [Out] uint* cbSid, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PSTR ReferencedDomainName, [In] [Out] uint* cchReferencedDomainName, [Out] SID_NAME_USE* peUse);
BOOL LookupAccountNameW([Const] [In] [Optional] PWSTR lpSystemName, [Const] [In] PWSTR lpAccountName, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PSID Sid, [In] [Out] uint* cbSid, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR ReferencedDomainName, [In] [Out] uint* cchReferencedDomainName, [Out] SID_NAME_USE* peUse);
BOOL LookupAccountNameLocalA([Const] [In] PSTR lpAccountName, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] PSID Sid, [In] [Out] uint* cbSid, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PSTR ReferencedDomainName, [In] [Out] uint* cchReferencedDomainName, [Out] SID_NAME_USE* peUse);
BOOL LookupAccountNameLocalW([Const] [In] PWSTR lpAccountName, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] PSID Sid, [In] [Out] uint* cbSid, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PWSTR ReferencedDomainName, [In] [Out] uint* cchReferencedDomainName, [Out] SID_NAME_USE* peUse);
BOOL LookupAccountSidLocalA([In] PSID Sid, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR Name, [In] [Out] uint* cchName, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PSTR ReferencedDomainName, [In] [Out] uint* cchReferencedDomainName, [Out] SID_NAME_USE* peUse);
BOOL LookupAccountSidLocalW([In] PSID Sid, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR Name, [In] [Out] uint* cchName, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PWSTR ReferencedDomainName, [In] [Out] uint* cchReferencedDomainName, [Out] SID_NAME_USE* peUse);
BOOL LookupPrivilegeValueA([Const] [In] [Optional] PSTR lpSystemName, [Const] [In] PSTR lpName, [Out] LUID* lpLuid);
BOOL LookupPrivilegeValueW([Const] [In] [Optional] PWSTR lpSystemName, [Const] [In] PWSTR lpName, [Out] LUID* lpLuid);
BOOL LookupPrivilegeNameA([Const] [In] [Optional] PSTR lpSystemName, [In] LUID* lpLuid, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PSTR lpName, [In] [Out] uint* cchName);
BOOL LookupPrivilegeNameW([Const] [In] [Optional] PWSTR lpSystemName, [In] LUID* lpLuid, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR lpName, [In] [Out] uint* cchName);
BOOL LookupPrivilegeDisplayNameA([Const] [In] [Optional] PSTR lpSystemName, [Const] [In] PSTR lpName, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PSTR lpDisplayName, [In] [Out] uint* cchDisplayName, [Out] uint* lpLanguageId);
BOOL LookupPrivilegeDisplayNameW([Const] [In] [Optional] PWSTR lpSystemName, [Const] [In] PWSTR lpName, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR lpDisplayName, [In] [Out] uint* cchDisplayName, [Out] uint* lpLanguageId);
BOOL LogonUserA([Const] [In] PSTR lpszUsername, [Const] [In] [Optional] PSTR lpszDomain, [Const] [In] [Optional] PSTR lpszPassword, [In] LOGON32_LOGON dwLogonType, [In] LOGON32_PROVIDER dwLogonProvider, [Out] HANDLE* phToken);
BOOL LogonUserW([Const] [In] PWSTR lpszUsername, [Const] [In] [Optional] PWSTR lpszDomain, [Const] [In] [Optional] PWSTR lpszPassword, [In] LOGON32_LOGON dwLogonType, [In] LOGON32_PROVIDER dwLogonProvider, [Out] HANDLE* phToken);
BOOL LogonUserExA([Const] [In] PSTR lpszUsername, [Const] [In] [Optional] PSTR lpszDomain, [Const] [In] [Optional] PSTR lpszPassword, [In] LOGON32_LOGON dwLogonType, [In] LOGON32_PROVIDER dwLogonProvider, [Out] [Optional] HANDLE* phToken, [Out] [Optional] PSID* ppLogonSid, [MemorySize(BytesParamIndex = 8)] [Out] [Optional] void** ppProfileBuffer, [Out] [Optional] uint* pdwProfileLength, [Out] [Optional] QUOTA_LIMITS* pQuotaLimits);
BOOL LogonUserExW([Const] [In] PWSTR lpszUsername, [Const] [In] [Optional] PWSTR lpszDomain, [Const] [In] [Optional] PWSTR lpszPassword, [In] LOGON32_LOGON dwLogonType, [In] LOGON32_PROVIDER dwLogonProvider, [Out] [Optional] HANDLE* phToken, [Out] [Optional] PSID* ppLogonSid, [MemorySize(BytesParamIndex = 8)] [Out] [Optional] void** ppProfileBuffer, [Out] [Optional] uint* pdwProfileLength, [Out] [Optional] QUOTA_LIMITS* pQuotaLimits);
BOOL SaferGetPolicyInformation([In] uint dwScopeId, [In] SAFER_POLICY_INFO_CLASS SaferPolicyInfoClass, [In] uint InfoBufferSize, [MemorySize(BytesParamIndex = 2)] [Out] void* InfoBuffer, [Out] uint* InfoBufferRetSize, [Reserved] [In] [Out] void* lpReserved);
BOOL SaferSetPolicyInformation([In] uint dwScopeId, [In] SAFER_POLICY_INFO_CLASS SaferPolicyInfoClass, [In] uint InfoBufferSize, [MemorySize(BytesParamIndex = 2)] [In] void* InfoBuffer, [Reserved] [In] [Out] void* lpReserved);
BOOL SaferCreateLevel([In] uint dwScopeId, [In] uint dwLevelId, [In] uint OpenFlags, [Out] SAFER_LEVEL_HANDLE* pLevelHandle, [Reserved] [In] [Out] void* lpReserved);
BOOL SaferCloseLevel([In] SAFER_LEVEL_HANDLE hLevelHandle);
BOOL SaferIdentifyLevel([In] uint dwNumProperties, [NativeArrayInfo(CountParamIndex = 0)] [In] [Optional] SAFER_CODE_PROPERTIES_V2* pCodeProperties, [Out] SAFER_LEVEL_HANDLE* pLevelHandle, [In] [Optional] void* lpReserved);
BOOL SaferComputeTokenFromLevel([In] SAFER_LEVEL_HANDLE LevelHandle, [In] [Optional] HANDLE InAccessToken, [Out] HANDLE* OutAccessToken, [In] SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS dwFlags, [In] [Out] [Optional] void* lpReserved);
BOOL SaferGetLevelInformation([In] SAFER_LEVEL_HANDLE LevelHandle, [In] SAFER_OBJECT_INFO_CLASS dwInfoType, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] void* lpQueryBuffer, [In] uint dwInBufferSize, [Out] uint* lpdwOutBufferSize);
BOOL SaferSetLevelInformation([In] SAFER_LEVEL_HANDLE LevelHandle, [In] SAFER_OBJECT_INFO_CLASS dwInfoType, [MemorySize(BytesParamIndex = 3)] [In] void* lpQueryBuffer, [In] uint dwInBufferSize);
BOOL SaferRecordEventLogEntry([In] SAFER_LEVEL_HANDLE hLevel, [Const] [In] PWSTR szTargetPath, [Reserved] [In] [Out] void* lpReserved);
BOOL SaferiIsExecutableFileType([Const] [In] PWSTR szFullPathname, [In] BOOLEAN bFromShellExecute);
NTSTATUS LsaFreeMemory([In] [Optional] void* Buffer);
NTSTATUS LsaClose([In] LSA_HANDLE ObjectHandle);
NTSTATUS LsaOpenPolicy([In] [Optional] UNICODE_STRING* SystemName, [In] OBJECT_ATTRIBUTES* ObjectAttributes, [In] uint DesiredAccess, [Out] LSA_HANDLE* PolicyHandle);
NTSTATUS LsaSetCAPs([NativeArrayInfo(CountParamIndex = 1)] [In] [Optional] UNICODE_STRING* CAPDNs, [In] uint CAPDNCount, [In] uint Flags);
NTSTATUS LsaGetAppliedCAPIDs([In] [Optional] UNICODE_STRING* SystemName, [Out] PSID** CAPIDs, [Out] uint* CAPIDCount);
NTSTATUS LsaQueryCAPs([NativeArrayInfo(CountParamIndex = 1)] [In] [Optional] PSID* CAPIDs, [In] uint CAPIDCount, [Out] CENTRAL_ACCESS_POLICY** CAPs, [Out] uint* CAPCount);
NTSTATUS LsaQueryInformationPolicy([In] LSA_HANDLE PolicyHandle, [In] POLICY_INFORMATION_CLASS InformationClass, [Out] void** Buffer);
NTSTATUS LsaSetInformationPolicy([In] LSA_HANDLE PolicyHandle, [In] POLICY_INFORMATION_CLASS InformationClass, [In] void* Buffer);
NTSTATUS LsaQueryDomainInformationPolicy([In] LSA_HANDLE PolicyHandle, [In] POLICY_DOMAIN_INFORMATION_CLASS InformationClass, [Out] void** Buffer);
NTSTATUS LsaSetDomainInformationPolicy([In] LSA_HANDLE PolicyHandle, [In] POLICY_DOMAIN_INFORMATION_CLASS InformationClass, [In] [Optional] void* Buffer);
NTSTATUS LsaEnumerateTrustedDomains([In] LSA_HANDLE PolicyHandle, [In] [Out] uint* EnumerationContext, [Out] void** Buffer, [In] uint PreferedMaximumLength, [Out] uint* CountReturned);
NTSTATUS LsaLookupNames([In] LSA_HANDLE PolicyHandle, [In] uint Count, [In] UNICODE_STRING* Names, [Out] LSA_REFERENCED_DOMAIN_LIST** ReferencedDomains, [Out] LSA_TRANSLATED_SID** Sids);
NTSTATUS LsaLookupNames2([In] LSA_HANDLE PolicyHandle, [In] uint Flags, [In] uint Count, [In] UNICODE_STRING* Names, [Out] LSA_REFERENCED_DOMAIN_LIST** ReferencedDomains, [Out] LSA_TRANSLATED_SID2** Sids);
NTSTATUS LsaLookupSids([In] LSA_HANDLE PolicyHandle, [In] uint Count, [In] PSID* Sids, [Out] LSA_REFERENCED_DOMAIN_LIST** ReferencedDomains, [Out] LSA_TRANSLATED_NAME** Names);
NTSTATUS LsaLookupSids2([In] LSA_HANDLE PolicyHandle, [In] uint LookupOptions, [In] uint Count, [In] PSID* Sids, [Out] LSA_REFERENCED_DOMAIN_LIST** ReferencedDomains, [Out] LSA_TRANSLATED_NAME** Names);
NTSTATUS LsaEnumerateAccountsWithUserRight([In] LSA_HANDLE PolicyHandle, [In] [Optional] UNICODE_STRING* UserRight, [Out] void** Buffer, [Out] uint* CountReturned);
NTSTATUS LsaEnumerateAccountRights([In] LSA_HANDLE PolicyHandle, [In] PSID AccountSid, [Out] UNICODE_STRING** UserRights, [Out] uint* CountOfRights);
NTSTATUS LsaAddAccountRights([In] LSA_HANDLE PolicyHandle, [In] PSID AccountSid, [NativeArrayInfo(CountParamIndex = 3)] [In] UNICODE_STRING* UserRights, [In] uint CountOfRights);
NTSTATUS LsaRemoveAccountRights([In] LSA_HANDLE PolicyHandle, [In] PSID AccountSid, [In] BOOLEAN AllRights, [NativeArrayInfo(CountParamIndex = 4)] [In] [Optional] UNICODE_STRING* UserRights, [In] uint CountOfRights);
NTSTATUS LsaOpenTrustedDomainByName([In] LSA_HANDLE PolicyHandle, [In] UNICODE_STRING* TrustedDomainName, [In] uint DesiredAccess, [Out] LSA_HANDLE* TrustedDomainHandle);
NTSTATUS LsaQueryTrustedDomainInfo([In] LSA_HANDLE PolicyHandle, [In] PSID TrustedDomainSid, [In] TRUSTED_INFORMATION_CLASS InformationClass, [Out] void** Buffer);
NTSTATUS LsaSetTrustedDomainInformation([In] LSA_HANDLE PolicyHandle, [In] PSID TrustedDomainSid, [In] TRUSTED_INFORMATION_CLASS InformationClass, [In] void* Buffer);
NTSTATUS LsaDeleteTrustedDomain([In] LSA_HANDLE PolicyHandle, [In] PSID TrustedDomainSid);
NTSTATUS LsaQueryTrustedDomainInfoByName([In] LSA_HANDLE PolicyHandle, [In] UNICODE_STRING* TrustedDomainName, [In] TRUSTED_INFORMATION_CLASS InformationClass, [Out] void** Buffer);
NTSTATUS LsaSetTrustedDomainInfoByName([In] LSA_HANDLE PolicyHandle, [In] UNICODE_STRING* TrustedDomainName, [In] TRUSTED_INFORMATION_CLASS InformationClass, [In] void* Buffer);
NTSTATUS LsaEnumerateTrustedDomainsEx([In] LSA_HANDLE PolicyHandle, [In] [Out] uint* EnumerationContext, [Out] void** Buffer, [In] uint PreferedMaximumLength, [Out] uint* CountReturned);
NTSTATUS LsaCreateTrustedDomainEx([In] LSA_HANDLE PolicyHandle, [In] TRUSTED_DOMAIN_INFORMATION_EX* TrustedDomainInformation, [In] TRUSTED_DOMAIN_AUTH_INFORMATION* AuthenticationInformation, [In] uint DesiredAccess, [Out] LSA_HANDLE* TrustedDomainHandle);
NTSTATUS LsaQueryForestTrustInformation([In] LSA_HANDLE PolicyHandle, [In] UNICODE_STRING* TrustedDomainName, [Out] LSA_FOREST_TRUST_INFORMATION** ForestTrustInfo);
NTSTATUS LsaSetForestTrustInformation([In] LSA_HANDLE PolicyHandle, [In] UNICODE_STRING* TrustedDomainName, [In] LSA_FOREST_TRUST_INFORMATION* ForestTrustInfo, [In] BOOLEAN CheckOnly, [Out] LSA_FOREST_TRUST_COLLISION_INFORMATION** CollisionInfo);
NTSTATUS LsaStorePrivateData([In] LSA_HANDLE PolicyHandle, [In] UNICODE_STRING* KeyName, [In] [Optional] UNICODE_STRING* PrivateData);
NTSTATUS LsaRetrievePrivateData([In] LSA_HANDLE PolicyHandle, [In] UNICODE_STRING* KeyName, [Out] UNICODE_STRING** PrivateData);
uint LsaNtStatusToWinError([In] NTSTATUS Status);
BOOLEAN SystemFunction036([MemorySize(BytesParamIndex = 1)] [Out] void* RandomBuffer, [In] uint RandomBufferLength);
NTSTATUS SystemFunction040([MemorySize(BytesParamIndex = 1)] [In] [Out] void* Memory, [In] uint MemorySize, [In] uint OptionFlags);
NTSTATUS SystemFunction041([MemorySize(BytesParamIndex = 1)] [In] [Out] void* Memory, [In] uint MemorySize, [In] uint OptionFlags);
BOOLEAN AuditSetSystemPolicy([NativeArrayInfo(CountParamIndex = 1)] [In] AUDIT_POLICY_INFORMATION* pAuditPolicy, [In] uint dwPolicyCount);
BOOLEAN AuditSetPerUserPolicy([Const] [In] PSID pSid, [NativeArrayInfo(CountParamIndex = 2)] [In] AUDIT_POLICY_INFORMATION* pAuditPolicy, [In] uint dwPolicyCount);
BOOLEAN AuditQuerySystemPolicy([Const] [NativeArrayInfo(CountParamIndex = 1)] [In] Guid* pSubCategoryGuids, [In] uint dwPolicyCount, [Out] AUDIT_POLICY_INFORMATION** ppAuditPolicy);
BOOLEAN AuditQueryPerUserPolicy([Const] [In] PSID pSid, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] Guid* pSubCategoryGuids, [In] uint dwPolicyCount, [Out] AUDIT_POLICY_INFORMATION** ppAuditPolicy);
BOOLEAN AuditEnumeratePerUserPolicy([Out] POLICY_AUDIT_SID_ARRAY** ppAuditSidArray);
BOOLEAN AuditComputeEffectivePolicyBySid([Const] [In] PSID pSid, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] Guid* pSubCategoryGuids, [In] uint dwPolicyCount, [Out] AUDIT_POLICY_INFORMATION** ppAuditPolicy);
BOOLEAN AuditComputeEffectivePolicyByToken([In] HANDLE hTokenHandle, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] Guid* pSubCategoryGuids, [In] uint dwPolicyCount, [Out] AUDIT_POLICY_INFORMATION** ppAuditPolicy);
BOOLEAN AuditEnumerateCategories([Out] Guid** ppAuditCategoriesArray, [Out] uint* pdwCountReturned);
BOOLEAN AuditEnumerateSubCategories([Const] [In] [Optional] Guid* pAuditCategoryGuid, [In] BOOLEAN bRetrieveAllSubCategories, [Out] Guid** ppAuditSubCategoriesArray, [Out] uint* pdwCountReturned);
BOOLEAN AuditLookupCategoryNameW([Const] [In] Guid* pAuditCategoryGuid, [Out] PWSTR* ppszCategoryName);
BOOLEAN AuditLookupCategoryNameA([Const] [In] Guid* pAuditCategoryGuid, [Out] PSTR* ppszCategoryName);
BOOLEAN AuditLookupSubCategoryNameW([Const] [In] Guid* pAuditSubCategoryGuid, [Out] PWSTR* ppszSubCategoryName);
BOOLEAN AuditLookupSubCategoryNameA([Const] [In] Guid* pAuditSubCategoryGuid, [Out] PSTR* ppszSubCategoryName);
BOOLEAN AuditLookupCategoryIdFromCategoryGuid([Const] [In] Guid* pAuditCategoryGuid, [Out] POLICY_AUDIT_EVENT_TYPE* pAuditCategoryId);
BOOLEAN AuditLookupCategoryGuidFromCategoryId([In] POLICY_AUDIT_EVENT_TYPE AuditCategoryId, [Out] Guid* pAuditCategoryGuid);
BOOLEAN AuditSetSecurity([In] uint SecurityInformation, [In] PSECURITY_DESCRIPTOR pSecurityDescriptor);
BOOLEAN AuditQuerySecurity([In] uint SecurityInformation, [Out] PSECURITY_DESCRIPTOR* ppSecurityDescriptor);
BOOLEAN AuditSetGlobalSaclW([Const] [In] PWSTR ObjectTypeName, [In] [Optional] ACL* Acl);
BOOLEAN AuditSetGlobalSaclA([Const] [In] PSTR ObjectTypeName, [In] [Optional] ACL* Acl);
BOOLEAN AuditQueryGlobalSaclW([Const] [In] PWSTR ObjectTypeName, [Out] ACL** Acl);
BOOLEAN AuditQueryGlobalSaclA([Const] [In] PSTR ObjectTypeName, [Out] ACL** Acl);
void AuditFree([In] void* Buffer);
WIN32_ERROR SetEntriesInAclA([In] uint cCountOfExplicitEntries, [NativeArrayInfo(CountParamIndex = 0)] [In] [Optional] EXPLICIT_ACCESS_A* pListOfExplicitEntries, [In] [Optional] ACL* OldAcl, [Out] ACL** NewAcl);
WIN32_ERROR SetEntriesInAclW([In] uint cCountOfExplicitEntries, [NativeArrayInfo(CountParamIndex = 0)] [In] [Optional] EXPLICIT_ACCESS_W* pListOfExplicitEntries, [In] [Optional] ACL* OldAcl, [Out] ACL** NewAcl);
WIN32_ERROR GetExplicitEntriesFromAclA([In] ACL* pacl, [Out] uint* pcCountOfExplicitEntries, [Out] EXPLICIT_ACCESS_A** pListOfExplicitEntries);
WIN32_ERROR GetExplicitEntriesFromAclW([In] ACL* pacl, [Out] uint* pcCountOfExplicitEntries, [Out] EXPLICIT_ACCESS_W** pListOfExplicitEntries);
WIN32_ERROR GetEffectiveRightsFromAclA([In] ACL* pacl, [In] TRUSTEE_A* pTrustee, [Out] uint* pAccessRights);
WIN32_ERROR GetEffectiveRightsFromAclW([In] ACL* pacl, [In] TRUSTEE_W* pTrustee, [Out] uint* pAccessRights);
WIN32_ERROR GetAuditedPermissionsFromAclA([In] ACL* pacl, [In] TRUSTEE_A* pTrustee, [Out] uint* pSuccessfulAuditedRights, [Out] uint* pFailedAuditRights);
WIN32_ERROR GetAuditedPermissionsFromAclW([In] ACL* pacl, [In] TRUSTEE_W* pTrustee, [Out] uint* pSuccessfulAuditedRights, [Out] uint* pFailedAuditRights);
WIN32_ERROR GetNamedSecurityInfoA([Const] [In] PSTR pObjectName, [In] SE_OBJECT_TYPE ObjectType, [In] OBJECT_SECURITY_INFORMATION SecurityInfo, [Out] [Optional] PSID* ppsidOwner, [Out] [Optional] PSID* ppsidGroup, [Out] [Optional] ACL** ppDacl, [Out] [Optional] ACL** ppSacl, [Out] PSECURITY_DESCRIPTOR* ppSecurityDescriptor);
WIN32_ERROR GetNamedSecurityInfoW([Const] [In] PWSTR pObjectName, [In] SE_OBJECT_TYPE ObjectType, [In] OBJECT_SECURITY_INFORMATION SecurityInfo, [Out] [Optional] PSID* ppsidOwner, [Out] [Optional] PSID* ppsidGroup, [Out] [Optional] ACL** ppDacl, [Out] [Optional] ACL** ppSacl, [Out] PSECURITY_DESCRIPTOR* ppSecurityDescriptor);
WIN32_ERROR GetSecurityInfo([In] HANDLE handle, [In] SE_OBJECT_TYPE ObjectType, [In] uint SecurityInfo, [Out] [Optional] PSID* ppsidOwner, [Out] [Optional] PSID* ppsidGroup, [Out] [Optional] ACL** ppDacl, [Out] [Optional] ACL** ppSacl, [Out] [Optional] PSECURITY_DESCRIPTOR* ppSecurityDescriptor);
WIN32_ERROR SetNamedSecurityInfoA([In] PSTR pObjectName, [In] SE_OBJECT_TYPE ObjectType, [In] OBJECT_SECURITY_INFORMATION SecurityInfo, [In] [Optional] PSID psidOwner, [In] [Optional] PSID psidGroup, [In] [Optional] ACL* pDacl, [In] [Optional] ACL* pSacl);
WIN32_ERROR SetNamedSecurityInfoW([In] PWSTR pObjectName, [In] SE_OBJECT_TYPE ObjectType, [In] OBJECT_SECURITY_INFORMATION SecurityInfo, [In] [Optional] PSID psidOwner, [In] [Optional] PSID psidGroup, [In] [Optional] ACL* pDacl, [In] [Optional] ACL* pSacl);
WIN32_ERROR SetSecurityInfo([In] HANDLE handle, [In] SE_OBJECT_TYPE ObjectType, [In] uint SecurityInfo, [In] [Optional] PSID psidOwner, [In] [Optional] PSID psidGroup, [In] [Optional] ACL* pDacl, [In] [Optional] ACL* pSacl);
WIN32_ERROR GetInheritanceSourceA([In] PSTR pObjectName, [In] SE_OBJECT_TYPE ObjectType, [In] uint SecurityInfo, [In] BOOL Container, [NativeArrayInfo(CountParamIndex = 5)] [In] [Optional] Guid** pObjectClassGuids, [In] uint GuidCount, [In] ACL* pAcl, [In] [Optional] FN_OBJECT_MGR_FUNCTS* pfnArray, [In] GENERIC_MAPPING* pGenericMapping, [Out] INHERITED_FROMA* pInheritArray);
WIN32_ERROR GetInheritanceSourceW([In] PWSTR pObjectName, [In] SE_OBJECT_TYPE ObjectType, [In] uint SecurityInfo, [In] BOOL Container, [NativeArrayInfo(CountParamIndex = 5)] [In] [Optional] Guid** pObjectClassGuids, [In] uint GuidCount, [In] ACL* pAcl, [In] [Optional] FN_OBJECT_MGR_FUNCTS* pfnArray, [In] GENERIC_MAPPING* pGenericMapping, [Out] INHERITED_FROMW* pInheritArray);
WIN32_ERROR FreeInheritedFromArray([NativeArrayInfo(CountParamIndex = 1)] [In] INHERITED_FROMW* pInheritArray, [In] ushort AceCnt, [In] [Optional] FN_OBJECT_MGR_FUNCTS* pfnArray);
WIN32_ERROR TreeResetNamedSecurityInfoA([In] PSTR pObjectName, [In] SE_OBJECT_TYPE ObjectType, [In] uint SecurityInfo, [In] [Optional] PSID pOwner, [In] [Optional] PSID pGroup, [In] [Optional] ACL* pDacl, [In] [Optional] ACL* pSacl, [In] BOOL KeepExplicit, [In] [Optional] FN_PROGRESS fnProgress, [In] PROG_INVOKE_SETTING ProgressInvokeSetting, [In] [Optional] void* Args);
WIN32_ERROR TreeResetNamedSecurityInfoW([In] PWSTR pObjectName, [In] SE_OBJECT_TYPE ObjectType, [In] uint SecurityInfo, [In] [Optional] PSID pOwner, [In] [Optional] PSID pGroup, [In] [Optional] ACL* pDacl, [In] [Optional] ACL* pSacl, [In] BOOL KeepExplicit, [In] [Optional] FN_PROGRESS fnProgress, [In] PROG_INVOKE_SETTING ProgressInvokeSetting, [In] [Optional] void* Args);
WIN32_ERROR TreeSetNamedSecurityInfoA([In] PSTR pObjectName, [In] SE_OBJECT_TYPE ObjectType, [In] uint SecurityInfo, [In] [Optional] PSID pOwner, [In] [Optional] PSID pGroup, [In] [Optional] ACL* pDacl, [In] [Optional] ACL* pSacl, [In] TREE_SEC_INFO dwAction, [In] [Optional] FN_PROGRESS fnProgress, [In] PROG_INVOKE_SETTING ProgressInvokeSetting, [In] [Optional] void* Args);
WIN32_ERROR TreeSetNamedSecurityInfoW([In] PWSTR pObjectName, [In] SE_OBJECT_TYPE ObjectType, [In] uint SecurityInfo, [In] [Optional] PSID pOwner, [In] [Optional] PSID pGroup, [In] [Optional] ACL* pDacl, [In] [Optional] ACL* pSacl, [In] TREE_SEC_INFO dwAction, [In] [Optional] FN_PROGRESS fnProgress, [In] PROG_INVOKE_SETTING ProgressInvokeSetting, [In] [Optional] void* Args);
WIN32_ERROR BuildSecurityDescriptorA([In] [Optional] TRUSTEE_A* pOwner, [In] [Optional] TRUSTEE_A* pGroup, [In] uint cCountOfAccessEntries, [NativeArrayInfo(CountParamIndex = 2)] [In] [Optional] EXPLICIT_ACCESS_A* pListOfAccessEntries, [In] uint cCountOfAuditEntries, [NativeArrayInfo(CountParamIndex = 4)] [In] [Optional] EXPLICIT_ACCESS_A* pListOfAuditEntries, [In] [Optional] PSECURITY_DESCRIPTOR pOldSD, [Out] uint* pSizeNewSD, [Out] PSECURITY_DESCRIPTOR* pNewSD);
WIN32_ERROR BuildSecurityDescriptorW([In] [Optional] TRUSTEE_W* pOwner, [In] [Optional] TRUSTEE_W* pGroup, [In] uint cCountOfAccessEntries, [NativeArrayInfo(CountParamIndex = 2)] [In] [Optional] EXPLICIT_ACCESS_W* pListOfAccessEntries, [In] uint cCountOfAuditEntries, [NativeArrayInfo(CountParamIndex = 4)] [In] [Optional] EXPLICIT_ACCESS_W* pListOfAuditEntries, [In] [Optional] PSECURITY_DESCRIPTOR pOldSD, [Out] uint* pSizeNewSD, [Out] PSECURITY_DESCRIPTOR* pNewSD);
WIN32_ERROR LookupSecurityDescriptorPartsA([Out] [Optional] TRUSTEE_A** ppOwner, [Out] [Optional] TRUSTEE_A** ppGroup, [Out] [Optional] uint* pcCountOfAccessEntries, [Out] [Optional] EXPLICIT_ACCESS_A** ppListOfAccessEntries, [Out] [Optional] uint* pcCountOfAuditEntries, [Out] [Optional] EXPLICIT_ACCESS_A** ppListOfAuditEntries, [In] PSECURITY_DESCRIPTOR pSD);
WIN32_ERROR LookupSecurityDescriptorPartsW([Out] [Optional] TRUSTEE_W** ppOwner, [Out] [Optional] TRUSTEE_W** ppGroup, [Out] [Optional] uint* pcCountOfAccessEntries, [Out] [Optional] EXPLICIT_ACCESS_W** ppListOfAccessEntries, [Out] [Optional] uint* pcCountOfAuditEntries, [Out] [Optional] EXPLICIT_ACCESS_W** ppListOfAuditEntries, [In] PSECURITY_DESCRIPTOR pSD);
void BuildExplicitAccessWithNameA([In] [Out] EXPLICIT_ACCESS_A* pExplicitAccess, [In] [Optional] PSTR pTrusteeName, [In] uint AccessPermissions, [In] ACCESS_MODE AccessMode, [In] ACE_FLAGS Inheritance);
void BuildExplicitAccessWithNameW([In] [Out] EXPLICIT_ACCESS_W* pExplicitAccess, [In] [Optional] PWSTR pTrusteeName, [In] uint AccessPermissions, [In] ACCESS_MODE AccessMode, [In] ACE_FLAGS Inheritance);
void BuildImpersonateExplicitAccessWithNameA([In] [Out] EXPLICIT_ACCESS_A* pExplicitAccess, [In] [Optional] PSTR pTrusteeName, [In] [Optional] TRUSTEE_A* pTrustee, [In] uint AccessPermissions, [In] ACCESS_MODE AccessMode, [In] uint Inheritance);
void BuildImpersonateExplicitAccessWithNameW([In] [Out] EXPLICIT_ACCESS_W* pExplicitAccess, [In] [Optional] PWSTR pTrusteeName, [In] [Optional] TRUSTEE_W* pTrustee, [In] uint AccessPermissions, [In] ACCESS_MODE AccessMode, [In] uint Inheritance);
void BuildTrusteeWithNameA([In] [Out] TRUSTEE_A* pTrustee, [In] [Optional] PSTR pName);
void BuildTrusteeWithNameW([In] [Out] TRUSTEE_W* pTrustee, [In] [Optional] PWSTR pName);
void BuildImpersonateTrusteeA([In] [Out] TRUSTEE_A* pTrustee, [In] [Optional] TRUSTEE_A* pImpersonateTrustee);
void BuildImpersonateTrusteeW([In] [Out] TRUSTEE_W* pTrustee, [In] [Optional] TRUSTEE_W* pImpersonateTrustee);
void BuildTrusteeWithSidA([In] [Out] TRUSTEE_A* pTrustee, [In] [Optional] PSID pSid);
void BuildTrusteeWithSidW([In] [Out] TRUSTEE_W* pTrustee, [In] [Optional] PSID pSid);
void BuildTrusteeWithObjectsAndSidA([In] [Out] TRUSTEE_A* pTrustee, [In] [Optional] OBJECTS_AND_SID* pObjSid, [In] [Optional] Guid* pObjectGuid, [In] [Optional] Guid* pInheritedObjectGuid, [In] [Optional] PSID pSid);
void BuildTrusteeWithObjectsAndSidW([In] [Out] TRUSTEE_W* pTrustee, [In] [Optional] OBJECTS_AND_SID* pObjSid, [In] [Optional] Guid* pObjectGuid, [In] [Optional] Guid* pInheritedObjectGuid, [In] [Optional] PSID pSid);
void BuildTrusteeWithObjectsAndNameA([In] [Out] TRUSTEE_A* pTrustee, [In] [Optional] OBJECTS_AND_NAME_A* pObjName, [In] [Optional] SE_OBJECT_TYPE ObjectType, [In] [Optional] PSTR ObjectTypeName, [In] [Optional] PSTR InheritedObjectTypeName, [In] [Optional] PSTR Name);
void BuildTrusteeWithObjectsAndNameW([In] [Out] TRUSTEE_W* pTrustee, [In] [Optional] OBJECTS_AND_NAME_W* pObjName, [In] [Optional] SE_OBJECT_TYPE ObjectType, [In] [Optional] PWSTR ObjectTypeName, [In] [Optional] PWSTR InheritedObjectTypeName, [In] [Optional] PWSTR Name);
PSTR GetTrusteeNameA([In] TRUSTEE_A* pTrustee);
PWSTR GetTrusteeNameW([In] TRUSTEE_W* pTrustee);
TRUSTEE_TYPE GetTrusteeTypeA([In] [Optional] TRUSTEE_A* pTrustee);
TRUSTEE_TYPE GetTrusteeTypeW([In] [Optional] TRUSTEE_W* pTrustee);
TRUSTEE_FORM GetTrusteeFormA([In] TRUSTEE_A* pTrustee);
TRUSTEE_FORM GetTrusteeFormW([In] TRUSTEE_W* pTrustee);
MULTIPLE_TRUSTEE_OPERATION GetMultipleTrusteeOperationA([In] [Optional] TRUSTEE_A* pTrustee);
MULTIPLE_TRUSTEE_OPERATION GetMultipleTrusteeOperationW([In] [Optional] TRUSTEE_W* pTrustee);
TRUSTEE_A* GetMultipleTrusteeA([In] [Optional] TRUSTEE_A* pTrustee);
TRUSTEE_W* GetMultipleTrusteeW([In] [Optional] TRUSTEE_W* pTrustee);
BOOL ConvertSidToStringSidA([In] PSID Sid, [Out] PSTR* StringSid);
BOOL ConvertSidToStringSidW([In] PSID Sid, [Out] PWSTR* StringSid);
BOOL ConvertStringSidToSidA([Const] [In] PSTR StringSid, [Out] PSID* Sid);
BOOL ConvertStringSidToSidW([Const] [In] PWSTR StringSid, [Out] PSID* Sid);
BOOL ConvertStringSecurityDescriptorToSecurityDescriptorA([Const] [In] PSTR StringSecurityDescriptor, [In] uint StringSDRevision, [Out] PSECURITY_DESCRIPTOR* SecurityDescriptor, [Out] [Optional] uint* SecurityDescriptorSize);
BOOL ConvertStringSecurityDescriptorToSecurityDescriptorW([Const] [In] PWSTR StringSecurityDescriptor, [In] uint StringSDRevision, [Out] PSECURITY_DESCRIPTOR* SecurityDescriptor, [Out] [Optional] uint* SecurityDescriptorSize);
BOOL ConvertSecurityDescriptorToStringSecurityDescriptorA([In] PSECURITY_DESCRIPTOR SecurityDescriptor, [In] uint RequestedStringSDRevision, [In] uint SecurityInformation, [Out] PSTR* StringSecurityDescriptor, [Out] [Optional] uint* StringSecurityDescriptorLen);
BOOL ConvertSecurityDescriptorToStringSecurityDescriptorW([In] PSECURITY_DESCRIPTOR SecurityDescriptor, [In] uint RequestedStringSDRevision, [In] uint SecurityInformation, [Out] PWSTR* StringSecurityDescriptor, [Out] [Optional] uint* StringSecurityDescriptorLen);
BOOL CredWriteW([In] CREDENTIALW* Credential, [In] uint Flags);
BOOL CredWriteA([In] CREDENTIALA* Credential, [In] uint Flags);
BOOL CredReadW([Const] [In] PWSTR TargetName, [In] uint Type, [Reserved] [In] uint Flags, [Out] CREDENTIALW** Credential);
BOOL CredReadA([Const] [In] PSTR TargetName, [In] uint Type, [Reserved] [In] uint Flags, [Out] CREDENTIALA** Credential);
BOOL CredEnumerateW([Const] [In] [Optional] PWSTR Filter, [Reserved] [In] CRED_ENUMERATE_FLAGS Flags, [Out] uint* Count, [Out] CREDENTIALW*** Credential);
BOOL CredEnumerateA([Const] [In] [Optional] PSTR Filter, [Reserved] [In] CRED_ENUMERATE_FLAGS Flags, [Out] uint* Count, [Out] CREDENTIALA*** Credential);
BOOL CredWriteDomainCredentialsW([In] CREDENTIAL_TARGET_INFORMATIONW* TargetInfo, [In] CREDENTIALW* Credential, [In] uint Flags);
BOOL CredWriteDomainCredentialsA([In] CREDENTIAL_TARGET_INFORMATIONA* TargetInfo, [In] CREDENTIALA* Credential, [In] uint Flags);
BOOL CredReadDomainCredentialsW([In] CREDENTIAL_TARGET_INFORMATIONW* TargetInfo, [In] uint Flags, [Out] uint* Count, [Out] CREDENTIALW*** Credential);
BOOL CredReadDomainCredentialsA([In] CREDENTIAL_TARGET_INFORMATIONA* TargetInfo, [In] uint Flags, [Out] uint* Count, [Out] CREDENTIALA*** Credential);
BOOL CredDeleteW([Const] [In] PWSTR TargetName, [In] uint Type, [Reserved] [In] uint Flags);
BOOL CredDeleteA([Const] [In] PSTR TargetName, [In] uint Type, [Reserved] [In] uint Flags);
BOOL CredRenameW([Const] [In] PWSTR OldTargetName, [Const] [In] PWSTR NewTargetName, [In] uint Type, [Reserved] [In] uint Flags);
BOOL CredRenameA([Const] [In] PSTR OldTargetName, [Const] [In] PSTR NewTargetName, [In] uint Type, [Reserved] [In] uint Flags);
BOOL CredGetTargetInfoW([Const] [In] PWSTR TargetName, [In] uint Flags, [Out] CREDENTIAL_TARGET_INFORMATIONW** TargetInfo);
BOOL CredGetTargetInfoA([Const] [In] PSTR TargetName, [In] uint Flags, [Out] CREDENTIAL_TARGET_INFORMATIONA** TargetInfo);
BOOL CredMarshalCredentialW([In] CRED_MARSHAL_TYPE CredType, [In] void* Credential, [Out] PWSTR* MarshaledCredential);
BOOL CredMarshalCredentialA([In] CRED_MARSHAL_TYPE CredType, [In] void* Credential, [Out] PSTR* MarshaledCredential);
BOOL CredUnmarshalCredentialW([Const] [In] PWSTR MarshaledCredential, [Out] CRED_MARSHAL_TYPE* CredType, [Out] void** Credential);
BOOL CredUnmarshalCredentialA([Const] [In] PSTR MarshaledCredential, [Out] CRED_MARSHAL_TYPE* CredType, [Out] void** Credential);
BOOL CredIsMarshaledCredentialW([Const] [In] PWSTR MarshaledCredential);
BOOL CredIsMarshaledCredentialA([Const] [In] PSTR MarshaledCredential);
BOOL CredProtectW([In] BOOL fAsSelf, [NativeArrayInfo(CountParamIndex = 2)] [In] PWSTR pszCredentials, [In] uint cchCredentials, [NativeArrayInfo(CountParamIndex = 4)] [Out] PWSTR pszProtectedCredentials, [In] [Out] uint* pcchMaxChars, [Out] [Optional] CRED_PROTECTION_TYPE* ProtectionType);
BOOL CredProtectA([In] BOOL fAsSelf, [NativeArrayInfo(CountParamIndex = 2)] [In] PSTR pszCredentials, [In] uint cchCredentials, [NativeArrayInfo(CountParamIndex = 4)] [Out] PSTR pszProtectedCredentials, [In] [Out] uint* pcchMaxChars, [Out] [Optional] CRED_PROTECTION_TYPE* ProtectionType);
BOOL CredUnprotectW([In] BOOL fAsSelf, [NativeArrayInfo(CountParamIndex = 2)] [In] PWSTR pszProtectedCredentials, [In] uint cchProtectedCredentials, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PWSTR pszCredentials, [In] [Out] uint* pcchMaxChars);
BOOL CredUnprotectA([In] BOOL fAsSelf, [NativeArrayInfo(CountParamIndex = 2)] [In] PSTR pszProtectedCredentials, [In] uint cchProtectedCredentials, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PSTR pszCredentials, [In] [Out] uint* pcchMaxChars);
BOOL CredIsProtectedW([In] PWSTR pszProtectedCredentials, [Out] CRED_PROTECTION_TYPE* pProtectionType);
BOOL CredIsProtectedA([In] PSTR pszProtectedCredentials, [Out] CRED_PROTECTION_TYPE* pProtectionType);
BOOL CredFindBestCredentialW([Const] [In] PWSTR TargetName, [In] uint Type, [In] uint Flags, [Out] CREDENTIALW** Credential);
BOOL CredFindBestCredentialA([Const] [In] PSTR TargetName, [In] uint Type, [In] uint Flags, [Out] CREDENTIALA** Credential);
BOOL CredGetSessionTypes([In] uint MaximumPersistCount, [NativeArrayInfo(CountParamIndex = 0)] [Out] uint* MaximumPersist);
void CredFree([In] void* Buffer);
BOOL CryptAcquireContextA([Out] nuint* phProv, [Const] [In] [Optional] PSTR szContainer, [Const] [In] [Optional] PSTR szProvider, [In] uint dwProvType, [In] uint dwFlags);
BOOL CryptAcquireContextW([Out] nuint* phProv, [Const] [In] [Optional] PWSTR szContainer, [Const] [In] [Optional] PWSTR szProvider, [In] uint dwProvType, [In] uint dwFlags);
BOOL CryptReleaseContext([In] nuint hProv, [In] uint dwFlags);
BOOL CryptGenKey([In] nuint hProv, [In] uint Algid, [In] CRYPT_KEY_FLAGS dwFlags, [Out] nuint* phKey);
BOOL CryptDeriveKey([In] nuint hProv, [In] uint Algid, [In] nuint hBaseData, [In] uint dwFlags, [Out] nuint* phKey);
BOOL CryptDestroyKey([In] nuint hKey);
BOOL CryptSetKeyParam([In] nuint hKey, [In] CRYPT_KEY_PARAM_ID dwParam, [Const] [In] byte* pbData, [In] uint dwFlags);
BOOL CryptGetKeyParam([In] nuint hKey, [In] CRYPT_KEY_PARAM_ID dwParam, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] byte* pbData, [In] [Out] uint* pdwDataLen, [In] uint dwFlags);
BOOL CryptSetHashParam([In] nuint hHash, [In] CRYPT_SET_HASH_PARAM dwParam, [Const] [In] byte* pbData, [In] uint dwFlags);
BOOL CryptGetHashParam([In] nuint hHash, [In] uint dwParam, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] byte* pbData, [In] [Out] uint* pdwDataLen, [In] uint dwFlags);
BOOL CryptSetProvParam([In] nuint hProv, [In] CRYPT_SET_PROV_PARAM_ID dwParam, [Const] [In] byte* pbData, [In] uint dwFlags);
BOOL CryptGetProvParam([In] nuint hProv, [In] uint dwParam, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] byte* pbData, [In] [Out] uint* pdwDataLen, [In] uint dwFlags);
BOOL CryptGenRandom([In] nuint hProv, [In] uint dwLen, [MemorySize(BytesParamIndex = 1)] [In] [Out] byte* pbBuffer);
BOOL CryptGetUserKey([In] nuint hProv, [In] uint dwKeySpec, [Out] nuint* phUserKey);
BOOL CryptExportKey([In] nuint hKey, [In] nuint hExpKey, [In] uint dwBlobType, [In] CRYPT_KEY_FLAGS dwFlags, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] byte* pbData, [In] [Out] uint* pdwDataLen);
BOOL CryptImportKey([In] nuint hProv, [Const] [MemorySize(BytesParamIndex = 2)] [In] byte* pbData, [In] uint dwDataLen, [In] nuint hPubKey, [In] CRYPT_KEY_FLAGS dwFlags, [Out] nuint* phKey);
BOOL CryptEncrypt([In] nuint hKey, [In] nuint hHash, [In] BOOL Final, [In] uint dwFlags, [MemorySize(BytesParamIndex = 6)] [In] [Out] [Optional] byte* pbData, [In] [Out] uint* pdwDataLen, [In] uint dwBufLen);
BOOL CryptDecrypt([In] nuint hKey, [In] nuint hHash, [In] BOOL Final, [In] uint dwFlags, [MemorySize(BytesParamIndex = 5)] [In] [Out] byte* pbData, [In] [Out] uint* pdwDataLen);
BOOL CryptCreateHash([In] nuint hProv, [In] uint Algid, [In] nuint hKey, [In] uint dwFlags, [Out] nuint* phHash);
BOOL CryptHashData([In] nuint hHash, [Const] [MemorySize(BytesParamIndex = 2)] [In] byte* pbData, [In] uint dwDataLen, [In] uint dwFlags);
BOOL CryptHashSessionKey([In] nuint hHash, [In] nuint hKey, [In] uint dwFlags);
BOOL CryptDestroyHash([In] nuint hHash);
BOOL CryptSignHashA([In] nuint hHash, [In] uint dwKeySpec, [Const] [In] [Optional] PSTR szDescription, [In] uint dwFlags, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] byte* pbSignature, [In] [Out] uint* pdwSigLen);
BOOL CryptSignHashW([In] nuint hHash, [In] uint dwKeySpec, [Const] [In] [Optional] PWSTR szDescription, [In] uint dwFlags, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] byte* pbSignature, [In] [Out] uint* pdwSigLen);
BOOL CryptVerifySignatureA([In] nuint hHash, [Const] [MemorySize(BytesParamIndex = 2)] [In] byte* pbSignature, [In] uint dwSigLen, [In] nuint hPubKey, [Const] [In] [Optional] PSTR szDescription, [In] uint dwFlags);
BOOL CryptVerifySignatureW([In] nuint hHash, [Const] [MemorySize(BytesParamIndex = 2)] [In] byte* pbSignature, [In] uint dwSigLen, [In] nuint hPubKey, [Const] [In] [Optional] PWSTR szDescription, [In] uint dwFlags);
BOOL CryptSetProviderA([Const] [In] PSTR pszProvName, [In] uint dwProvType);
BOOL CryptSetProviderW([Const] [In] PWSTR pszProvName, [In] uint dwProvType);
BOOL CryptSetProviderExA([Const] [In] PSTR pszProvName, [In] uint dwProvType, [Reserved] [In] [Out] uint* pdwReserved, [In] uint dwFlags);
BOOL CryptSetProviderExW([Const] [In] PWSTR pszProvName, [In] uint dwProvType, [Reserved] [In] [Out] uint* pdwReserved, [In] uint dwFlags);
BOOL CryptGetDefaultProviderA([In] uint dwProvType, [Reserved] [In] [Out] uint* pdwReserved, [In] uint dwFlags, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] PSTR pszProvName, [In] [Out] uint* pcbProvName);
BOOL CryptGetDefaultProviderW([In] uint dwProvType, [Reserved] [In] [Out] uint* pdwReserved, [In] uint dwFlags, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] PWSTR pszProvName, [In] [Out] uint* pcbProvName);
BOOL CryptEnumProviderTypesA([In] uint dwIndex, [Reserved] [In] [Out] uint* pdwReserved, [In] uint dwFlags, [Out] uint* pdwProvType, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] PSTR szTypeName, [In] [Out] uint* pcbTypeName);
BOOL CryptEnumProviderTypesW([In] uint dwIndex, [Reserved] [In] [Out] uint* pdwReserved, [In] uint dwFlags, [Out] uint* pdwProvType, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] PWSTR szTypeName, [In] [Out] uint* pcbTypeName);
BOOL CryptEnumProvidersA([In] uint dwIndex, [Reserved] [In] [Out] uint* pdwReserved, [In] uint dwFlags, [Out] uint* pdwProvType, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] PSTR szProvName, [In] [Out] uint* pcbProvName);
BOOL CryptEnumProvidersW([In] uint dwIndex, [Reserved] [In] [Out] uint* pdwReserved, [In] uint dwFlags, [Out] uint* pdwProvType, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] PWSTR szProvName, [In] [Out] uint* pcbProvName);
BOOL CryptContextAddRef([In] nuint hProv, [Reserved] [In] [Out] uint* pdwReserved, [In] uint dwFlags);
BOOL CryptDuplicateKey([In] nuint hKey, [Reserved] [In] [Out] uint* pdwReserved, [In] uint dwFlags, [Out] nuint* phKey);
BOOL CryptDuplicateHash([In] nuint hHash, [Reserved] [In] [Out] uint* pdwReserved, [In] uint dwFlags, [Out] nuint* phHash);
uint QueryUsersOnEncryptedFile([Const] [In] PWSTR lpFileName, [Out] ENCRYPTION_CERTIFICATE_HASH_LIST** pUsers);
uint QueryRecoveryAgentsOnEncryptedFile([Const] [In] PWSTR lpFileName, [Out] ENCRYPTION_CERTIFICATE_HASH_LIST** pRecoveryAgents);
uint RemoveUsersFromEncryptedFile([Const] [In] PWSTR lpFileName, [In] ENCRYPTION_CERTIFICATE_HASH_LIST* pHashes);
uint AddUsersToEncryptedFile([Const] [In] PWSTR lpFileName, [In] ENCRYPTION_CERTIFICATE_LIST* pEncryptionCertificates);
uint SetUserFileEncryptionKey([In] [Optional] ENCRYPTION_CERTIFICATE* pEncryptionCertificate);
uint SetUserFileEncryptionKeyEx([In] [Optional] ENCRYPTION_CERTIFICATE* pEncryptionCertificate, [In] uint dwCapabilities, [In] uint dwFlags, [Reserved] [In] [Out] void* pvReserved);
void FreeEncryptionCertificateHashList([In] ENCRYPTION_CERTIFICATE_HASH_LIST* pUsers);
BOOL EncryptionDisable([Const] [In] PWSTR DirPath, [In] BOOL Disable);
uint DuplicateEncryptionInfoFile([Const] [In] PWSTR SrcFileName, [Const] [In] PWSTR DstFileName, [In] uint dwCreationDistribution, [In] uint dwAttributes, [Const] [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes);
uint GetEncryptedFileMetadata([Const] [In] PWSTR lpFileName, [Out] uint* pcbMetadata, [Out] byte** ppbMetadata);
uint SetEncryptedFileMetadata([Const] [In] PWSTR lpFileName, [In] [Optional] byte* pbOldMetadata, [In] byte* pbNewMetadata, [In] ENCRYPTION_CERTIFICATE_HASH* pOwnerHash, [In] uint dwOperation, [In] [Optional] ENCRYPTION_CERTIFICATE_HASH_LIST* pCertificatesAdded);
void FreeEncryptedFileMetadata([In] byte* pbMetadata);
BOOL EncryptFileA([Const] [In] PSTR lpFileName);
BOOL EncryptFileW([Const] [In] PWSTR lpFileName);
BOOL DecryptFileA([Const] [In] PSTR lpFileName, [Reserved] [In] uint dwReserved);
BOOL DecryptFileW([Const] [In] PWSTR lpFileName, [Reserved] [In] uint dwReserved);
BOOL FileEncryptionStatusA([Const] [In] PSTR lpFileName, [Out] uint* lpStatus);
BOOL FileEncryptionStatusW([Const] [In] PWSTR lpFileName, [Out] uint* lpStatus);
uint OpenEncryptedFileRawA([Const] [In] PSTR lpFileName, [In] uint ulFlags, [Out] void** pvContext);
uint OpenEncryptedFileRawW([Const] [In] PWSTR lpFileName, [In] uint ulFlags, [Out] void** pvContext);
uint ReadEncryptedFileRaw([In] PFE_EXPORT_FUNC pfExportCallback, [In] [Optional] void* pvCallbackContext, [In] void* pvContext);
uint WriteEncryptedFileRaw([In] PFE_IMPORT_FUNC pfImportCallback, [In] [Optional] void* pvCallbackContext, [In] void* pvContext);
void CloseEncryptedFileRaw([In] void* pvContext);
BOOL OperationStart([In] OPERATION_START_PARAMETERS* OperationStartParams);
BOOL OperationEnd([In] OPERATION_END_PARAMETERS* OperationEndParams);
BOOL ClearEventLogA([In] EventLogHandle hEventLog, [Const] [In] [Optional] PSTR lpBackupFileName);
BOOL ClearEventLogW([In] EventLogHandle hEventLog, [Const] [In] [Optional] PWSTR lpBackupFileName);
BOOL BackupEventLogA([In] EventLogHandle hEventLog, [Const] [In] PSTR lpBackupFileName);
BOOL BackupEventLogW([In] EventLogHandle hEventLog, [Const] [In] PWSTR lpBackupFileName);
BOOL CloseEventLog([In] EventLogHandle hEventLog);
BOOL DeregisterEventSource([In] EventSourceHandle hEventLog);
BOOL NotifyChangeEventLog([In] EventLogHandle hEventLog, [In] HANDLE hEvent);
BOOL GetNumberOfEventLogRecords([In] EventLogHandle hEventLog, [Out] uint* NumberOfRecords);
BOOL GetOldestEventLogRecord([In] EventLogHandle hEventLog, [Out] uint* OldestRecord);
EventLogHandle OpenEventLogA([Const] [In] [Optional] PSTR lpUNCServerName, [Const] [In] PSTR lpSourceName);
EventLogHandle OpenEventLogW([Const] [In] [Optional] PWSTR lpUNCServerName, [Const] [In] PWSTR lpSourceName);
EventSourceHandle RegisterEventSourceA([Const] [In] [Optional] PSTR lpUNCServerName, [Const] [In] PSTR lpSourceName);
EventSourceHandle RegisterEventSourceW([Const] [In] [Optional] PWSTR lpUNCServerName, [Const] [In] PWSTR lpSourceName);
EventLogHandle OpenBackupEventLogA([Const] [In] [Optional] PSTR lpUNCServerName, [Const] [In] PSTR lpFileName);
EventLogHandle OpenBackupEventLogW([Const] [In] [Optional] PWSTR lpUNCServerName, [Const] [In] PWSTR lpFileName);
BOOL ReadEventLogA([In] EventLogHandle hEventLog, [In] READ_EVENT_LOG_READ_FLAGS dwReadFlags, [In] uint dwRecordOffset, [MemorySize(BytesParamIndex = 4)] [Out] void* lpBuffer, [In] uint nNumberOfBytesToRead, [Out] uint* pnBytesRead, [Out] uint* pnMinNumberOfBytesNeeded);
BOOL ReadEventLogW([In] EventLogHandle hEventLog, [In] READ_EVENT_LOG_READ_FLAGS dwReadFlags, [In] uint dwRecordOffset, [MemorySize(BytesParamIndex = 4)] [Out] void* lpBuffer, [In] uint nNumberOfBytesToRead, [Out] uint* pnBytesRead, [Out] uint* pnMinNumberOfBytesNeeded);
BOOL ReportEventA([In] EventSourceHandle hEventLog, [In] REPORT_EVENT_TYPE wType, [In] ushort wCategory, [In] uint dwEventID, [In] [Optional] PSID lpUserSid, [In] ushort wNumStrings, [In] uint dwDataSize, [NativeArrayInfo(CountParamIndex = 5)] [In] [Optional] PSTR* lpStrings, [MemorySize(BytesParamIndex = 6)] [In] [Optional] void* lpRawData);
BOOL ReportEventW([In] EventSourceHandle hEventLog, [In] REPORT_EVENT_TYPE wType, [In] ushort wCategory, [In] uint dwEventID, [In] [Optional] PSID lpUserSid, [In] ushort wNumStrings, [In] uint dwDataSize, [NativeArrayInfo(CountParamIndex = 5)] [In] [Optional] PWSTR* lpStrings, [MemorySize(BytesParamIndex = 6)] [In] [Optional] void* lpRawData);
BOOL GetEventLogInformation([In] EventLogHandle hEventLog, [In] uint dwInfoLevel, [MemorySize(BytesParamIndex = 3)] [Out] void* lpBuffer, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded);
BOOL SetServiceBits([In] SERVICE_STATUS_HANDLE hServiceStatus, [In] uint dwServiceBits, [In] BOOL bSetBitsOn, [In] BOOL bUpdateImmediately);
BOOL ChangeServiceConfigA([In] SC_HANDLE hService, [In] uint dwServiceType, [In] SERVICE_START_TYPE dwStartType, [In] SERVICE_ERROR dwErrorControl, [Const] [In] [Optional] PSTR lpBinaryPathName, [Const] [In] [Optional] PSTR lpLoadOrderGroup, [Out] [Optional] uint* lpdwTagId, [Const] [In] [Optional] PSTR lpDependencies, [Const] [In] [Optional] PSTR lpServiceStartName, [Const] [In] [Optional] PSTR lpPassword, [Const] [In] [Optional] PSTR lpDisplayName);
BOOL ChangeServiceConfigW([In] SC_HANDLE hService, [In] uint dwServiceType, [In] SERVICE_START_TYPE dwStartType, [In] SERVICE_ERROR dwErrorControl, [Const] [In] [Optional] PWSTR lpBinaryPathName, [Const] [In] [Optional] PWSTR lpLoadOrderGroup, [Out] [Optional] uint* lpdwTagId, [Const] [In] [Optional] PWSTR lpDependencies, [Const] [In] [Optional] PWSTR lpServiceStartName, [Const] [In] [Optional] PWSTR lpPassword, [Const] [In] [Optional] PWSTR lpDisplayName);
BOOL ChangeServiceConfig2A([In] SC_HANDLE hService, [In] SERVICE_CONFIG dwInfoLevel, [In] [Optional] void* lpInfo);
BOOL ChangeServiceConfig2W([In] SC_HANDLE hService, [In] SERVICE_CONFIG dwInfoLevel, [In] [Optional] void* lpInfo);
BOOL CloseServiceHandle([In] SC_HANDLE hSCObject);
BOOL ControlService([In] SC_HANDLE hService, [In] uint dwControl, [Out] SERVICE_STATUS* lpServiceStatus);
SC_HANDLE CreateServiceA([In] SC_HANDLE hSCManager, [Const] [In] PSTR lpServiceName, [Const] [In] [Optional] PSTR lpDisplayName, [In] uint dwDesiredAccess, [In] ENUM_SERVICE_TYPE dwServiceType, [In] SERVICE_START_TYPE dwStartType, [In] SERVICE_ERROR dwErrorControl, [Const] [In] [Optional] PSTR lpBinaryPathName, [Const] [In] [Optional] PSTR lpLoadOrderGroup, [Out] [Optional] uint* lpdwTagId, [Const] [In] [Optional] PSTR lpDependencies, [Const] [In] [Optional] PSTR lpServiceStartName, [Const] [In] [Optional] PSTR lpPassword);
SC_HANDLE CreateServiceW([In] SC_HANDLE hSCManager, [Const] [In] PWSTR lpServiceName, [Const] [In] [Optional] PWSTR lpDisplayName, [In] uint dwDesiredAccess, [In] ENUM_SERVICE_TYPE dwServiceType, [In] SERVICE_START_TYPE dwStartType, [In] SERVICE_ERROR dwErrorControl, [Const] [In] [Optional] PWSTR lpBinaryPathName, [Const] [In] [Optional] PWSTR lpLoadOrderGroup, [Out] [Optional] uint* lpdwTagId, [Const] [In] [Optional] PWSTR lpDependencies, [Const] [In] [Optional] PWSTR lpServiceStartName, [Const] [In] [Optional] PWSTR lpPassword);
BOOL DeleteService([In] SC_HANDLE hService);
BOOL EnumDependentServicesA([In] SC_HANDLE hService, [In] ENUM_SERVICE_STATE dwServiceState, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] ENUM_SERVICE_STATUSA* lpServices, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded, [Out] uint* lpServicesReturned);
BOOL EnumDependentServicesW([In] SC_HANDLE hService, [In] ENUM_SERVICE_STATE dwServiceState, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] ENUM_SERVICE_STATUSW* lpServices, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded, [Out] uint* lpServicesReturned);
BOOL EnumServicesStatusA([In] SC_HANDLE hSCManager, [In] ENUM_SERVICE_TYPE dwServiceType, [In] ENUM_SERVICE_STATE dwServiceState, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] ENUM_SERVICE_STATUSA* lpServices, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded, [Out] uint* lpServicesReturned, [In] [Out] [Optional] uint* lpResumeHandle);
BOOL EnumServicesStatusW([In] SC_HANDLE hSCManager, [In] ENUM_SERVICE_TYPE dwServiceType, [In] ENUM_SERVICE_STATE dwServiceState, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] ENUM_SERVICE_STATUSW* lpServices, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded, [Out] uint* lpServicesReturned, [In] [Out] [Optional] uint* lpResumeHandle);
BOOL EnumServicesStatusExA([In] SC_HANDLE hSCManager, [In] SC_ENUM_TYPE InfoLevel, [In] ENUM_SERVICE_TYPE dwServiceType, [In] ENUM_SERVICE_STATE dwServiceState, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] byte* lpServices, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded, [Out] uint* lpServicesReturned, [In] [Out] [Optional] uint* lpResumeHandle, [Const] [In] [Optional] PSTR pszGroupName);
BOOL EnumServicesStatusExW([In] SC_HANDLE hSCManager, [In] SC_ENUM_TYPE InfoLevel, [In] ENUM_SERVICE_TYPE dwServiceType, [In] ENUM_SERVICE_STATE dwServiceState, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] byte* lpServices, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded, [Out] uint* lpServicesReturned, [In] [Out] [Optional] uint* lpResumeHandle, [Const] [In] [Optional] PWSTR pszGroupName);
BOOL GetServiceKeyNameA([In] SC_HANDLE hSCManager, [Const] [In] PSTR lpDisplayName, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PSTR lpServiceName, [In] [Out] uint* lpcchBuffer);
BOOL GetServiceKeyNameW([In] SC_HANDLE hSCManager, [Const] [In] PWSTR lpDisplayName, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR lpServiceName, [In] [Out] uint* lpcchBuffer);
BOOL GetServiceDisplayNameA([In] SC_HANDLE hSCManager, [Const] [In] PSTR lpServiceName, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PSTR lpDisplayName, [In] [Out] uint* lpcchBuffer);
BOOL GetServiceDisplayNameW([In] SC_HANDLE hSCManager, [Const] [In] PWSTR lpServiceName, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR lpDisplayName, [In] [Out] uint* lpcchBuffer);
void* LockServiceDatabase([In] SC_HANDLE hSCManager);
BOOL NotifyBootConfigStatus([In] BOOL BootAcceptable);
SC_HANDLE OpenSCManagerA([Const] [In] [Optional] PSTR lpMachineName, [Const] [In] [Optional] PSTR lpDatabaseName, [In] uint dwDesiredAccess);
SC_HANDLE OpenSCManagerW([Const] [In] [Optional] PWSTR lpMachineName, [Const] [In] [Optional] PWSTR lpDatabaseName, [In] uint dwDesiredAccess);
SC_HANDLE OpenServiceA([In] SC_HANDLE hSCManager, [Const] [In] PSTR lpServiceName, [In] uint dwDesiredAccess);
SC_HANDLE OpenServiceW([In] SC_HANDLE hSCManager, [Const] [In] PWSTR lpServiceName, [In] uint dwDesiredAccess);
BOOL QueryServiceConfigA([In] SC_HANDLE hService, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] QUERY_SERVICE_CONFIGA* lpServiceConfig, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded);
BOOL QueryServiceConfigW([In] SC_HANDLE hService, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] QUERY_SERVICE_CONFIGW* lpServiceConfig, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded);
BOOL QueryServiceConfig2A([In] SC_HANDLE hService, [In] SERVICE_CONFIG dwInfoLevel, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] byte* lpBuffer, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded);
BOOL QueryServiceConfig2W([In] SC_HANDLE hService, [In] SERVICE_CONFIG dwInfoLevel, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] byte* lpBuffer, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded);
BOOL QueryServiceLockStatusA([In] SC_HANDLE hSCManager, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] QUERY_SERVICE_LOCK_STATUSA* lpLockStatus, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded);
BOOL QueryServiceLockStatusW([In] SC_HANDLE hSCManager, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] QUERY_SERVICE_LOCK_STATUSW* lpLockStatus, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded);
BOOL QueryServiceObjectSecurity([In] SC_HANDLE hService, [In] uint dwSecurityInformation, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PSECURITY_DESCRIPTOR lpSecurityDescriptor, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded);
BOOL QueryServiceStatus([In] SC_HANDLE hService, [Out] SERVICE_STATUS* lpServiceStatus);
BOOL QueryServiceStatusEx([In] SC_HANDLE hService, [In] SC_STATUS_TYPE InfoLevel, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] byte* lpBuffer, [In] uint cbBufSize, [Out] uint* pcbBytesNeeded);
SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA([Const] [In] PSTR lpServiceName, [In] LPHANDLER_FUNCTION lpHandlerProc);
SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerW([Const] [In] PWSTR lpServiceName, [In] LPHANDLER_FUNCTION lpHandlerProc);
SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExA([Const] [In] PSTR lpServiceName, [In] LPHANDLER_FUNCTION_EX lpHandlerProc, [In] [Optional] void* lpContext);
SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExW([Const] [In] PWSTR lpServiceName, [In] LPHANDLER_FUNCTION_EX lpHandlerProc, [In] [Optional] void* lpContext);
BOOL SetServiceObjectSecurity([In] SC_HANDLE hService, [In] OBJECT_SECURITY_INFORMATION dwSecurityInformation, [In] PSECURITY_DESCRIPTOR lpSecurityDescriptor);
BOOL SetServiceStatus([In] SERVICE_STATUS_HANDLE hServiceStatus, [In] SERVICE_STATUS* lpServiceStatus);
BOOL StartServiceCtrlDispatcherA([Const] [In] SERVICE_TABLE_ENTRYA* lpServiceStartTable);
BOOL StartServiceCtrlDispatcherW([Const] [In] SERVICE_TABLE_ENTRYW* lpServiceStartTable);
BOOL StartServiceA([In] SC_HANDLE hService, [In] uint dwNumServiceArgs, [NativeArrayInfo(CountParamIndex = 1)] [In] [Optional] PSTR* lpServiceArgVectors);
BOOL StartServiceW([In] SC_HANDLE hService, [In] uint dwNumServiceArgs, [NativeArrayInfo(CountParamIndex = 1)] [In] [Optional] PWSTR* lpServiceArgVectors);
BOOL UnlockServiceDatabase([In] void* ScLock);
uint NotifyServiceStatusChangeA([In] SC_HANDLE hService, [In] SERVICE_NOTIFY dwNotifyMask, [In] SERVICE_NOTIFY_2A* pNotifyBuffer);
uint NotifyServiceStatusChangeW([In] SC_HANDLE hService, [In] SERVICE_NOTIFY dwNotifyMask, [In] SERVICE_NOTIFY_2W* pNotifyBuffer);
BOOL ControlServiceExA([In] SC_HANDLE hService, [In] uint dwControl, [In] uint dwInfoLevel, [In] [Out] void* pControlParams);
BOOL ControlServiceExW([In] SC_HANDLE hService, [In] uint dwControl, [In] uint dwInfoLevel, [In] [Out] void* pControlParams);
BOOL QueryServiceDynamicInformation([In] SERVICE_STATUS_HANDLE hServiceStatus, [In] uint dwInfoLevel, [Out] void** ppDynamicInfo);
uint WaitServiceState([In] SC_HANDLE hService, [In] uint dwNotify, [In] [Optional] uint dwTimeout, [In] [Optional] HANDLE hCancelEvent);
void* OpenThreadWaitChainSession([In] OPEN_THREAD_WAIT_CHAIN_SESSION_FLAGS Flags, [In] [Optional] PWAITCHAINCALLBACK callback);
void CloseThreadWaitChainSession([In] void* WctHandle);
BOOL GetThreadWaitChain([In] void* WctHandle, [In] [Optional] nuint Context, [In] WAIT_CHAIN_THREAD_OPTIONS Flags, [In] uint ThreadId, [In] [Out] uint* NodeCount, [NativeArrayInfo(CountParamIndex = 4)] [Out] WAITCHAIN_NODE_INFO* NodeInfoArray, [Out] int* IsCycle);
void RegisterWaitChainCOMCallback([In] PCOGETCALLSTATE CallStateCallback, [In] PCOGETACTIVATIONSTATE ActivationStateCallback);
WIN32_ERROR StartTraceW([Out] CONTROLTRACE_HANDLE* TraceHandle, [Const] [In] PWSTR InstanceName, [In] [Out] EVENT_TRACE_PROPERTIES* Properties);
WIN32_ERROR StartTraceA([Out] CONTROLTRACE_HANDLE* TraceHandle, [Const] [In] PSTR InstanceName, [In] [Out] EVENT_TRACE_PROPERTIES* Properties);
WIN32_ERROR StopTraceW([In] CONTROLTRACE_HANDLE TraceHandle, [Const] [In] [Optional] PWSTR InstanceName, [In] [Out] EVENT_TRACE_PROPERTIES* Properties);
WIN32_ERROR StopTraceA([In] CONTROLTRACE_HANDLE TraceHandle, [Const] [In] [Optional] PSTR InstanceName, [In] [Out] EVENT_TRACE_PROPERTIES* Properties);
WIN32_ERROR QueryTraceW([In] CONTROLTRACE_HANDLE TraceHandle, [Const] [In] [Optional] PWSTR InstanceName, [In] [Out] EVENT_TRACE_PROPERTIES* Properties);
WIN32_ERROR QueryTraceA([In] CONTROLTRACE_HANDLE TraceHandle, [Const] [In] [Optional] PSTR InstanceName, [In] [Out] EVENT_TRACE_PROPERTIES* Properties);
WIN32_ERROR UpdateTraceW([In] CONTROLTRACE_HANDLE TraceHandle, [Const] [In] [Optional] PWSTR InstanceName, [In] [Out] EVENT_TRACE_PROPERTIES* Properties);
WIN32_ERROR UpdateTraceA([In] CONTROLTRACE_HANDLE TraceHandle, [Const] [In] [Optional] PSTR InstanceName, [In] [Out] EVENT_TRACE_PROPERTIES* Properties);
WIN32_ERROR FlushTraceW([In] CONTROLTRACE_HANDLE TraceHandle, [Const] [In] [Optional] PWSTR InstanceName, [In] [Out] EVENT_TRACE_PROPERTIES* Properties);
WIN32_ERROR FlushTraceA([In] CONTROLTRACE_HANDLE TraceHandle, [Const] [In] [Optional] PSTR InstanceName, [In] [Out] EVENT_TRACE_PROPERTIES* Properties);
WIN32_ERROR ControlTraceW([In] CONTROLTRACE_HANDLE TraceHandle, [Const] [In] [Optional] PWSTR InstanceName, [In] [Out] EVENT_TRACE_PROPERTIES* Properties, [In] EVENT_TRACE_CONTROL ControlCode);
WIN32_ERROR ControlTraceA([In] CONTROLTRACE_HANDLE TraceHandle, [Const] [In] [Optional] PSTR InstanceName, [In] [Out] EVENT_TRACE_PROPERTIES* Properties, [In] EVENT_TRACE_CONTROL ControlCode);
WIN32_ERROR QueryAllTracesW([NativeArrayInfo(CountParamIndex = 1)] [Out] EVENT_TRACE_PROPERTIES** PropertyArray, [In] uint PropertyArrayCount, [Out] uint* LoggerCount);
WIN32_ERROR QueryAllTracesA([NativeArrayInfo(CountParamIndex = 1)] [Out] EVENT_TRACE_PROPERTIES** PropertyArray, [In] uint PropertyArrayCount, [Out] uint* LoggerCount);
WIN32_ERROR EnableTrace([In] uint Enable, [In] uint EnableFlag, [In] uint EnableLevel, [Const] [In] Guid* ControlGuid, [In] CONTROLTRACE_HANDLE TraceHandle);
WIN32_ERROR EnableTraceEx([Const] [In] Guid* ProviderId, [Const] [In] [Optional] Guid* SourceId, [In] CONTROLTRACE_HANDLE TraceHandle, [In] uint IsEnabled, [In] byte Level, [In] ulong MatchAnyKeyword, [In] ulong MatchAllKeyword, [In] uint EnableProperty, [In] [Optional] EVENT_FILTER_DESCRIPTOR* EnableFilterDesc);
WIN32_ERROR EnableTraceEx2([In] CONTROLTRACE_HANDLE TraceHandle, [Const] [In] Guid* ProviderId, [In] uint ControlCode, [In] byte Level, [In] ulong MatchAnyKeyword, [In] ulong MatchAllKeyword, [In] uint Timeout, [In] [Optional] ENABLE_TRACE_PARAMETERS* EnableParameters);
WIN32_ERROR EnumerateTraceGuidsEx([In] TRACE_QUERY_INFO_CLASS TraceQueryInfoClass, [MemorySize(BytesParamIndex = 2)] [In] [Optional] void* InBuffer, [In] uint InBufferSize, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] void* OutBuffer, [In] uint OutBufferSize, [Out] uint* ReturnLength);
WIN32_ERROR TraceSetInformation([In] CONTROLTRACE_HANDLE SessionHandle, [In] TRACE_QUERY_INFO_CLASS InformationClass, [MemorySize(BytesParamIndex = 3)] [In] void* TraceInformation, [In] uint InformationLength);
WIN32_ERROR TraceQueryInformation([In] CONTROLTRACE_HANDLE SessionHandle, [In] TRACE_QUERY_INFO_CLASS InformationClass, [MemorySize(BytesParamIndex = 3)] [Out] void* TraceInformation, [In] uint InformationLength, [Out] [Optional] uint* ReturnLength);
WIN32_ERROR CreateTraceInstanceId([In] HANDLE RegHandle, [In] [Out] EVENT_INSTANCE_INFO* InstInfo);
WIN32_ERROR TraceEvent([In] ulong TraceHandle, [In] EVENT_TRACE_HEADER* EventTrace);
uint TraceEventInstance([In] ulong TraceHandle, [In] EVENT_INSTANCE_HEADER* EventTrace, [In] EVENT_INSTANCE_INFO* InstInfo, [In] [Optional] EVENT_INSTANCE_INFO* ParentInstInfo);
uint RegisterTraceGuidsW([In] WMIDPREQUEST RequestAddress, [In] [Optional] void* RequestContext, [Const] [In] Guid* ControlGuid, [In] uint GuidCount, [NativeArrayInfo(CountParamIndex = 3)] [In] [Optional] TRACE_GUID_REGISTRATION* TraceGuidReg, [Const] [In] [Optional] PWSTR MofImagePath, [Const] [In] [Optional] PWSTR MofResourceName, [Out] ulong* RegistrationHandle);
uint RegisterTraceGuidsA([In] WMIDPREQUEST RequestAddress, [In] [Optional] void* RequestContext, [Const] [In] Guid* ControlGuid, [In] uint GuidCount, [NativeArrayInfo(CountParamIndex = 3)] [In] [Optional] TRACE_GUID_REGISTRATION* TraceGuidReg, [Const] [In] [Optional] PSTR MofImagePath, [Const] [In] [Optional] PSTR MofResourceName, [Out] ulong* RegistrationHandle);
WIN32_ERROR EnumerateTraceGuids([NativeArrayInfo(CountParamIndex = 1)] [In] [Out] TRACE_GUID_PROPERTIES** GuidPropertiesArray, [In] uint PropertyArrayCount, [Out] uint* GuidCount);
uint UnregisterTraceGuids([In] ulong RegistrationHandle);
ulong GetTraceLoggerHandle([In] void* Buffer);
byte GetTraceEnableLevel([In] ulong TraceHandle);
uint GetTraceEnableFlags([In] ulong TraceHandle);
PROCESSTRACE_HANDLE OpenTraceW([In] [Out] EVENT_TRACE_LOGFILEW* Logfile);
WIN32_ERROR ProcessTrace([NativeArrayInfo(CountParamIndex = 1)] [In] PROCESSTRACE_HANDLE* HandleArray, [In] uint HandleCount, [In] [Optional] FILETIME* StartTime, [In] [Optional] FILETIME* EndTime);
WIN32_ERROR CloseTrace([In] PROCESSTRACE_HANDLE TraceHandle);
WIN32_ERROR QueryTraceProcessingHandle([In] PROCESSTRACE_HANDLE ProcessingHandle, [In] ETW_PROCESS_HANDLE_INFO_TYPE InformationClass, [In] [Optional] void* InBuffer, [In] uint InBufferSize, [Out] [Optional] void* OutBuffer, [In] uint OutBufferSize, [In] [Out] uint* ReturnLength);
PROCESSTRACE_HANDLE OpenTraceA([In] [Out] EVENT_TRACE_LOGFILEA* Logfile);
WIN32_ERROR SetTraceCallback([Const] [In] Guid* pGuid, [In] PEVENT_CALLBACK EventCallback);
WIN32_ERROR RemoveTraceCallback([Const] [In] Guid* pGuid);
WIN32_ERROR TraceMessage([In] ulong LoggerHandle, [In] TRACE_MESSAGE_FLAGS MessageFlags, [Const] [In] Guid* MessageGuid, [In] ushort MessageNumber, ...);
WIN32_ERROR TraceMessageVa([In] ulong LoggerHandle, [In] TRACE_MESSAGE_FLAGS MessageFlags, [Const] [In] Guid* MessageGuid, [In] ushort MessageNumber, [In] sbyte* MessageArgList);
uint EventRegister([Const] [In] Guid* ProviderId, [In] [Optional] PENABLECALLBACK EnableCallback, [In] [Optional] void* CallbackContext, [Out] ulong* RegHandle);
uint EventUnregister([In] ulong RegHandle);
uint EventSetInformation([In] ulong RegHandle, [In] EVENT_INFO_CLASS InformationClass, [MemorySize(BytesParamIndex = 3)] [In] void* EventInformation, [In] uint InformationLength);
BOOLEAN EventEnabled([In] ulong RegHandle, [Const] [In] EVENT_DESCRIPTOR* EventDescriptor);
BOOLEAN EventProviderEnabled([In] ulong RegHandle, [In] byte Level, [In] ulong Keyword);
uint EventWrite([In] ulong RegHandle, [Const] [In] EVENT_DESCRIPTOR* EventDescriptor, [In] uint UserDataCount, [NativeArrayInfo(CountParamIndex = 2)] [In] [Optional] EVENT_DATA_DESCRIPTOR* UserData);
uint EventWriteTransfer([In] ulong RegHandle, [Const] [In] EVENT_DESCRIPTOR* EventDescriptor, [Const] [In] [Optional] Guid* ActivityId, [Const] [In] [Optional] Guid* RelatedActivityId, [In] uint UserDataCount, [NativeArrayInfo(CountParamIndex = 4)] [In] [Optional] EVENT_DATA_DESCRIPTOR* UserData);
uint EventWriteEx([In] ulong RegHandle, [Const] [In] EVENT_DESCRIPTOR* EventDescriptor, [In] ulong Filter, [In] uint Flags, [Const] [In] [Optional] Guid* ActivityId, [Const] [In] [Optional] Guid* RelatedActivityId, [In] uint UserDataCount, [NativeArrayInfo(CountParamIndex = 6)] [In] [Optional] EVENT_DATA_DESCRIPTOR* UserData);
uint EventWriteString([In] ulong RegHandle, [In] byte Level, [In] ulong Keyword, [Const] [In] PWSTR String);
uint EventActivityIdControl([In] uint ControlCode, [In] [Out] Guid* ActivityId);
uint EventAccessControl([In] Guid* Guid, [In] uint Operation, [In] PSID Sid, [In] uint Rights, [In] BOOLEAN AllowOrDeny);
uint EventAccessQuery([In] Guid* Guid, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] PSECURITY_DESCRIPTOR Buffer, [In] [Out] uint* BufferSize);
uint EventAccessRemove([In] Guid* Guid);
int CveEventWrite([Const] [In] PWSTR CveId, [Const] [In] [Optional] PWSTR AdditionalDetails);
uint MSChapSrvChangePassword([In] PWSTR ServerName, [In] PWSTR UserName, [In] BOOLEAN LmOldPresent, [In] LM_OWF_PASSWORD* LmOldOwfPassword, [In] LM_OWF_PASSWORD* LmNewOwfPassword, [In] LM_OWF_PASSWORD* NtOldOwfPassword, [In] LM_OWF_PASSWORD* NtNewOwfPassword);
uint MSChapSrvChangePassword2([In] PWSTR ServerName, [In] PWSTR UserName, [In] SAMPR_ENCRYPTED_USER_PASSWORD* NewPasswordEncryptedWithOldNt, [In] ENCRYPTED_LM_OWF_PASSWORD* OldNtOwfPasswordEncryptedWithNewNt, [In] BOOLEAN LmPresent, [In] SAMPR_ENCRYPTED_USER_PASSWORD* NewPasswordEncryptedWithOldLm, [In] ENCRYPTED_LM_OWF_PASSWORD* OldLmOwfPasswordEncryptedWithNewLmOrNt);
uint PerfStartProvider([In] Guid* ProviderGuid, [In] [Optional] PERFLIBREQUEST ControlCallback, [Out] PerfProviderHandle* phProvider);
uint PerfStartProviderEx([In] Guid* ProviderGuid, [In] [Optional] PERF_PROVIDER_CONTEXT* ProviderContext, [Out] PerfProviderHandle* Provider);
uint PerfStopProvider([In] PerfProviderHandle ProviderHandle);
uint PerfSetCounterSetInfo([In] HANDLE ProviderHandle, [MemorySize(BytesParamIndex = 2)] [In] [Out] PERF_COUNTERSET_INFO* Template, [In] uint TemplateSize);
PERF_COUNTERSET_INSTANCE* PerfCreateInstance([In] PerfProviderHandle ProviderHandle, [Const] [In] Guid* CounterSetGuid, [Const] [In] PWSTR Name, [In] uint Id);
uint PerfDeleteInstance([In] PerfProviderHandle Provider, [In] PERF_COUNTERSET_INSTANCE* InstanceBlock);
PERF_COUNTERSET_INSTANCE* PerfQueryInstance([In] HANDLE ProviderHandle, [Const] [In] Guid* CounterSetGuid, [Const] [In] PWSTR Name, [In] uint Id);
uint PerfSetCounterRefValue([In] HANDLE Provider, [In] [Out] PERF_COUNTERSET_INSTANCE* Instance, [In] uint CounterId, [In] void* Address);
uint PerfSetULongCounterValue([In] HANDLE Provider, [In] [Out] PERF_COUNTERSET_INSTANCE* Instance, [In] uint CounterId, [In] uint Value);
uint PerfSetULongLongCounterValue([In] HANDLE Provider, [In] [Out] PERF_COUNTERSET_INSTANCE* Instance, [In] uint CounterId, [In] ulong Value);
uint PerfIncrementULongCounterValue([In] HANDLE Provider, [In] [Out] PERF_COUNTERSET_INSTANCE* Instance, [In] uint CounterId, [In] uint Value);
uint PerfIncrementULongLongCounterValue([In] HANDLE Provider, [In] [Out] PERF_COUNTERSET_INSTANCE* Instance, [In] uint CounterId, [In] ulong Value);
uint PerfDecrementULongCounterValue([In] HANDLE Provider, [In] [Out] PERF_COUNTERSET_INSTANCE* Instance, [In] uint CounterId, [In] uint Value);
uint PerfDecrementULongLongCounterValue([In] HANDLE Provider, [In] [Out] PERF_COUNTERSET_INSTANCE* Instance, [In] uint CounterId, [In] ulong Value);
uint PerfEnumerateCounterSet([Const] [In] [Optional] PWSTR szMachine, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] Guid* pCounterSetIds, [In] uint cCounterSetIds, [Out] uint* pcCounterSetIdsActual);
uint PerfEnumerateCounterSetInstances([Const] [In] [Optional] PWSTR szMachine, [Const] [In] Guid* pCounterSetId, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PERF_INSTANCE_HEADER* pInstances, [In] uint cbInstances, [Out] uint* pcbInstancesActual);
uint PerfQueryCounterSetRegistrationInfo([Const] [In] [Optional] PWSTR szMachine, [Const] [In] Guid* pCounterSetId, [In] PerfRegInfoType requestCode, [In] uint requestLangId, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] byte* pbRegInfo, [In] uint cbRegInfo, [Out] uint* pcbRegInfoActual);
uint PerfOpenQueryHandle([Const] [In] [Optional] PWSTR szMachine, [Out] PerfQueryHandle* phQuery);
uint PerfCloseQueryHandle([In] HANDLE hQuery);
uint PerfQueryCounterInfo([In] PerfQueryHandle hQuery, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] PERF_COUNTER_IDENTIFIER* pCounters, [In] uint cbCounters, [Out] uint* pcbCountersActual);
uint PerfQueryCounterData([In] PerfQueryHandle hQuery, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] PERF_DATA_HEADER* pCounterBlock, [In] uint cbCounterBlock, [Out] uint* pcbCounterBlockActual);
uint PerfAddCounters([In] PerfQueryHandle hQuery, [MemorySize(BytesParamIndex = 2)] [In] [Out] PERF_COUNTER_IDENTIFIER* pCounters, [In] uint cbCounters);
uint PerfDeleteCounters([In] PerfQueryHandle hQuery, [MemorySize(BytesParamIndex = 2)] [In] [Out] PERF_COUNTER_IDENTIFIER* pCounters, [In] uint cbCounters);
BOOL ImpersonateNamedPipeClient([In] HANDLE hNamedPipe);
WIN32_ERROR RegCloseKey([In] HKEY hKey);
WIN32_ERROR RegOverridePredefKey([In] HKEY hKey, [In] [Optional] HKEY hNewHKey);
WIN32_ERROR RegOpenUserClassesRoot([In] HANDLE hToken, [Reserved] [In] uint dwOptions, [In] uint samDesired, [Out] HKEY* phkResult);
WIN32_ERROR RegOpenCurrentUser([In] uint samDesired, [Out] HKEY* phkResult);
WIN32_ERROR RegDisablePredefinedCache();
WIN32_ERROR RegDisablePredefinedCacheEx();
WIN32_ERROR RegConnectRegistryA([Const] [In] [Optional] PSTR lpMachineName, [In] HKEY hKey, [Out] HKEY* phkResult);
WIN32_ERROR RegConnectRegistryW([Const] [In] [Optional] PWSTR lpMachineName, [In] HKEY hKey, [Out] HKEY* phkResult);
int RegConnectRegistryExA([Const] [In] [Optional] PSTR lpMachineName, [In] HKEY hKey, [In] uint Flags, [Out] HKEY* phkResult);
int RegConnectRegistryExW([Const] [In] [Optional] PWSTR lpMachineName, [In] HKEY hKey, [In] uint Flags, [Out] HKEY* phkResult);
WIN32_ERROR RegCreateKeyA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpSubKey, [Out] HKEY* phkResult);
WIN32_ERROR RegCreateKeyW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKey, [Out] HKEY* phkResult);
WIN32_ERROR RegCreateKeyExA([In] HKEY hKey, [Const] [In] PSTR lpSubKey, [Reserved] [In] uint Reserved, [In] [Optional] PSTR lpClass, [In] REG_OPEN_CREATE_OPTIONS dwOptions, [In] REG_SAM_FLAGS samDesired, [Const] [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [Out] HKEY* phkResult, [Out] [Optional] REG_CREATE_KEY_DISPOSITION* lpdwDisposition);
WIN32_ERROR RegCreateKeyExW([In] HKEY hKey, [Const] [In] PWSTR lpSubKey, [Reserved] [In] uint Reserved, [In] [Optional] PWSTR lpClass, [In] REG_OPEN_CREATE_OPTIONS dwOptions, [In] REG_SAM_FLAGS samDesired, [Const] [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [Out] HKEY* phkResult, [Out] [Optional] REG_CREATE_KEY_DISPOSITION* lpdwDisposition);
WIN32_ERROR RegCreateKeyTransactedA([In] HKEY hKey, [Const] [In] PSTR lpSubKey, [Reserved] [In] uint Reserved, [In] [Optional] PSTR lpClass, [In] REG_OPEN_CREATE_OPTIONS dwOptions, [In] REG_SAM_FLAGS samDesired, [Const] [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [Out] HKEY* phkResult, [Out] [Optional] REG_CREATE_KEY_DISPOSITION* lpdwDisposition, [In] HANDLE hTransaction, [Reserved] [In] [Out] void* pExtendedParemeter);
WIN32_ERROR RegCreateKeyTransactedW([In] HKEY hKey, [Const] [In] PWSTR lpSubKey, [Reserved] [In] uint Reserved, [In] [Optional] PWSTR lpClass, [In] REG_OPEN_CREATE_OPTIONS dwOptions, [In] REG_SAM_FLAGS samDesired, [Const] [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [Out] HKEY* phkResult, [Out] [Optional] REG_CREATE_KEY_DISPOSITION* lpdwDisposition, [In] HANDLE hTransaction, [Reserved] [In] [Out] void* pExtendedParemeter);
WIN32_ERROR RegDeleteKeyA([In] HKEY hKey, [Const] [In] PSTR lpSubKey);
WIN32_ERROR RegDeleteKeyW([In] HKEY hKey, [Const] [In] PWSTR lpSubKey);
WIN32_ERROR RegDeleteKeyExA([In] HKEY hKey, [Const] [In] PSTR lpSubKey, [In] uint samDesired, [Reserved] [In] uint Reserved);
WIN32_ERROR RegDeleteKeyExW([In] HKEY hKey, [Const] [In] PWSTR lpSubKey, [In] uint samDesired, [Reserved] [In] uint Reserved);
WIN32_ERROR RegDeleteKeyTransactedA([In] HKEY hKey, [Const] [In] PSTR lpSubKey, [In] uint samDesired, [Reserved] [In] uint Reserved, [In] HANDLE hTransaction, [Reserved] [In] [Out] void* pExtendedParameter);
WIN32_ERROR RegDeleteKeyTransactedW([In] HKEY hKey, [Const] [In] PWSTR lpSubKey, [In] uint samDesired, [Reserved] [In] uint Reserved, [In] HANDLE hTransaction, [Reserved] [In] [Out] void* pExtendedParameter);
WIN32_ERROR RegDisableReflectionKey([In] HKEY hBase);
WIN32_ERROR RegEnableReflectionKey([In] HKEY hBase);
WIN32_ERROR RegQueryReflectionKey([In] HKEY hBase, [Out] BOOL* bIsReflectionDisabled);
WIN32_ERROR RegDeleteValueA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpValueName);
WIN32_ERROR RegDeleteValueW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpValueName);
WIN32_ERROR RegEnumKeyA([In] HKEY hKey, [In] uint dwIndex, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PSTR lpName, [In] uint cchName);
WIN32_ERROR RegEnumKeyW([In] HKEY hKey, [In] uint dwIndex, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR lpName, [In] uint cchName);
WIN32_ERROR RegEnumKeyExA([In] HKEY hKey, [In] uint dwIndex, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PSTR lpName, [In] [Out] uint* lpcchName, [Reserved] [In] [Out] uint* lpReserved, [NativeArrayInfo(CountParamIndex = 6)] [Out] [Optional] PSTR lpClass, [In] [Out] [Optional] uint* lpcchClass, [Out] [Optional] FILETIME* lpftLastWriteTime);
WIN32_ERROR RegEnumKeyExW([In] HKEY hKey, [In] uint dwIndex, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR lpName, [In] [Out] uint* lpcchName, [Reserved] [In] [Out] uint* lpReserved, [NativeArrayInfo(CountParamIndex = 6)] [Out] [Optional] PWSTR lpClass, [In] [Out] [Optional] uint* lpcchClass, [Out] [Optional] FILETIME* lpftLastWriteTime);
WIN32_ERROR RegEnumValueA([In] HKEY hKey, [In] uint dwIndex, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PSTR lpValueName, [In] [Out] uint* lpcchValueName, [Reserved] [In] [Out] uint* lpReserved, [Out] [Optional] uint* lpType, [MemorySize(BytesParamIndex = 7)] [Out] [Optional] byte* lpData, [In] [Out] [Optional] uint* lpcbData);
WIN32_ERROR RegEnumValueW([In] HKEY hKey, [In] uint dwIndex, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR lpValueName, [In] [Out] uint* lpcchValueName, [Reserved] [In] [Out] uint* lpReserved, [Out] [Optional] uint* lpType, [MemorySize(BytesParamIndex = 7)] [Out] [Optional] byte* lpData, [In] [Out] [Optional] uint* lpcbData);
WIN32_ERROR RegFlushKey([In] HKEY hKey);
WIN32_ERROR RegGetKeySecurity([In] HKEY hKey, [In] uint SecurityInformation, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PSECURITY_DESCRIPTOR pSecurityDescriptor, [In] [Out] uint* lpcbSecurityDescriptor);
WIN32_ERROR RegLoadKeyA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpSubKey, [Const] [In] PSTR lpFile);
WIN32_ERROR RegLoadKeyW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKey, [Const] [In] PWSTR lpFile);
WIN32_ERROR RegNotifyChangeKeyValue([In] HKEY hKey, [In] BOOL bWatchSubtree, [In] REG_NOTIFY_FILTER dwNotifyFilter, [In] [Optional] HANDLE hEvent, [In] BOOL fAsynchronous);
WIN32_ERROR RegOpenKeyA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpSubKey, [Out] HKEY* phkResult);
WIN32_ERROR RegOpenKeyW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKey, [Out] HKEY* phkResult);
WIN32_ERROR RegOpenKeyExA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpSubKey, [In] [Optional] uint ulOptions, [In] REG_SAM_FLAGS samDesired, [Out] HKEY* phkResult);
WIN32_ERROR RegOpenKeyExW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKey, [In] [Optional] uint ulOptions, [In] REG_SAM_FLAGS samDesired, [Out] HKEY* phkResult);
WIN32_ERROR RegOpenKeyTransactedA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpSubKey, [In] [Optional] uint ulOptions, [In] REG_SAM_FLAGS samDesired, [Out] HKEY* phkResult, [In] HANDLE hTransaction, [Reserved] [In] [Out] void* pExtendedParemeter);
WIN32_ERROR RegOpenKeyTransactedW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKey, [In] [Optional] uint ulOptions, [In] REG_SAM_FLAGS samDesired, [Out] HKEY* phkResult, [In] HANDLE hTransaction, [Reserved] [In] [Out] void* pExtendedParemeter);
WIN32_ERROR RegQueryInfoKeyA([In] HKEY hKey, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpClass, [In] [Out] [Optional] uint* lpcchClass, [Reserved] [In] [Out] uint* lpReserved, [Out] [Optional] uint* lpcSubKeys, [Out] [Optional] uint* lpcbMaxSubKeyLen, [Out] [Optional] uint* lpcbMaxClassLen, [Out] [Optional] uint* lpcValues, [Out] [Optional] uint* lpcbMaxValueNameLen, [Out] [Optional] uint* lpcbMaxValueLen, [Out] [Optional] uint* lpcbSecurityDescriptor, [Out] [Optional] FILETIME* lpftLastWriteTime);
WIN32_ERROR RegQueryInfoKeyW([In] HKEY hKey, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpClass, [In] [Out] [Optional] uint* lpcchClass, [Reserved] [In] [Out] uint* lpReserved, [Out] [Optional] uint* lpcSubKeys, [Out] [Optional] uint* lpcbMaxSubKeyLen, [Out] [Optional] uint* lpcbMaxClassLen, [Out] [Optional] uint* lpcValues, [Out] [Optional] uint* lpcbMaxValueNameLen, [Out] [Optional] uint* lpcbMaxValueLen, [Out] [Optional] uint* lpcbSecurityDescriptor, [Out] [Optional] FILETIME* lpftLastWriteTime);
WIN32_ERROR RegQueryValueA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpSubKey, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PSTR lpData, [In] [Out] [Optional] int* lpcbData);
WIN32_ERROR RegQueryValueW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKey, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PWSTR lpData, [In] [Out] [Optional] int* lpcbData);
WIN32_ERROR RegQueryMultipleValuesA([In] HKEY hKey, [NativeArrayInfo(CountParamIndex = 2)] [Out] VALENTA* val_list, [In] uint num_vals, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] PSTR lpValueBuf, [In] [Out] [Optional] uint* ldwTotsize);
WIN32_ERROR RegQueryMultipleValuesW([In] HKEY hKey, [NativeArrayInfo(CountParamIndex = 2)] [Out] VALENTW* val_list, [In] uint num_vals, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] PWSTR lpValueBuf, [In] [Out] [Optional] uint* ldwTotsize);
WIN32_ERROR RegQueryValueExA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpValueName, [Reserved] [In] [Out] uint* lpReserved, [Out] [Optional] REG_VALUE_TYPE* lpType, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] byte* lpData, [In] [Out] [Optional] uint* lpcbData);
WIN32_ERROR RegQueryValueExW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpValueName, [Reserved] [In] [Out] uint* lpReserved, [Out] [Optional] REG_VALUE_TYPE* lpType, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] byte* lpData, [In] [Out] [Optional] uint* lpcbData);
WIN32_ERROR RegReplaceKeyA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpSubKey, [Const] [In] PSTR lpNewFile, [Const] [In] PSTR lpOldFile);
WIN32_ERROR RegReplaceKeyW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKey, [Const] [In] PWSTR lpNewFile, [Const] [In] PWSTR lpOldFile);
WIN32_ERROR RegRestoreKeyA([In] HKEY hKey, [Const] [In] PSTR lpFile, [In] REG_RESTORE_KEY_FLAGS dwFlags);
WIN32_ERROR RegRestoreKeyW([In] HKEY hKey, [Const] [In] PWSTR lpFile, [In] REG_RESTORE_KEY_FLAGS dwFlags);
WIN32_ERROR RegRenameKey([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKeyName, [Const] [In] PWSTR lpNewKeyName);
WIN32_ERROR RegSaveKeyA([In] HKEY hKey, [Const] [In] PSTR lpFile, [Const] [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes);
WIN32_ERROR RegSaveKeyW([In] HKEY hKey, [Const] [In] PWSTR lpFile, [Const] [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes);
WIN32_ERROR RegSetKeySecurity([In] HKEY hKey, [In] uint SecurityInformation, [In] PSECURITY_DESCRIPTOR pSecurityDescriptor);
WIN32_ERROR RegSetValueA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpSubKey, [In] REG_VALUE_TYPE dwType, [Const] [MemorySize(BytesParamIndex = 4)] [In] [Optional] PSTR lpData, [In] uint cbData);
WIN32_ERROR RegSetValueW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKey, [In] REG_VALUE_TYPE dwType, [Const] [MemorySize(BytesParamIndex = 4)] [In] [Optional] PWSTR lpData, [In] uint cbData);
WIN32_ERROR RegSetValueExA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpValueName, [Reserved] [In] uint Reserved, [In] REG_VALUE_TYPE dwType, [Const] [MemorySize(BytesParamIndex = 5)] [In] [Optional] byte* lpData, [In] uint cbData);
WIN32_ERROR RegSetValueExW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpValueName, [Reserved] [In] uint Reserved, [In] REG_VALUE_TYPE dwType, [Const] [MemorySize(BytesParamIndex = 5)] [In] [Optional] byte* lpData, [In] uint cbData);
WIN32_ERROR RegUnLoadKeyA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpSubKey);
WIN32_ERROR RegUnLoadKeyW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKey);
WIN32_ERROR RegDeleteKeyValueA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpSubKey, [Const] [In] [Optional] PSTR lpValueName);
WIN32_ERROR RegDeleteKeyValueW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKey, [Const] [In] [Optional] PWSTR lpValueName);
WIN32_ERROR RegSetKeyValueA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpSubKey, [Const] [In] [Optional] PSTR lpValueName, [In] uint dwType, [Const] [MemorySize(BytesParamIndex = 5)] [In] [Optional] void* lpData, [In] uint cbData);
WIN32_ERROR RegSetKeyValueW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKey, [Const] [In] [Optional] PWSTR lpValueName, [In] uint dwType, [Const] [MemorySize(BytesParamIndex = 5)] [In] [Optional] void* lpData, [In] uint cbData);
WIN32_ERROR RegDeleteTreeA([In] HKEY hKey, [Const] [In] [Optional] PSTR lpSubKey);
WIN32_ERROR RegDeleteTreeW([In] HKEY hKey, [Const] [In] [Optional] PWSTR lpSubKey);
WIN32_ERROR RegCopyTreeA([In] HKEY hKeySrc, [Const] [In] [Optional] PSTR lpSubKey, [In] HKEY hKeyDest);
WIN32_ERROR RegGetValueA([In] HKEY hkey, [Const] [In] [Optional] PSTR lpSubKey, [Const] [In] [Optional] PSTR lpValue, [In] REG_ROUTINE_FLAGS dwFlags, [Out] [Optional] REG_VALUE_TYPE* pdwType, [MemorySize(BytesParamIndex = 6)] [NullNullTerminated] [Out] [Optional] void* pvData, [In] [Out] [Optional] uint* pcbData);
WIN32_ERROR RegGetValueW([In] HKEY hkey, [Const] [In] [Optional] PWSTR lpSubKey, [Const] [In] [Optional] PWSTR lpValue, [In] REG_ROUTINE_FLAGS dwFlags, [Out] [Optional] REG_VALUE_TYPE* pdwType, [MemorySize(BytesParamIndex = 6)] [NullNullTerminated] [Out] [Optional] void* pvData, [In] [Out] [Optional] uint* pcbData);
WIN32_ERROR RegCopyTreeW([In] HKEY hKeySrc, [Const] [In] [Optional] PWSTR lpSubKey, [In] HKEY hKeyDest);
WIN32_ERROR RegLoadMUIStringA([In] HKEY hKey, [Const] [In] [Optional] PSTR pszValue, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PSTR pszOutBuf, [In] uint cbOutBuf, [Out] [Optional] uint* pcbData, [In] uint Flags, [Const] [In] [Optional] PSTR pszDirectory);
WIN32_ERROR RegLoadMUIStringW([In] HKEY hKey, [Const] [In] [Optional] PWSTR pszValue, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] PWSTR pszOutBuf, [In] uint cbOutBuf, [Out] [Optional] uint* pcbData, [In] uint Flags, [Const] [In] [Optional] PWSTR pszDirectory);
WIN32_ERROR RegLoadAppKeyA([Const] [In] PSTR lpFile, [Out] HKEY* phkResult, [In] uint samDesired, [In] uint dwOptions, [Reserved] [In] uint Reserved);
WIN32_ERROR RegLoadAppKeyW([Const] [In] PWSTR lpFile, [Out] HKEY* phkResult, [In] uint samDesired, [In] uint dwOptions, [Reserved] [In] uint Reserved);
WIN32_ERROR RegSaveKeyExA([In] HKEY hKey, [Const] [In] PSTR lpFile, [Const] [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [In] REG_SAVE_FORMAT Flags);
WIN32_ERROR RegSaveKeyExW([In] HKEY hKey, [Const] [In] PWSTR lpFile, [Const] [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [In] REG_SAVE_FORMAT Flags);
uint InstallApplication([In] INSTALLDATA* pInstallInfo);
uint UninstallApplication([In] PWSTR ProductCode, [In] uint dwStatus);
uint CommandLineFromMsiDescriptor([In] PWSTR Descriptor, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR CommandLine, [In] [Out] uint* CommandLineLength);
uint GetManagedApplications([In] Guid* pCategory, [In] uint dwQueryFlags, [In] uint dwInfoLevel, [Out] uint* pdwApps, [Out] MANAGEDAPPLICATION** prgManagedApps);
uint GetLocalManagedApplications([In] BOOL bUserApps, [Out] uint* pdwApps, [Out] LOCALMANAGEDAPPLICATION** prgLocalApps);
void GetLocalManagedApplicationData([In] PWSTR ProductCode, [Out] PWSTR* DisplayName, [Out] PWSTR* SupportUrl);
uint GetManagedApplicationCategories([Reserved] [In] uint dwReserved, [Out] APPCATEGORYINFOLIST* pAppCategory);
BOOL InitiateSystemShutdownA([In] [Optional] PSTR lpMachineName, [In] [Optional] PSTR lpMessage, [In] uint dwTimeout, [In] BOOL bForceAppsClosed, [In] BOOL bRebootAfterShutdown);
BOOL InitiateSystemShutdownW([In] [Optional] PWSTR lpMachineName, [In] [Optional] PWSTR lpMessage, [In] uint dwTimeout, [In] BOOL bForceAppsClosed, [In] BOOL bRebootAfterShutdown);
BOOL AbortSystemShutdownA([In] [Optional] PSTR lpMachineName);
BOOL AbortSystemShutdownW([In] [Optional] PWSTR lpMachineName);
BOOL InitiateSystemShutdownExA([In] [Optional] PSTR lpMachineName, [In] [Optional] PSTR lpMessage, [In] uint dwTimeout, [In] BOOL bForceAppsClosed, [In] BOOL bRebootAfterShutdown, [In] SHUTDOWN_REASON dwReason);
BOOL InitiateSystemShutdownExW([In] [Optional] PWSTR lpMachineName, [In] [Optional] PWSTR lpMessage, [In] uint dwTimeout, [In] BOOL bForceAppsClosed, [In] BOOL bRebootAfterShutdown, [In] SHUTDOWN_REASON dwReason);
uint InitiateShutdownA([In] [Optional] PSTR lpMachineName, [In] [Optional] PSTR lpMessage, [In] uint dwGracePeriod, [In] SHUTDOWN_FLAGS dwShutdownFlags, [In] SHUTDOWN_REASON dwReason);
uint InitiateShutdownW([In] [Optional] PWSTR lpMachineName, [In] [Optional] PWSTR lpMessage, [In] uint dwGracePeriod, [In] SHUTDOWN_FLAGS dwShutdownFlags, [In] SHUTDOWN_REASON dwReason);
uint CheckForHiberboot([In] [Out] BOOLEAN* pHiberboot, [In] BOOLEAN bClearFlag);
BOOL CreateProcessAsUserW([In] [Optional] HANDLE hToken, [Const] [In] [Optional] PWSTR lpApplicationName, [In] [Out] [Optional] PWSTR lpCommandLine, [In] [Optional] SECURITY_ATTRIBUTES* lpProcessAttributes, [In] [Optional] SECURITY_ATTRIBUTES* lpThreadAttributes, [In] BOOL bInheritHandles, [In] uint dwCreationFlags, [In] [Optional] void* lpEnvironment, [Const] [In] [Optional] PWSTR lpCurrentDirectory, [In] STARTUPINFOW* lpStartupInfo, [Out] PROCESS_INFORMATION* lpProcessInformation);
BOOL SetThreadToken([In] [Optional] HANDLE* Thread, [In] [Optional] HANDLE Token);
BOOL OpenProcessToken([In] HANDLE ProcessHandle, [In] TOKEN_ACCESS_MASK DesiredAccess, [Out] HANDLE* TokenHandle);
BOOL OpenThreadToken([In] HANDLE ThreadHandle, [In] TOKEN_ACCESS_MASK DesiredAccess, [In] BOOL OpenAsSelf, [Out] HANDLE* TokenHandle);
BOOL CreateProcessAsUserA([In] [Optional] HANDLE hToken, [Const] [In] [Optional] PSTR lpApplicationName, [In] [Out] [Optional] PSTR lpCommandLine, [In] [Optional] SECURITY_ATTRIBUTES* lpProcessAttributes, [In] [Optional] SECURITY_ATTRIBUTES* lpThreadAttributes, [In] BOOL bInheritHandles, [In] uint dwCreationFlags, [In] [Optional] void* lpEnvironment, [Const] [In] [Optional] PSTR lpCurrentDirectory, [In] STARTUPINFOA* lpStartupInfo, [Out] PROCESS_INFORMATION* lpProcessInformation);
BOOL CreateProcessWithLogonW([Const] [In] PWSTR lpUsername, [Const] [In] [Optional] PWSTR lpDomain, [Const] [In] PWSTR lpPassword, [In] CREATE_PROCESS_LOGON_FLAGS dwLogonFlags, [Const] [In] [Optional] PWSTR lpApplicationName, [In] [Out] [Optional] PWSTR lpCommandLine, [In] uint dwCreationFlags, [In] [Optional] void* lpEnvironment, [Const] [In] [Optional] PWSTR lpCurrentDirectory, [In] STARTUPINFOW* lpStartupInfo, [Out] PROCESS_INFORMATION* lpProcessInformation);
BOOL CreateProcessWithTokenW([In] HANDLE hToken, [In] CREATE_PROCESS_LOGON_FLAGS dwLogonFlags, [Const] [In] [Optional] PWSTR lpApplicationName, [In] [Out] [Optional] PWSTR lpCommandLine, [In] uint dwCreationFlags, [In] [Optional] void* lpEnvironment, [Const] [In] [Optional] PWSTR lpCurrentDirectory, [In] STARTUPINFOW* lpStartupInfo, [Out] PROCESS_INFORMATION* lpProcessInformation);
uint EnumDynamicTimeZoneInformation([Const] [In] uint dwIndex, [Out] DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation);
uint GetDynamicTimeZoneInformationEffectiveYears([Const] [In] DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation, [Out] uint* FirstYear, [Out] uint* LastYear);
BOOL GetUserNameA([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PSTR lpBuffer, [In] [Out] uint* pcbBuffer);
BOOL GetUserNameW([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR lpBuffer, [In] [Out] uint* pcbBuffer);
BOOL IsTokenUntrusted([In] HANDLE TokenHandle);
BOOL GetCurrentHwProfileA([Out] HW_PROFILE_INFOA* lpHwProfileInfo);
BOOL GetCurrentHwProfileW([Out] HW_PROFILE_INFOW* lpHwProfileInfo);
