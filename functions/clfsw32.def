BOOLEAN LsnEqual([Const] [In] CLS_LSN* plsn1, [Const] [In] CLS_LSN* plsn2);
BOOLEAN LsnLess([Const] [In] CLS_LSN* plsn1, [Const] [In] CLS_LSN* plsn2);
BOOLEAN LsnGreater([Const] [In] CLS_LSN* plsn1, [Const] [In] CLS_LSN* plsn2);
BOOLEAN LsnNull([Const] [In] CLS_LSN* plsn);
uint LsnContainer([Const] [In] CLS_LSN* plsn);
CLS_LSN LsnCreate([In] uint cidContainer, [In] uint offBlock, [In] uint cRecord);
uint LsnBlockOffset([Const] [In] CLS_LSN* plsn);
uint LsnRecordSequence([Const] [In] CLS_LSN* plsn);
BOOLEAN LsnInvalid([Const] [In] CLS_LSN* plsn);
CLS_LSN LsnIncrement([In] CLS_LSN* plsn);
HANDLE CreateLogFile([Const] [In] PWSTR pszLogFileName, [In] FILE_ACCESS_FLAGS fDesiredAccess, [In] FILE_SHARE_MODE dwShareMode, [In] [Out] SECURITY_ATTRIBUTES* psaLogFile, [In] FILE_CREATION_DISPOSITION fCreateDisposition, [In] FILE_FLAGS_AND_ATTRIBUTES fFlagsAndAttributes);
BOOL DeleteLogByHandle([In] HANDLE hLog);
BOOL DeleteLogFile([Const] [In] PWSTR pszLogFileName, [In] [Out] void* pvReserved);
BOOL AddLogContainer([In] HANDLE hLog, [In] [Optional] ulong* pcbContainer, [In] PWSTR pwszContainerPath, [In] [Out] [Optional] void* pReserved);
BOOL AddLogContainerSet([In] HANDLE hLog, [In] ushort cContainer, [In] [Optional] ulong* pcbContainer, [NativeArrayInfo(CountParamIndex = 1)] [In] PWSTR* rgwszContainerPath, [In] [Out] [Optional] void* pReserved);
BOOL RemoveLogContainer([In] HANDLE hLog, [In] PWSTR pwszContainerPath, [In] BOOL fForce, [In] [Out] [Optional] void* pReserved);
BOOL RemoveLogContainerSet([In] HANDLE hLog, [In] ushort cContainer, [NativeArrayInfo(CountParamIndex = 1)] [In] PWSTR* rgwszContainerPath, [In] BOOL fForce, [In] [Out] [Optional] void* pReserved);
BOOL SetLogArchiveTail([In] HANDLE hLog, [In] [Out] CLS_LSN* plsnArchiveTail, [In] [Out] void* pReserved);
BOOL SetEndOfLog([In] HANDLE hLog, [In] [Out] CLS_LSN* plsnEnd, [In] [Out] OVERLAPPED* lpOverlapped);
BOOL TruncateLog([In] void* pvMarshal, [In] CLS_LSN* plsnEnd, [In] [Out] [Optional] OVERLAPPED* lpOverlapped);
BOOL CreateLogContainerScanContext([In] HANDLE hLog, [In] uint cFromContainer, [In] uint cContainers, [In] byte eScanMode, [In] [Out] CLS_SCAN_CONTEXT* pcxScan, [In] [Out] OVERLAPPED* pOverlapped);
BOOL ScanLogContainers([In] [Out] CLS_SCAN_CONTEXT* pcxScan, [In] byte eScanMode, [In] [Out] void* pReserved);
BOOL AlignReservedLog([In] [Out] void* pvMarshal, [In] uint cReservedRecords, [In] [Out] long* rgcbReservation, [In] [Out] long* pcbAlignReservation);
BOOL AllocReservedLog([In] [Out] void* pvMarshal, [In] uint cReservedRecords, [In] [Out] long* pcbAdjustment);
BOOL FreeReservedLog([In] [Out] void* pvMarshal, [In] uint cReservedRecords, [In] [Out] long* pcbAdjustment);
BOOL GetLogFileInformation([In] HANDLE hLog, [In] [Out] CLS_INFORMATION* pinfoBuffer, [In] [Out] uint* cbBuffer);
BOOL SetLogArchiveMode([In] HANDLE hLog, [In] CLFS_LOG_ARCHIVE_MODE eMode);
BOOL ReadLogRestartArea([In] [Out] void* pvMarshal, [In] [Out] void** ppvRestartBuffer, [In] [Out] uint* pcbRestartBuffer, [In] [Out] CLS_LSN* plsn, [In] [Out] void** ppvContext, [In] [Out] OVERLAPPED* pOverlapped);
BOOL ReadPreviousLogRestartArea([In] [Out] void* pvReadContext, [In] [Out] void** ppvRestartBuffer, [In] [Out] uint* pcbRestartBuffer, [In] [Out] CLS_LSN* plsnRestart, [In] [Out] OVERLAPPED* pOverlapped);
BOOL WriteLogRestartArea([In] [Out] void* pvMarshal, [In] [Out] void* pvRestartBuffer, [In] uint cbRestartBuffer, [In] [Out] CLS_LSN* plsnBase, [In] CLFS_FLAG fFlags, [In] [Out] uint* pcbWritten, [In] [Out] CLS_LSN* plsnNext, [In] [Out] OVERLAPPED* pOverlapped);
BOOL GetLogReservationInfo([In] void* pvMarshal, [Out] uint* pcbRecordNumber, [Out] long* pcbUserReservation, [Out] long* pcbCommitReservation);
BOOL AdvanceLogBase([In] [Out] void* pvMarshal, [In] [Out] CLS_LSN* plsnBase, [In] uint fFlags, [In] [Out] OVERLAPPED* pOverlapped);
BOOL CloseAndResetLogFile([In] HANDLE hLog);
BOOL CreateLogMarshallingArea([In] HANDLE hLog, [In] CLFS_BLOCK_ALLOCATION pfnAllocBuffer, [In] CLFS_BLOCK_DEALLOCATION pfnFreeBuffer, [In] [Out] void* pvBlockAllocContext, [In] uint cbMarshallingBuffer, [In] uint cMaxWriteBuffers, [In] uint cMaxReadBuffers, [In] [Out] void** ppvMarshal);
BOOL DeleteLogMarshallingArea([In] [Out] void* pvMarshal);
BOOL ReserveAndAppendLog([In] [Out] void* pvMarshal, [In] [Out] CLS_WRITE_ENTRY* rgWriteEntries, [In] uint cWriteEntries, [In] [Out] CLS_LSN* plsnUndoNext, [In] [Out] CLS_LSN* plsnPrevious, [In] uint cReserveRecords, [In] [Out] long* rgcbReservation, [In] CLFS_FLAG fFlags, [In] [Out] CLS_LSN* plsn, [In] [Out] OVERLAPPED* pOverlapped);
BOOL ReserveAndAppendLogAligned([In] [Out] void* pvMarshal, [In] [Out] CLS_WRITE_ENTRY* rgWriteEntries, [In] uint cWriteEntries, [In] uint cbEntryAlignment, [In] [Out] CLS_LSN* plsnUndoNext, [In] [Out] CLS_LSN* plsnPrevious, [In] uint cReserveRecords, [In] [Out] long* rgcbReservation, [In] CLFS_FLAG fFlags, [In] [Out] CLS_LSN* plsn, [In] [Out] OVERLAPPED* pOverlapped);
BOOL FlushLogBuffers([In] void* pvMarshal, [In] [Out] [Optional] OVERLAPPED* pOverlapped);
BOOL FlushLogToLsn([In] [Out] void* pvMarshalContext, [In] [Out] CLS_LSN* plsnFlush, [In] [Out] CLS_LSN* plsnLastFlushed, [In] [Out] OVERLAPPED* pOverlapped);
BOOL ReadLogRecord([In] [Out] void* pvMarshal, [In] [Out] CLS_LSN* plsnFirst, [In] CLFS_CONTEXT_MODE eContextMode, [In] [Out] void** ppvReadBuffer, [In] [Out] uint* pcbReadBuffer, [In] [Out] byte* peRecordType, [In] [Out] CLS_LSN* plsnUndoNext, [In] [Out] CLS_LSN* plsnPrevious, [In] [Out] void** ppvReadContext, [In] [Out] OVERLAPPED* pOverlapped);
BOOL ReadNextLogRecord([In] [Out] void* pvReadContext, [In] [Out] void** ppvBuffer, [In] [Out] uint* pcbBuffer, [In] [Out] byte* peRecordType, [In] [Out] CLS_LSN* plsnUser, [In] [Out] CLS_LSN* plsnUndoNext, [In] [Out] CLS_LSN* plsnPrevious, [In] [Out] CLS_LSN* plsnRecord, [In] [Out] OVERLAPPED* pOverlapped);
BOOL TerminateReadLog([In] [Out] void* pvCursorContext);
BOOL PrepareLogArchive([In] HANDLE hLog, [NativeArrayInfo(CountParamIndex = 2)] [In] [Out] PWSTR pszBaseLogFileName, [In] uint cLen, [Const] [In] [Optional] CLS_LSN* plsnLow, [Const] [In] [Optional] CLS_LSN* plsnHigh, [Out] [Optional] uint* pcActualLength, [Out] ulong* poffBaseLogFileData, [Out] ulong* pcbBaseLogFileLength, [Out] CLS_LSN* plsnBase, [Out] CLS_LSN* plsnLast, [Out] CLS_LSN* plsnCurrentArchiveTail, [Out] void** ppvArchiveContext);
BOOL ReadLogArchiveMetadata([In] [Out] void* pvArchiveContext, [In] uint cbOffset, [In] uint cbBytesToRead, [In] [Out] byte* pbReadBuffer, [In] [Out] uint* pcbBytesRead);
BOOL GetNextLogArchiveExtent([In] [Out] void* pvArchiveContext, [In] [Out] CLS_ARCHIVE_DESCRIPTOR* rgadExtent, [In] uint cDescriptors, [In] [Out] uint* pcDescriptorsReturned);
BOOL TerminateLogArchive([In] [Out] void* pvArchiveContext);
BOOL ValidateLog([Const] [In] PWSTR pszLogFileName, [In] [Out] SECURITY_ATTRIBUTES* psaLogFile, [In] [Out] CLS_INFORMATION* pinfoBuffer, [In] [Out] uint* pcbBuffer);
BOOL GetLogContainerName([In] HANDLE hLog, [In] uint cidLogicalContainer, [Const] [In] PWSTR pwstrContainerName, [In] uint cLenContainerName, [In] [Out] uint* pcActualLenContainerName);
BOOL GetLogIoStatistics([In] HANDLE hLog, [In] [Out] void* pvStatsBuffer, [In] uint cbStatsBuffer, [In] CLFS_IOSTATS_CLASS eStatsClass, [In] [Out] uint* pcbStatsWritten);
BOOL RegisterManageableLogClient([In] HANDLE hLog, [In] [Out] LOG_MANAGEMENT_CALLBACKS* pCallbacks);
BOOL DeregisterManageableLogClient([In] HANDLE hLog);
BOOL ReadLogNotification([In] HANDLE hLog, [In] [Out] CLFS_MGMT_NOTIFICATION* pNotification, [In] [Out] OVERLAPPED* lpOverlapped);
BOOL InstallLogPolicy([In] HANDLE hLog, [In] [Out] CLFS_MGMT_POLICY* pPolicy);
BOOL RemoveLogPolicy([In] HANDLE hLog, [In] CLFS_MGMT_POLICY_TYPE ePolicyType);
BOOL QueryLogPolicy([In] HANDLE hLog, [In] CLFS_MGMT_POLICY_TYPE ePolicyType, [In] [Out] CLFS_MGMT_POLICY* pPolicyBuffer, [In] [Out] uint* pcbPolicyBuffer);
BOOL SetLogFileSizeWithPolicy([In] HANDLE hLog, [In] ulong* pDesiredSize, [Out] ulong* pResultingSize);
BOOL HandleLogFull([In] HANDLE hLog);
BOOL LogTailAdvanceFailure([In] HANDLE hLog, [In] uint dwReason);
BOOL RegisterForLogWriteNotification([In] HANDLE hLog, [In] uint cbThreshold, [In] BOOL fEnable);
