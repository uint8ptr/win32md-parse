BOOL ClearCommBreak([In] HANDLE hFile);
BOOL ClearCommError([In] HANDLE hFile, [Out] [Optional] CLEAR_COMM_ERROR_FLAGS* lpErrors, [Out] [Optional] COMSTAT* lpStat);
BOOL SetupComm([In] HANDLE hFile, [In] uint dwInQueue, [In] uint dwOutQueue);
BOOL EscapeCommFunction([In] HANDLE hFile, [In] ESCAPE_COMM_FUNCTION dwFunc);
BOOL GetCommConfig([In] HANDLE hCommDev, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] COMMCONFIG* lpCC, [In] [Out] uint* lpdwSize);
BOOL GetCommMask([In] HANDLE hFile, [Out] COMM_EVENT_MASK* lpEvtMask);
BOOL GetCommProperties([In] HANDLE hFile, [In] [Out] COMMPROP* lpCommProp);
BOOL GetCommModemStatus([In] HANDLE hFile, [Out] MODEM_STATUS_FLAGS* lpModemStat);
BOOL GetCommState([In] HANDLE hFile, [Out] DCB* lpDCB);
BOOL GetCommTimeouts([In] HANDLE hFile, [Out] COMMTIMEOUTS* lpCommTimeouts);
BOOL PurgeComm([In] HANDLE hFile, [In] PURGE_COMM_FLAGS dwFlags);
BOOL SetCommBreak([In] HANDLE hFile);
BOOL SetCommConfig([In] HANDLE hCommDev, [MemorySize(BytesParamIndex = 2)] [In] COMMCONFIG* lpCC, [In] uint dwSize);
BOOL SetCommMask([In] HANDLE hFile, [In] COMM_EVENT_MASK dwEvtMask);
BOOL SetCommState([In] HANDLE hFile, [In] DCB* lpDCB);
BOOL SetCommTimeouts([In] HANDLE hFile, [In] COMMTIMEOUTS* lpCommTimeouts);
BOOL TransmitCommChar([In] HANDLE hFile, [In] CHAR cChar);
BOOL WaitCommEvent([In] HANDLE hFile, [In] [Out] COMM_EVENT_MASK* lpEvtMask, [In] [Out] [Optional] OVERLAPPED* lpOverlapped);
BOOL BuildCommDCBA([Const] [In] PSTR lpDef, [Out] DCB* lpDCB);
BOOL BuildCommDCBW([Const] [In] PWSTR lpDef, [Out] DCB* lpDCB);
BOOL BuildCommDCBAndTimeoutsA([Const] [In] PSTR lpDef, [Out] DCB* lpDCB, [Out] COMMTIMEOUTS* lpCommTimeouts);
BOOL BuildCommDCBAndTimeoutsW([Const] [In] PWSTR lpDef, [Out] DCB* lpDCB, [Out] COMMTIMEOUTS* lpCommTimeouts);
BOOL CommConfigDialogA([Const] [In] PSTR lpszName, [In] [Optional] HWND hWnd, [In] [Out] COMMCONFIG* lpCC);
BOOL CommConfigDialogW([Const] [In] PWSTR lpszName, [In] [Optional] HWND hWnd, [In] [Out] COMMCONFIG* lpCC);
BOOL GetDefaultCommConfigA([Const] [In] PSTR lpszName, [MemorySize(BytesParamIndex = 2)] [Out] COMMCONFIG* lpCC, [In] [Out] uint* lpdwSize);
BOOL GetDefaultCommConfigW([Const] [In] PWSTR lpszName, [MemorySize(BytesParamIndex = 2)] [Out] COMMCONFIG* lpCC, [In] [Out] uint* lpdwSize);
BOOL SetDefaultCommConfigA([Const] [In] PSTR lpszName, [MemorySize(BytesParamIndex = 2)] [In] COMMCONFIG* lpCC, [In] uint dwSize);
BOOL SetDefaultCommConfigW([Const] [In] PWSTR lpszName, [MemorySize(BytesParamIndex = 2)] [In] COMMCONFIG* lpCC, [In] uint dwSize);
BOOL CloseHandle([In] HANDLE hObject);
BOOL DuplicateHandle([In] HANDLE hSourceProcessHandle, [In] HANDLE hSourceHandle, [In] HANDLE hTargetProcessHandle, [Out] HANDLE* lpTargetHandle, [In] uint dwDesiredAccess, [In] BOOL bInheritHandle, [In] DUPLICATE_HANDLE_OPTIONS dwOptions);
BOOL GetHandleInformation([In] HANDLE hObject, [Out] uint* lpdwFlags);
BOOL SetHandleInformation([In] HANDLE hObject, [In] uint dwMask, [In] HANDLE_FLAGS dwFlags);
WIN32_ERROR GetLastError();
void SetLastError([In] WIN32_ERROR dwErrCode);
int GetDateFormatA([In] uint Locale, [In] uint dwFlags, [Const] [In] [Optional] SYSTEMTIME* lpDate, [Const] [In] [Optional] PSTR lpFormat, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PSTR lpDateStr, [In] int cchDate);
int GetDateFormatW([In] uint Locale, [In] uint dwFlags, [Const] [In] [Optional] SYSTEMTIME* lpDate, [Const] [In] [Optional] PWSTR lpFormat, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR lpDateStr, [In] int cchDate);
int GetTimeFormatA([In] uint Locale, [In] uint dwFlags, [Const] [In] [Optional] SYSTEMTIME* lpTime, [Const] [In] [Optional] PSTR lpFormat, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PSTR lpTimeStr, [In] int cchTime);
int GetTimeFormatW([In] uint Locale, [In] uint dwFlags, [Const] [In] [Optional] SYSTEMTIME* lpTime, [Const] [In] [Optional] PWSTR lpFormat, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR lpTimeStr, [In] int cchTime);
int GetTimeFormatEx([Const] [In] [Optional] PWSTR lpLocaleName, [In] TIME_FORMAT_FLAGS dwFlags, [Const] [In] [Optional] SYSTEMTIME* lpTime, [Const] [In] [Optional] PWSTR lpFormat, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR lpTimeStr, [In] int cchTime);
int GetDateFormatEx([Const] [In] [Optional] PWSTR lpLocaleName, [In] ENUM_DATE_FORMATS_FLAGS dwFlags, [Const] [In] [Optional] SYSTEMTIME* lpDate, [Const] [In] [Optional] PWSTR lpFormat, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR lpDateStr, [In] int cchDate, [Const] [In] [Optional] PWSTR lpCalendar);
int GetDurationFormatEx([Const] [In] [Optional] PWSTR lpLocaleName, [In] uint dwFlags, [Const] [In] [Optional] SYSTEMTIME* lpDuration, [In] ulong ullDuration, [Const] [In] [Optional] PWSTR lpFormat, [NativeArrayInfo(CountParamIndex = 6)] [Out] [Optional] PWSTR lpDurationStr, [In] int cchDuration);
int CompareStringEx([Const] [In] [Optional] PWSTR lpLocaleName, [In] COMPARE_STRING_FLAGS dwCmpFlags, [Const] [NativeArrayInfo(CountParamIndex = 3)] [In] PWSTR lpString1, [In] int cchCount1, [Const] [NativeArrayInfo(CountParamIndex = 5)] [In] PWSTR lpString2, [In] int cchCount2, [Reserved] [In] [Out] NLSVERSIONINFO* lpVersionInformation, [Reserved] [In] [Out] void* lpReserved, [Reserved] [In] LPARAM lParam);
int CompareStringOrdinal([Const] [NativeArrayInfo(CountParamIndex = 1)] [In] PWSTR lpString1, [In] int cchCount1, [Const] [NativeArrayInfo(CountParamIndex = 3)] [In] PWSTR lpString2, [In] int cchCount2, [In] BOOL bIgnoreCase);
int CompareStringW([In] uint Locale, [In] uint dwCmpFlags, [Const] [NativeArrayInfo(CountParamIndex = 3)] [In] PWSTR lpString1, [In] int cchCount1, [Const] [NativeArrayInfo(CountParamIndex = 5)] [In] PWSTR lpString2, [In] int cchCount2);
int FoldStringW([In] FOLD_STRING_MAP_FLAGS dwMapFlags, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] PWSTR lpSrcStr, [In] int cchSrc, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PWSTR lpDestStr, [In] int cchDest);
BOOL GetStringTypeExW([In] uint Locale, [In] uint dwInfoType, [Const] [NativeArrayInfo(CountParamIndex = 3)] [In] PWSTR lpSrcStr, [In] int cchSrc, [NativeArrayInfo(CountParamIndex = 3)] [Out] ushort* lpCharType);
BOOL GetStringTypeW([In] uint dwInfoType, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] PWSTR lpSrcStr, [In] int cchSrc, [Out] ushort* lpCharType);
int MultiByteToWideChar([In] uint CodePage, [In] MULTI_BYTE_TO_WIDE_CHAR_FLAGS dwFlags, [Const] [NotNullTerminated] [NativeArrayInfo(CountParamIndex = 3)] [In] PSTR lpMultiByteStr, [In] int cbMultiByte, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR lpWideCharStr, [In] int cchWideChar);
int WideCharToMultiByte([In] uint CodePage, [In] uint dwFlags, [Const] [NativeArrayInfo(CountParamIndex = 3)] [In] PWSTR lpWideCharStr, [In] int cchWideChar, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] PSTR lpMultiByteStr, [In] int cbMultiByte, [Const] [NotNullTerminated] [In] [Optional] PSTR lpDefaultChar, [Out] [Optional] int* lpUsedDefaultChar);
BOOL IsValidCodePage([In] uint CodePage);
uint GetACP();
uint GetOEMCP();
BOOL GetCPInfo([In] uint CodePage, [Out] CPINFO* lpCPInfo);
BOOL GetCPInfoExA([In] uint CodePage, [In] uint dwFlags, [Out] CPINFOEXA* lpCPInfoEx);
BOOL GetCPInfoExW([In] uint CodePage, [In] uint dwFlags, [Out] CPINFOEXW* lpCPInfoEx);
int CompareStringA([In] uint Locale, [In] uint dwCmpFlags, [NativeArrayInfo(CountParamIndex = 3)] [In] sbyte* lpString1, [In] int cchCount1, [NativeArrayInfo(CountParamIndex = 5)] [In] sbyte* lpString2, [In] int cchCount2);
int FindNLSString([In] uint Locale, [In] uint dwFindNLSStringFlags, [Const] [NativeArrayInfo(CountParamIndex = 3)] [In] PWSTR lpStringSource, [In] int cchSource, [Const] [NativeArrayInfo(CountParamIndex = 5)] [In] PWSTR lpStringValue, [In] int cchValue, [Out] [Optional] int* pcchFound);
int LCMapStringW([In] uint Locale, [In] uint dwMapFlags, [Const] [NativeArrayInfo(CountParamIndex = 3)] [In] PWSTR lpSrcStr, [In] int cchSrc, [Out] [Optional] PWSTR lpDestStr, [In] int cchDest);
int LCMapStringA([In] uint Locale, [In] uint dwMapFlags, [Const] [NativeArrayInfo(CountParamIndex = 3)] [In] PSTR lpSrcStr, [In] int cchSrc, [Out] [Optional] PSTR lpDestStr, [In] int cchDest);
int GetLocaleInfoW([In] uint Locale, [In] uint LCType, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR lpLCData, [In] int cchData);
int GetLocaleInfoA([In] uint Locale, [In] uint LCType, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PSTR lpLCData, [In] int cchData);
BOOL SetLocaleInfoA([In] uint Locale, [In] uint LCType, [Const] [In] PSTR lpLCData);
BOOL SetLocaleInfoW([In] uint Locale, [In] uint LCType, [Const] [In] PWSTR lpLCData);
int GetCalendarInfoA([In] uint Locale, [In] uint Calendar, [In] uint CalType, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PSTR lpCalData, [In] int cchData, [Out] [Optional] uint* lpValue);
int GetCalendarInfoW([In] uint Locale, [In] uint Calendar, [In] uint CalType, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PWSTR lpCalData, [In] int cchData, [Out] [Optional] uint* lpValue);
BOOL SetCalendarInfoA([In] uint Locale, [In] uint Calendar, [In] uint CalType, [Const] [In] PSTR lpCalData);
BOOL SetCalendarInfoW([In] uint Locale, [In] uint Calendar, [In] uint CalType, [Const] [In] PWSTR lpCalData);
BOOL IsDBCSLeadByte([In] byte TestChar);
BOOL IsDBCSLeadByteEx([In] uint CodePage, [In] byte TestChar);
uint LocaleNameToLCID([Const] [In] PWSTR lpName, [In] uint dwFlags);
int LCIDToLocaleName([In] uint Locale, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpName, [In] int cchName, [In] uint dwFlags);
int GetDurationFormat([In] uint Locale, [In] uint dwFlags, [Const] [In] [Optional] SYSTEMTIME* lpDuration, [In] ulong ullDuration, [Const] [In] [Optional] PWSTR lpFormat, [NativeArrayInfo(CountParamIndex = 6)] [Out] [Optional] PWSTR lpDurationStr, [In] int cchDuration);
int GetNumberFormatA([In] uint Locale, [In] uint dwFlags, [Const] [In] PSTR lpValue, [Const] [In] [Optional] NUMBERFMTA* lpFormat, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PSTR lpNumberStr, [In] int cchNumber);
int GetNumberFormatW([In] uint Locale, [In] uint dwFlags, [Const] [In] PWSTR lpValue, [Const] [In] [Optional] NUMBERFMTW* lpFormat, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR lpNumberStr, [In] int cchNumber);
int GetCurrencyFormatA([In] uint Locale, [In] uint dwFlags, [Const] [In] PSTR lpValue, [Const] [In] [Optional] CURRENCYFMTA* lpFormat, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PSTR lpCurrencyStr, [In] int cchCurrency);
int GetCurrencyFormatW([In] uint Locale, [In] uint dwFlags, [Const] [In] PWSTR lpValue, [Const] [In] [Optional] CURRENCYFMTW* lpFormat, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR lpCurrencyStr, [In] int cchCurrency);
BOOL EnumCalendarInfoA([In] CALINFO_ENUMPROCA lpCalInfoEnumProc, [In] uint Locale, [In] uint Calendar, [In] uint CalType);
BOOL EnumCalendarInfoW([In] CALINFO_ENUMPROCW lpCalInfoEnumProc, [In] uint Locale, [In] uint Calendar, [In] uint CalType);
BOOL EnumCalendarInfoExA([In] CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, [In] uint Locale, [In] uint Calendar, [In] uint CalType);
BOOL EnumCalendarInfoExW([In] CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, [In] uint Locale, [In] uint Calendar, [In] uint CalType);
BOOL EnumTimeFormatsA([In] TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, [In] uint Locale, [In] TIME_FORMAT_FLAGS dwFlags);
BOOL EnumTimeFormatsW([In] TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, [In] uint Locale, [In] TIME_FORMAT_FLAGS dwFlags);
BOOL EnumDateFormatsA([In] DATEFMT_ENUMPROCA lpDateFmtEnumProc, [In] uint Locale, [In] uint dwFlags);
BOOL EnumDateFormatsW([In] DATEFMT_ENUMPROCW lpDateFmtEnumProc, [In] uint Locale, [In] uint dwFlags);
BOOL EnumDateFormatsExA([In] DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, [In] uint Locale, [In] uint dwFlags);
BOOL EnumDateFormatsExW([In] DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, [In] uint Locale, [In] uint dwFlags);
BOOL IsValidLanguageGroup([In] uint LanguageGroup, [In] ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS dwFlags);
BOOL GetNLSVersion([In] uint Function, [In] uint Locale, [In] [Out] NLSVERSIONINFO* lpVersionInformation);
BOOL IsValidLocale([In] uint Locale, [In] IS_VALID_LOCALE_FLAGS dwFlags);
int GetGeoInfoA([In] int Location, [In] uint GeoType, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PSTR lpGeoData, [In] int cchData, [In] ushort LangId);
int GetGeoInfoW([In] int Location, [In] uint GeoType, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR lpGeoData, [In] int cchData, [In] ushort LangId);
int GetGeoInfoEx([In] PWSTR location, [In] uint geoType, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR geoData, [In] int geoDataCount);
BOOL EnumSystemGeoID([In] uint GeoClass, [In] int ParentGeoId, [In] GEO_ENUMPROC lpGeoEnumProc);
BOOL EnumSystemGeoNames([In] uint geoClass, [In] GEO_ENUMNAMEPROC geoEnumProc, [In] LPARAM data);
int GetUserGeoID([In] uint GeoClass);
int GetUserDefaultGeoName([NativeArrayInfo(CountParamIndex = 1)] [Out] PWSTR geoName, [In] int geoNameCount);
BOOL SetUserGeoID([In] int GeoId);
BOOL SetUserGeoName([In] PWSTR geoName);
uint ConvertDefaultLocale([In] uint Locale);
ushort GetSystemDefaultUILanguage();
uint GetThreadLocale();
BOOL SetThreadLocale([In] uint Locale);
ushort GetUserDefaultUILanguage();
ushort GetUserDefaultLangID();
ushort GetSystemDefaultLangID();
uint GetSystemDefaultLCID();
uint GetUserDefaultLCID();
ushort SetThreadUILanguage([In] ushort LangId);
ushort GetThreadUILanguage();
BOOL GetProcessPreferredUILanguages([In] uint dwFlags, [Out] uint* pulNumLanguages, [NotNullTerminated] [NullNullTerminated] [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR pwszLanguagesBuffer, [In] [Out] uint* pcchLanguagesBuffer);
BOOL SetProcessPreferredUILanguages([In] uint dwFlags, [Const] [NotNullTerminated] [NullNullTerminated] [In] [Optional] PWSTR pwszLanguagesBuffer, [Out] [Optional] uint* pulNumLanguages);
BOOL GetUserPreferredUILanguages([In] uint dwFlags, [Out] uint* pulNumLanguages, [NotNullTerminated] [NullNullTerminated] [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR pwszLanguagesBuffer, [In] [Out] uint* pcchLanguagesBuffer);
BOOL GetSystemPreferredUILanguages([In] uint dwFlags, [Out] uint* pulNumLanguages, [NotNullTerminated] [NullNullTerminated] [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR pwszLanguagesBuffer, [In] [Out] uint* pcchLanguagesBuffer);
BOOL GetThreadPreferredUILanguages([In] uint dwFlags, [Out] uint* pulNumLanguages, [NotNullTerminated] [NullNullTerminated] [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR pwszLanguagesBuffer, [In] [Out] uint* pcchLanguagesBuffer);
BOOL SetThreadPreferredUILanguages([In] uint dwFlags, [Const] [NotNullTerminated] [NullNullTerminated] [In] [Optional] PWSTR pwszLanguagesBuffer, [Out] [Optional] uint* pulNumLanguages);
BOOL GetFileMUIInfo([In] uint dwFlags, [Const] [In] PWSTR pcwszFilePath, [MemorySize(BytesParamIndex = 3)] [In] [Out] [Optional] FILEMUIINFO* pFileMUIInfo, [In] [Out] uint* pcbFileMUIInfo);
BOOL GetFileMUIPath([In] uint dwFlags, [Const] [In] PWSTR pcwszFilePath, [NativeArrayInfo(CountParamIndex = 3)] [In] [Out] [Optional] PWSTR pwszLanguage, [In] [Out] uint* pcchLanguage, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR pwszFileMUIPath, [In] [Out] uint* pcchFileMUIPath, [In] [Out] ulong* pululEnumerator);
BOOL GetUILanguageInfo([In] uint dwFlags, [Const] [NotNullTerminated] [NullNullTerminated] [In] PWSTR pwmszLanguage, [NotNullTerminated] [NullNullTerminated] [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR pwszFallbackLanguages, [In] [Out] [Optional] uint* pcchFallbackLanguages, [Out] uint* pAttributes);
BOOL SetThreadPreferredUILanguages2([In] uint flags, [Const] [NotNullTerminated] [NullNullTerminated] [In] [Optional] PWSTR languages, [Out] [Optional] uint* numLanguagesSet, [Out] [Optional] HSAVEDUILANGUAGES* snapshot);
void RestoreThreadPreferredUILanguages([Const] [In] HSAVEDUILANGUAGES snapshot);
BOOL NotifyUILanguageChange([In] uint dwFlags, [Const] [In] [Optional] PWSTR pcwstrNewLanguage, [Const] [In] [Optional] PWSTR pcwstrPreviousLanguage, [In] uint dwReserved, [Out] [Optional] uint* pdwStatusRtrn);
BOOL GetStringTypeExA([In] uint Locale, [In] uint dwInfoType, [Const] [NativeArrayInfo(CountParamIndex = 3)] [In] PSTR lpSrcStr, [In] int cchSrc, [NativeArrayInfo(CountParamIndex = 3)] [Out] ushort* lpCharType);
BOOL GetStringTypeA([In] uint Locale, [In] uint dwInfoType, [Const] [NativeArrayInfo(CountParamIndex = 3)] [In] PSTR lpSrcStr, [In] int cchSrc, [Out] ushort* lpCharType);
int FoldStringA([In] FOLD_STRING_MAP_FLAGS dwMapFlags, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] PSTR lpSrcStr, [In] int cchSrc, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PSTR lpDestStr, [In] int cchDest);
BOOL EnumSystemLocalesA([In] LOCALE_ENUMPROCA lpLocaleEnumProc, [In] uint dwFlags);
BOOL EnumSystemLocalesW([In] LOCALE_ENUMPROCW lpLocaleEnumProc, [In] uint dwFlags);
BOOL EnumSystemLanguageGroupsA([In] LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, [In] ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS dwFlags, [In] nint lParam);
BOOL EnumSystemLanguageGroupsW([In] LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, [In] ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS dwFlags, [In] nint lParam);
BOOL EnumLanguageGroupLocalesA([In] LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, [In] uint LanguageGroup, [In] uint dwFlags, [In] nint lParam);
BOOL EnumLanguageGroupLocalesW([In] LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, [In] uint LanguageGroup, [In] uint dwFlags, [In] nint lParam);
BOOL EnumUILanguagesA([In] UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, [In] uint dwFlags, [In] nint lParam);
BOOL EnumUILanguagesW([In] UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, [In] uint dwFlags, [In] nint lParam);
BOOL EnumSystemCodePagesA([In] CODEPAGE_ENUMPROCA lpCodePageEnumProc, [In] ENUM_SYSTEM_CODE_PAGES_FLAGS dwFlags);
BOOL EnumSystemCodePagesW([In] CODEPAGE_ENUMPROCW lpCodePageEnumProc, [In] ENUM_SYSTEM_CODE_PAGES_FLAGS dwFlags);
int IdnToNameprepUnicode([In] uint dwFlags, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] PWSTR lpUnicodeCharStr, [In] int cchUnicodeChar, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PWSTR lpNameprepCharStr, [In] int cchNameprepChar);
int NormalizeString([In] NORM_FORM NormForm, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] PWSTR lpSrcString, [In] int cwSrcLength, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PWSTR lpDstString, [In] int cwDstLength);
BOOL IsNormalizedString([In] NORM_FORM NormForm, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] PWSTR lpString, [In] int cwLength);
BOOL VerifyScripts([In] uint dwFlags, [Const] [In] PWSTR lpLocaleScripts, [In] int cchLocaleScripts, [Const] [In] PWSTR lpTestScripts, [In] int cchTestScripts);
int GetStringScripts([In] uint dwFlags, [Const] [In] PWSTR lpString, [In] int cchString, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PWSTR lpScripts, [In] int cchScripts);
int GetLocaleInfoEx([Const] [In] [Optional] PWSTR lpLocaleName, [In] uint LCType, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR lpLCData, [In] int cchData);
int GetCalendarInfoEx([Const] [In] [Optional] PWSTR lpLocaleName, [In] uint Calendar, [Const] [In] [Optional] PWSTR lpReserved, [In] uint CalType, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR lpCalData, [In] int cchData, [Out] [Optional] uint* lpValue);
int GetNumberFormatEx([Const] [In] [Optional] PWSTR lpLocaleName, [In] uint dwFlags, [Const] [In] PWSTR lpValue, [Const] [In] [Optional] NUMBERFMTW* lpFormat, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR lpNumberStr, [In] int cchNumber);
int GetCurrencyFormatEx([Const] [In] [Optional] PWSTR lpLocaleName, [In] uint dwFlags, [Const] [In] PWSTR lpValue, [Const] [In] [Optional] CURRENCYFMTW* lpFormat, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR lpCurrencyStr, [In] int cchCurrency);
int GetUserDefaultLocaleName([NativeArrayInfo(CountParamIndex = 1)] [Out] PWSTR lpLocaleName, [In] int cchLocaleName);
int GetSystemDefaultLocaleName([NativeArrayInfo(CountParamIndex = 1)] [Out] PWSTR lpLocaleName, [In] int cchLocaleName);
BOOL IsNLSDefinedString([In] uint Function, [In] uint dwFlags, [In] NLSVERSIONINFO* lpVersionInformation, [Const] [NativeArrayInfo(CountParamIndex = 4)] [In] PWSTR lpString, [In] int cchStr);
BOOL GetNLSVersionEx([In] uint function, [Const] [In] [Optional] PWSTR lpLocaleName, [In] [Out] NLSVERSIONINFOEX* lpVersionInformation);
uint IsValidNLSVersion([In] uint function, [Const] [In] [Optional] PWSTR lpLocaleName, [In] NLSVERSIONINFOEX* lpVersionInformation);
int FindNLSStringEx([Const] [In] [Optional] PWSTR lpLocaleName, [In] uint dwFindNLSStringFlags, [Const] [NativeArrayInfo(CountParamIndex = 3)] [In] PWSTR lpStringSource, [In] int cchSource, [Const] [NativeArrayInfo(CountParamIndex = 5)] [In] PWSTR lpStringValue, [In] int cchValue, [Out] [Optional] int* pcchFound, [In] [Optional] NLSVERSIONINFO* lpVersionInformation, [In] [Optional] void* lpReserved, [In] LPARAM sortHandle);
int LCMapStringEx([Const] [In] [Optional] PWSTR lpLocaleName, [In] uint dwMapFlags, [Const] [NativeArrayInfo(CountParamIndex = 3)] [In] PWSTR lpSrcStr, [In] int cchSrc, [NativeArrayInfo(CountParamIndex = 5)] [Out] [Optional] PWSTR lpDestStr, [In] int cchDest, [In] [Optional] NLSVERSIONINFO* lpVersionInformation, [In] [Optional] void* lpReserved, [In] LPARAM sortHandle);
BOOL IsValidLocaleName([Const] [In] PWSTR lpLocaleName);
BOOL EnumCalendarInfoExEx([In] CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, [Const] [In] [Optional] PWSTR lpLocaleName, [In] uint Calendar, [Const] [In] [Optional] PWSTR lpReserved, [In] uint CalType, [In] LPARAM lParam);
BOOL EnumDateFormatsExEx([In] DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, [Const] [In] [Optional] PWSTR lpLocaleName, [In] ENUM_DATE_FORMATS_FLAGS dwFlags, [In] LPARAM lParam);
BOOL EnumTimeFormatsEx([In] TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, [Const] [In] [Optional] PWSTR lpLocaleName, [In] uint dwFlags, [In] LPARAM lParam);
BOOL EnumSystemLocalesEx([In] LOCALE_ENUMPROCEX lpLocaleEnumProcEx, [In] uint dwFlags, [In] LPARAM lParam, [In] [Optional] void* lpReserved);
int ResolveLocaleName([Const] [In] [Optional] PWSTR lpNameToResolve, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpLocaleName, [In] int cchLocaleName);
int FindStringOrdinal([In] uint dwFindStringOrdinalFlags, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] PWSTR lpStringSource, [In] int cchSource, [Const] [NativeArrayInfo(CountParamIndex = 4)] [In] PWSTR lpStringValue, [In] int cchValue, [In] BOOL bIgnoreCase);
int lstrcmpA([Const] [In] PSTR lpString1, [Const] [In] PSTR lpString2);
int lstrcmpW([Const] [In] PWSTR lpString1, [Const] [In] PWSTR lpString2);
int lstrcmpiA([Const] [In] PSTR lpString1, [Const] [In] PSTR lpString2);
int lstrcmpiW([Const] [In] PWSTR lpString1, [Const] [In] PWSTR lpString2);
PSTR lstrcpynA([NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpString1, [Const] [In] PSTR lpString2, [In] int iMaxLength);
PWSTR lstrcpynW([NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpString1, [Const] [In] PWSTR lpString2, [In] int iMaxLength);
PSTR lstrcpyA([Out] PSTR lpString1, [Const] [In] PSTR lpString2);
PWSTR lstrcpyW([Out] PWSTR lpString1, [Const] [In] PWSTR lpString2);
PSTR lstrcatA([In] [Out] PSTR lpString1, [Const] [In] PSTR lpString2);
PWSTR lstrcatW([In] [Out] PWSTR lpString1, [Const] [In] PWSTR lpString2);
int lstrlenA([Const] [In] PSTR lpString);
int lstrlenW([Const] [In] PWSTR lpString);
BOOL AddResourceAttributeAce([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] ACE_FLAGS AceFlags, [In] uint AccessMask, [In] PSID pSid, [In] CLAIM_SECURITY_ATTRIBUTES_INFORMATION* pAttributeInfo, [Out] uint* pReturnLength);
BOOL AddScopedPolicyIDAce([In] [Out] ACL* pAcl, [In] ACE_REVISION dwAceRevision, [In] ACE_FLAGS AceFlags, [In] uint AccessMask, [In] PSID pSid);
BOOL CheckTokenCapability([In] [Optional] HANDLE TokenHandle, [In] PSID CapabilitySidToCheck, [Out] BOOL* HasCapability);
BOOL GetAppContainerAce([In] ACL* Acl, [In] uint StartingAceIndex, [Out] void** AppContainerAce, [Out] [Optional] uint* AppContainerAceIndex);
BOOL CheckTokenMembershipEx([In] [Optional] HANDLE TokenHandle, [In] PSID SidToCheck, [In] uint Flags, [Out] BOOL* IsMember);
BOOL SetCachedSigningLevel([NativeArrayInfo(CountParamIndex = 1)] [In] HANDLE* SourceFiles, [In] uint SourceFileCount, [In] uint Flags, [In] [Optional] HANDLE TargetFile);
BOOL GetCachedSigningLevel([In] HANDLE File, [Out] uint* Flags, [Out] uint* SigningLevel, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] byte* Thumbprint, [In] [Out] [Optional] uint* ThumbprintSize, [Out] [Optional] uint* ThumbprintAlgorithm);
BOOL GetAppContainerNamedObjectPath([In] [Optional] HANDLE Token, [In] [Optional] PSID AppContainerSid, [In] uint ObjectPathLength, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR ObjectPath, [Out] uint* ReturnLength);
uint SearchPathW([Const] [In] [Optional] PWSTR lpPath, [Const] [In] PWSTR lpFileName, [Const] [In] [Optional] PWSTR lpExtension, [In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR lpBuffer, [Out] [Optional] PWSTR* lpFilePart);
uint SearchPathA([Const] [In] [Optional] PSTR lpPath, [Const] [In] PSTR lpFileName, [Const] [In] [Optional] PSTR lpExtension, [In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PSTR lpBuffer, [Out] [Optional] PSTR* lpFilePart);
int CompareFileTime([Const] [In] FILETIME* lpFileTime1, [Const] [In] FILETIME* lpFileTime2);
BOOL CreateDirectoryA([Const] [In] PSTR lpPathName, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes);
BOOL CreateDirectoryW([Const] [In] PWSTR lpPathName, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes);
HANDLE CreateFileA([Const] [In] PSTR lpFileName, [In] FILE_ACCESS_FLAGS dwDesiredAccess, [In] FILE_SHARE_MODE dwShareMode, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [In] FILE_CREATION_DISPOSITION dwCreationDisposition, [In] FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, [In] [Optional] HANDLE hTemplateFile);
HANDLE CreateFileW([Const] [In] PWSTR lpFileName, [In] FILE_ACCESS_FLAGS dwDesiredAccess, [In] FILE_SHARE_MODE dwShareMode, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [In] FILE_CREATION_DISPOSITION dwCreationDisposition, [In] FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, [In] [Optional] HANDLE hTemplateFile);
BOOL DefineDosDeviceW([In] DEFINE_DOS_DEVICE_FLAGS dwFlags, [Const] [In] PWSTR lpDeviceName, [Const] [In] [Optional] PWSTR lpTargetPath);
BOOL DeleteFileA([Const] [In] PSTR lpFileName);
BOOL DeleteFileW([Const] [In] PWSTR lpFileName);
BOOL DeleteVolumeMountPointW([Const] [In] PWSTR lpszVolumeMountPoint);
BOOL FileTimeToLocalFileTime([Const] [In] FILETIME* lpFileTime, [Out] FILETIME* lpLocalFileTime);
BOOL FindClose([In] FindFileHandle hFindFile);
BOOL FindCloseChangeNotification([In] FindChangeNotificationHandle hChangeHandle);
FindChangeNotificationHandle FindFirstChangeNotificationA([Const] [In] PSTR lpPathName, [In] BOOL bWatchSubtree, [In] FILE_NOTIFY_CHANGE dwNotifyFilter);
FindChangeNotificationHandle FindFirstChangeNotificationW([Const] [In] PWSTR lpPathName, [In] BOOL bWatchSubtree, [In] FILE_NOTIFY_CHANGE dwNotifyFilter);
FindFileHandle FindFirstFileA([Const] [In] PSTR lpFileName, [Out] WIN32_FIND_DATAA* lpFindFileData);
FindFileHandle FindFirstFileW([Const] [In] PWSTR lpFileName, [Out] WIN32_FIND_DATAW* lpFindFileData);
FindFileHandle FindFirstFileExA([Const] [In] PSTR lpFileName, [In] FINDEX_INFO_LEVELS fInfoLevelId, [Out] void* lpFindFileData, [In] FINDEX_SEARCH_OPS fSearchOp, [Reserved] [In] [Out] void* lpSearchFilter, [In] FIND_FIRST_EX_FLAGS dwAdditionalFlags);
FindFileHandle FindFirstFileExW([Const] [In] PWSTR lpFileName, [In] FINDEX_INFO_LEVELS fInfoLevelId, [Out] void* lpFindFileData, [In] FINDEX_SEARCH_OPS fSearchOp, [Reserved] [In] [Out] void* lpSearchFilter, [In] FIND_FIRST_EX_FLAGS dwAdditionalFlags);
FindVolumeHandle FindFirstVolumeW([NativeArrayInfo(CountParamIndex = 1)] [Out] PWSTR lpszVolumeName, [In] uint cchBufferLength);
BOOL FindNextChangeNotification([In] FindChangeNotificationHandle hChangeHandle);
BOOL FindNextFileA([In] FindFileHandle hFindFile, [Out] WIN32_FIND_DATAA* lpFindFileData);
BOOL FindNextFileW([In] FindFileHandle hFindFile, [Out] WIN32_FIND_DATAW* lpFindFileData);
BOOL FindNextVolumeW([In] FindVolumeHandle hFindVolume, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpszVolumeName, [In] uint cchBufferLength);
BOOL FindVolumeClose([In] FindVolumeHandle hFindVolume);
BOOL FlushFileBuffers([In] HANDLE hFile);
BOOL GetDiskFreeSpaceA([Const] [In] [Optional] PSTR lpRootPathName, [Out] [Optional] uint* lpSectorsPerCluster, [Out] [Optional] uint* lpBytesPerSector, [Out] [Optional] uint* lpNumberOfFreeClusters, [Out] [Optional] uint* lpTotalNumberOfClusters);
BOOL GetDiskFreeSpaceW([Const] [In] [Optional] PWSTR lpRootPathName, [Out] [Optional] uint* lpSectorsPerCluster, [Out] [Optional] uint* lpBytesPerSector, [Out] [Optional] uint* lpNumberOfFreeClusters, [Out] [Optional] uint* lpTotalNumberOfClusters);
BOOL GetDiskFreeSpaceExA([Const] [In] [Optional] PSTR lpDirectoryName, [Out] [Optional] ULARGE_INTEGER* lpFreeBytesAvailableToCaller, [Out] [Optional] ULARGE_INTEGER* lpTotalNumberOfBytes, [Out] [Optional] ULARGE_INTEGER* lpTotalNumberOfFreeBytes);
BOOL GetDiskFreeSpaceExW([Const] [In] [Optional] PWSTR lpDirectoryName, [Out] [Optional] ULARGE_INTEGER* lpFreeBytesAvailableToCaller, [Out] [Optional] ULARGE_INTEGER* lpTotalNumberOfBytes, [Out] [Optional] ULARGE_INTEGER* lpTotalNumberOfFreeBytes);
HRESULT GetDiskSpaceInformationA([Const] [In] [Optional] PSTR rootPath, [Out] DISK_SPACE_INFORMATION* diskSpaceInfo);
HRESULT GetDiskSpaceInformationW([Const] [In] [Optional] PWSTR rootPath, [Out] DISK_SPACE_INFORMATION* diskSpaceInfo);
uint GetDriveTypeA([Const] [In] [Optional] PSTR lpRootPathName);
uint GetDriveTypeW([Const] [In] [Optional] PWSTR lpRootPathName);
uint GetFileAttributesA([Const] [In] PSTR lpFileName);
uint GetFileAttributesW([Const] [In] PWSTR lpFileName);
BOOL GetFileAttributesExA([Const] [In] PSTR lpFileName, [In] GET_FILEEX_INFO_LEVELS fInfoLevelId, [Out] void* lpFileInformation);
BOOL GetFileAttributesExW([Const] [In] PWSTR lpFileName, [In] GET_FILEEX_INFO_LEVELS fInfoLevelId, [Out] void* lpFileInformation);
BOOL GetFileInformationByHandle([In] HANDLE hFile, [Out] BY_HANDLE_FILE_INFORMATION* lpFileInformation);
uint GetFileSize([In] HANDLE hFile, [Out] [Optional] uint* lpFileSizeHigh);
BOOL GetFileSizeEx([In] HANDLE hFile, [Out] LARGE_INTEGER* lpFileSize);
uint GetFileType([In] HANDLE hFile);
uint GetFinalPathNameByHandleA([In] HANDLE hFile, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpszFilePath, [In] uint cchFilePath, [In] FILE_NAME dwFlags);
uint GetFinalPathNameByHandleW([In] HANDLE hFile, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpszFilePath, [In] uint cchFilePath, [In] FILE_NAME dwFlags);
BOOL GetFileTime([In] HANDLE hFile, [Out] [Optional] FILETIME* lpCreationTime, [Out] [Optional] FILETIME* lpLastAccessTime, [Out] [Optional] FILETIME* lpLastWriteTime);
uint GetFullPathNameW([Const] [In] PWSTR lpFileName, [In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR lpBuffer, [Out] [Optional] PWSTR* lpFilePart);
uint GetFullPathNameA([Const] [In] PSTR lpFileName, [In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PSTR lpBuffer, [Out] [Optional] PSTR* lpFilePart);
uint GetLogicalDrives();
uint GetLogicalDriveStringsW([In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PWSTR lpBuffer);
uint GetLongPathNameA([Const] [In] PSTR lpszShortPath, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpszLongPath, [In] uint cchBuffer);
uint GetLongPathNameW([Const] [In] PWSTR lpszShortPath, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpszLongPath, [In] uint cchBuffer);
BOOL AreShortNamesEnabled([In] HANDLE Handle, [Out] BOOL* Enabled);
uint GetShortPathNameW([Const] [In] PWSTR lpszLongPath, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpszShortPath, [In] uint cchBuffer);
uint GetTempFileNameW([Const] [In] PWSTR lpPathName, [Const] [In] PWSTR lpPrefixString, [In] uint uUnique, [NativeArrayInfo(CountConst = 260)] [Out] PWSTR lpTempFileName);
BOOL GetVolumeInformationByHandleW([In] HANDLE hFile, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpVolumeNameBuffer, [In] uint nVolumeNameSize, [Out] [Optional] uint* lpVolumeSerialNumber, [Out] [Optional] uint* lpMaximumComponentLength, [Out] [Optional] uint* lpFileSystemFlags, [NativeArrayInfo(CountParamIndex = 7)] [Out] [Optional] PWSTR lpFileSystemNameBuffer, [In] uint nFileSystemNameSize);
BOOL GetVolumeInformationW([Const] [In] [Optional] PWSTR lpRootPathName, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpVolumeNameBuffer, [In] uint nVolumeNameSize, [Out] [Optional] uint* lpVolumeSerialNumber, [Out] [Optional] uint* lpMaximumComponentLength, [Out] [Optional] uint* lpFileSystemFlags, [NativeArrayInfo(CountParamIndex = 7)] [Out] [Optional] PWSTR lpFileSystemNameBuffer, [In] uint nFileSystemNameSize);
BOOL GetVolumePathNameW([Const] [In] PWSTR lpszFileName, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpszVolumePathName, [In] uint cchBufferLength);
BOOL LocalFileTimeToFileTime([Const] [In] FILETIME* lpLocalFileTime, [Out] FILETIME* lpFileTime);
BOOL LockFile([In] HANDLE hFile, [In] uint dwFileOffsetLow, [In] uint dwFileOffsetHigh, [In] uint nNumberOfBytesToLockLow, [In] uint nNumberOfBytesToLockHigh);
BOOL LockFileEx([In] HANDLE hFile, [In] LOCK_FILE_FLAGS dwFlags, [Reserved] [In] uint dwReserved, [In] uint nNumberOfBytesToLockLow, [In] uint nNumberOfBytesToLockHigh, [In] [Out] OVERLAPPED* lpOverlapped);
uint QueryDosDeviceW([Const] [In] [Optional] PWSTR lpDeviceName, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpTargetPath, [In] uint ucchMax);
BOOL ReadFile([In] HANDLE hFile, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] void* lpBuffer, [In] uint nNumberOfBytesToRead, [Out] [Optional] uint* lpNumberOfBytesRead, [In] [Out] [Optional] OVERLAPPED* lpOverlapped);
BOOL ReadFileEx([In] HANDLE hFile, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] void* lpBuffer, [In] uint nNumberOfBytesToRead, [In] [Out] OVERLAPPED* lpOverlapped, [In] LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
BOOL ReadFileScatter([In] HANDLE hFile, [In] FILE_SEGMENT_ELEMENT* aSegmentArray, [In] uint nNumberOfBytesToRead, [Reserved] [In] [Out] uint* lpReserved, [In] [Out] OVERLAPPED* lpOverlapped);
BOOL RemoveDirectoryA([Const] [In] PSTR lpPathName);
BOOL RemoveDirectoryW([Const] [In] PWSTR lpPathName);
BOOL SetEndOfFile([In] HANDLE hFile);
BOOL SetFileAttributesA([Const] [In] PSTR lpFileName, [In] FILE_FLAGS_AND_ATTRIBUTES dwFileAttributes);
BOOL SetFileAttributesW([Const] [In] PWSTR lpFileName, [In] FILE_FLAGS_AND_ATTRIBUTES dwFileAttributes);
BOOL SetFileInformationByHandle([In] HANDLE hFile, [In] FILE_INFO_BY_HANDLE_CLASS FileInformationClass, [MemorySize(BytesParamIndex = 3)] [In] void* lpFileInformation, [In] uint dwBufferSize);
uint SetFilePointer([In] HANDLE hFile, [In] int lDistanceToMove, [In] [Out] [Optional] int* lpDistanceToMoveHigh, [In] SET_FILE_POINTER_MOVE_METHOD dwMoveMethod);
BOOL SetFilePointerEx([In] HANDLE hFile, [In] LARGE_INTEGER liDistanceToMove, [Out] [Optional] LARGE_INTEGER* lpNewFilePointer, [In] SET_FILE_POINTER_MOVE_METHOD dwMoveMethod);
BOOL SetFileTime([In] HANDLE hFile, [Const] [In] [Optional] FILETIME* lpCreationTime, [Const] [In] [Optional] FILETIME* lpLastAccessTime, [Const] [In] [Optional] FILETIME* lpLastWriteTime);
BOOL SetFileValidData([In] HANDLE hFile, [In] long ValidDataLength);
BOOL UnlockFile([In] HANDLE hFile, [In] uint dwFileOffsetLow, [In] uint dwFileOffsetHigh, [In] uint nNumberOfBytesToUnlockLow, [In] uint nNumberOfBytesToUnlockHigh);
BOOL UnlockFileEx([In] HANDLE hFile, [Reserved] [In] uint dwReserved, [In] uint nNumberOfBytesToUnlockLow, [In] uint nNumberOfBytesToUnlockHigh, [In] [Out] OVERLAPPED* lpOverlapped);
BOOL WriteFile([In] HANDLE hFile, [Const] [MemorySize(BytesParamIndex = 2)] [In] [Optional] void* lpBuffer, [In] uint nNumberOfBytesToWrite, [Out] [Optional] uint* lpNumberOfBytesWritten, [In] [Out] [Optional] OVERLAPPED* lpOverlapped);
BOOL WriteFileEx([In] HANDLE hFile, [Const] [MemorySize(BytesParamIndex = 2)] [In] [Optional] void* lpBuffer, [In] uint nNumberOfBytesToWrite, [In] [Out] OVERLAPPED* lpOverlapped, [In] LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
BOOL WriteFileGather([In] HANDLE hFile, [In] FILE_SEGMENT_ELEMENT* aSegmentArray, [In] uint nNumberOfBytesToWrite, [Reserved] [In] [Out] uint* lpReserved, [In] [Out] OVERLAPPED* lpOverlapped);
uint GetTempPathW([In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PWSTR lpBuffer);
BOOL GetVolumeNameForVolumeMountPointW([Const] [In] PWSTR lpszVolumeMountPoint, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpszVolumeName, [In] uint cchBufferLength);
BOOL GetVolumePathNamesForVolumeNameW([Const] [In] PWSTR lpszVolumeName, [NotNullTerminated] [NativeArrayInfo(CountParamIndex = 2)] [NullNullTerminated] [Out] [Optional] PWSTR lpszVolumePathNames, [In] uint cchBufferLength, [Out] uint* lpcchReturnLength);
HANDLE CreateFile2([Const] [In] PWSTR lpFileName, [In] FILE_ACCESS_FLAGS dwDesiredAccess, [In] FILE_SHARE_MODE dwShareMode, [In] FILE_CREATION_DISPOSITION dwCreationDisposition, [In] [Optional] CREATEFILE2_EXTENDED_PARAMETERS* pCreateExParams);
BOOL SetFileIoOverlappedRange([In] HANDLE FileHandle, [In] byte* OverlappedRangeStart, [In] uint Length);
uint GetCompressedFileSizeA([Const] [In] PSTR lpFileName, [Out] [Optional] uint* lpFileSizeHigh);
uint GetCompressedFileSizeW([Const] [In] PWSTR lpFileName, [Out] [Optional] uint* lpFileSizeHigh);
FindStreamHandle FindFirstStreamW([Const] [In] PWSTR lpFileName, [In] STREAM_INFO_LEVELS InfoLevel, [Out] void* lpFindStreamData, [Reserved] [In] uint dwFlags);
BOOL FindNextStreamW([In] FindStreamHandle hFindStream, [Out] void* lpFindStreamData);
BOOL AreFileApisANSI();
uint GetTempPathA([In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PSTR lpBuffer);
FindFileNameHandle FindFirstFileNameW([Const] [In] PWSTR lpFileName, [In] uint dwFlags, [In] [Out] uint* StringLength, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR LinkName);
BOOL FindNextFileNameW([In] FindFileNameHandle hFindStream, [In] [Out] uint* StringLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] PWSTR LinkName);
BOOL GetVolumeInformationA([Const] [In] [Optional] PSTR lpRootPathName, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpVolumeNameBuffer, [In] uint nVolumeNameSize, [Out] [Optional] uint* lpVolumeSerialNumber, [Out] [Optional] uint* lpMaximumComponentLength, [Out] [Optional] uint* lpFileSystemFlags, [NativeArrayInfo(CountParamIndex = 7)] [Out] [Optional] PSTR lpFileSystemNameBuffer, [In] uint nFileSystemNameSize);
uint GetTempFileNameA([Const] [In] PSTR lpPathName, [Const] [In] PSTR lpPrefixString, [In] uint uUnique, [NativeArrayInfo(CountConst = 260)] [Out] PSTR lpTempFileName);
void SetFileApisToOEM();
void SetFileApisToANSI();
uint GetTempPath2W([In] uint BufferLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PWSTR Buffer);
uint GetTempPath2A([In] uint BufferLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PSTR Buffer);
uint VerLanguageNameA([In] uint wLang, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR szLang, [In] uint cchLang);
uint VerLanguageNameW([In] uint wLang, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR szLang, [In] uint cchLang);
int LZStart();
void LZDone();
int CopyLZFile([In] int hfSource, [In] int hfDest);
int LZCopy([In] int hfSource, [In] int hfDest);
int LZInit([In] int hfSource);
int GetExpandedNameA([In] PSTR lpszSource, [NativeArrayInfo(CountConst = 260)] [Out] PSTR lpszBuffer);
int GetExpandedNameW([In] PWSTR lpszSource, [NativeArrayInfo(CountConst = 260)] [Out] PWSTR lpszBuffer);
int LZOpenFileA([In] PSTR lpFileName, [In] [Out] OFSTRUCT* lpReOpenBuf, [In] LZOPENFILE_STYLE wStyle);
int LZOpenFileW([In] PWSTR lpFileName, [In] [Out] OFSTRUCT* lpReOpenBuf, [In] LZOPENFILE_STYLE wStyle);
int LZSeek([In] int hFile, [In] int lOffset, [In] int iOrigin);
int LZRead([In] int hFile, [MemorySize(BytesParamIndex = 2)] [Out] PSTR lpBuffer, [In] int cbRead);
void LZClose([In] int hFile);
BOOLEAN Wow64EnableWow64FsRedirection([In] BOOLEAN Wow64FsEnableRedirection);
BOOL Wow64DisableWow64FsRedirection([Out] void** OldValue);
BOOL Wow64RevertWow64FsRedirection([In] void* OlValue);
BOOL GetBinaryTypeA([Const] [In] PSTR lpApplicationName, [Out] uint* lpBinaryType);
BOOL GetBinaryTypeW([Const] [In] PWSTR lpApplicationName, [Out] uint* lpBinaryType);
uint GetShortPathNameA([Const] [In] PSTR lpszLongPath, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpszShortPath, [In] uint cchBuffer);
uint GetLongPathNameTransactedA([Const] [In] PSTR lpszShortPath, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpszLongPath, [In] uint cchBuffer, [In] HANDLE hTransaction);
uint GetLongPathNameTransactedW([Const] [In] PWSTR lpszShortPath, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpszLongPath, [In] uint cchBuffer, [In] HANDLE hTransaction);
BOOL SetFileCompletionNotificationModes([In] HANDLE FileHandle, [In] byte Flags);
BOOL SetFileShortNameA([In] HANDLE hFile, [Const] [In] PSTR lpShortName);
BOOL SetFileShortNameW([In] HANDLE hFile, [Const] [In] PWSTR lpShortName);
uint SetTapePosition([In] HANDLE hDevice, [In] TAPE_POSITION_METHOD dwPositionMethod, [In] uint dwPartition, [In] uint dwOffsetLow, [In] uint dwOffsetHigh, [In] BOOL bImmediate);
uint GetTapePosition([In] HANDLE hDevice, [In] TAPE_POSITION_TYPE dwPositionType, [Out] uint* lpdwPartition, [Out] uint* lpdwOffsetLow, [Out] uint* lpdwOffsetHigh);
uint PrepareTape([In] HANDLE hDevice, [In] PREPARE_TAPE_OPERATION dwOperation, [In] BOOL bImmediate);
uint EraseTape([In] HANDLE hDevice, [In] ERASE_TAPE_TYPE dwEraseType, [In] BOOL bImmediate);
uint CreateTapePartition([In] HANDLE hDevice, [In] CREATE_TAPE_PARTITION_METHOD dwPartitionMethod, [In] uint dwCount, [In] uint dwSize);
uint WriteTapemark([In] HANDLE hDevice, [In] TAPEMARK_TYPE dwTapemarkType, [In] uint dwTapemarkCount, [In] BOOL bImmediate);
uint GetTapeStatus([In] HANDLE hDevice);
uint GetTapeParameters([In] HANDLE hDevice, [In] GET_TAPE_DRIVE_PARAMETERS_OPERATION dwOperation, [In] [Out] uint* lpdwSize, [MemorySize(BytesParamIndex = 2)] [Out] void* lpTapeInformation);
uint SetTapeParameters([In] HANDLE hDevice, [In] TAPE_INFORMATION_TYPE dwOperation, [In] void* lpTapeInformation);
int OpenFile([Const] [In] PSTR lpFileName, [In] [Out] OFSTRUCT* lpReOpenBuff, [In] uint uStyle);
BOOL BackupRead([In] HANDLE hFile, [MemorySize(BytesParamIndex = 2)] [Out] byte* lpBuffer, [In] uint nNumberOfBytesToRead, [Out] uint* lpNumberOfBytesRead, [In] BOOL bAbort, [In] BOOL bProcessSecurity, [In] [Out] void** lpContext);
BOOL BackupSeek([In] HANDLE hFile, [In] uint dwLowBytesToSeek, [In] uint dwHighBytesToSeek, [Out] uint* lpdwLowByteSeeked, [Out] uint* lpdwHighByteSeeked, [In] [Out] void** lpContext);
BOOL BackupWrite([In] HANDLE hFile, [MemorySize(BytesParamIndex = 2)] [In] byte* lpBuffer, [In] uint nNumberOfBytesToWrite, [Out] uint* lpNumberOfBytesWritten, [In] BOOL bAbort, [In] BOOL bProcessSecurity, [In] [Out] void** lpContext);
uint GetLogicalDriveStringsA([In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PSTR lpBuffer);
BOOL SetSearchPathMode([In] uint Flags);
BOOL CreateDirectoryExA([Const] [In] PSTR lpTemplateDirectory, [Const] [In] PSTR lpNewDirectory, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes);
BOOL CreateDirectoryExW([Const] [In] PWSTR lpTemplateDirectory, [Const] [In] PWSTR lpNewDirectory, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes);
BOOL CreateDirectoryTransactedA([Const] [In] [Optional] PSTR lpTemplateDirectory, [Const] [In] PSTR lpNewDirectory, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [In] HANDLE hTransaction);
BOOL CreateDirectoryTransactedW([Const] [In] [Optional] PWSTR lpTemplateDirectory, [Const] [In] PWSTR lpNewDirectory, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [In] HANDLE hTransaction);
BOOL RemoveDirectoryTransactedA([Const] [In] PSTR lpPathName, [In] HANDLE hTransaction);
BOOL RemoveDirectoryTransactedW([Const] [In] PWSTR lpPathName, [In] HANDLE hTransaction);
uint GetFullPathNameTransactedA([Const] [In] PSTR lpFileName, [In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PSTR lpBuffer, [Out] [Optional] PSTR* lpFilePart, [In] HANDLE hTransaction);
uint GetFullPathNameTransactedW([Const] [In] PWSTR lpFileName, [In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR lpBuffer, [Out] [Optional] PWSTR* lpFilePart, [In] HANDLE hTransaction);
BOOL DefineDosDeviceA([In] DEFINE_DOS_DEVICE_FLAGS dwFlags, [Const] [In] PSTR lpDeviceName, [Const] [In] [Optional] PSTR lpTargetPath);
uint QueryDosDeviceA([Const] [In] [Optional] PSTR lpDeviceName, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpTargetPath, [In] uint ucchMax);
HANDLE CreateFileTransactedA([Const] [In] PSTR lpFileName, [In] uint dwDesiredAccess, [In] FILE_SHARE_MODE dwShareMode, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [In] FILE_CREATION_DISPOSITION dwCreationDisposition, [In] FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, [In] [Optional] HANDLE hTemplateFile, [In] HANDLE hTransaction, [In] [Optional] TXFS_MINIVERSION* pusMiniVersion, [Reserved] [In] [Out] void* lpExtendedParameter);
HANDLE CreateFileTransactedW([Const] [In] PWSTR lpFileName, [In] uint dwDesiredAccess, [In] FILE_SHARE_MODE dwShareMode, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [In] FILE_CREATION_DISPOSITION dwCreationDisposition, [In] FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, [In] [Optional] HANDLE hTemplateFile, [In] HANDLE hTransaction, [In] [Optional] TXFS_MINIVERSION* pusMiniVersion, [Reserved] [In] [Out] void* lpExtendedParameter);
HANDLE ReOpenFile([In] HANDLE hOriginalFile, [In] FILE_ACCESS_FLAGS dwDesiredAccess, [In] FILE_SHARE_MODE dwShareMode, [In] FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
BOOL SetFileAttributesTransactedA([Const] [In] PSTR lpFileName, [In] uint dwFileAttributes, [In] HANDLE hTransaction);
BOOL SetFileAttributesTransactedW([Const] [In] PWSTR lpFileName, [In] uint dwFileAttributes, [In] HANDLE hTransaction);
BOOL GetFileAttributesTransactedA([Const] [In] PSTR lpFileName, [In] GET_FILEEX_INFO_LEVELS fInfoLevelId, [Out] void* lpFileInformation, [In] HANDLE hTransaction);
BOOL GetFileAttributesTransactedW([Const] [In] PWSTR lpFileName, [In] GET_FILEEX_INFO_LEVELS fInfoLevelId, [Out] void* lpFileInformation, [In] HANDLE hTransaction);
uint GetCompressedFileSizeTransactedA([Const] [In] PSTR lpFileName, [Out] [Optional] uint* lpFileSizeHigh, [In] HANDLE hTransaction);
uint GetCompressedFileSizeTransactedW([Const] [In] PWSTR lpFileName, [Out] [Optional] uint* lpFileSizeHigh, [In] HANDLE hTransaction);
BOOL DeleteFileTransactedA([Const] [In] PSTR lpFileName, [In] HANDLE hTransaction);
BOOL DeleteFileTransactedW([Const] [In] PWSTR lpFileName, [In] HANDLE hTransaction);
BOOL CheckNameLegalDOS8Dot3A([Const] [In] PSTR lpName, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpOemName, [In] uint OemNameSize, [Out] [Optional] BOOL* pbNameContainsSpaces, [Out] BOOL* pbNameLegal);
BOOL CheckNameLegalDOS8Dot3W([Const] [In] PWSTR lpName, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpOemName, [In] uint OemNameSize, [Out] [Optional] BOOL* pbNameContainsSpaces, [Out] BOOL* pbNameLegal);
FindFileHandle FindFirstFileTransactedA([Const] [In] PSTR lpFileName, [In] FINDEX_INFO_LEVELS fInfoLevelId, [Out] void* lpFindFileData, [In] FINDEX_SEARCH_OPS fSearchOp, [Reserved] [In] [Out] void* lpSearchFilter, [In] uint dwAdditionalFlags, [In] HANDLE hTransaction);
FindFileHandle FindFirstFileTransactedW([Const] [In] PWSTR lpFileName, [In] FINDEX_INFO_LEVELS fInfoLevelId, [Out] void* lpFindFileData, [In] FINDEX_SEARCH_OPS fSearchOp, [Reserved] [In] [Out] void* lpSearchFilter, [In] uint dwAdditionalFlags, [In] HANDLE hTransaction);
BOOL CopyFileA([Const] [In] PSTR lpExistingFileName, [Const] [In] PSTR lpNewFileName, [In] BOOL bFailIfExists);
BOOL CopyFileW([Const] [In] PWSTR lpExistingFileName, [Const] [In] PWSTR lpNewFileName, [In] BOOL bFailIfExists);
BOOL CopyFileExA([Const] [In] PSTR lpExistingFileName, [Const] [In] PSTR lpNewFileName, [In] [Optional] LPPROGRESS_ROUTINE lpProgressRoutine, [In] [Optional] void* lpData, [In] [Out] [Optional] int* pbCancel, [In] uint dwCopyFlags);
BOOL CopyFileExW([Const] [In] PWSTR lpExistingFileName, [Const] [In] PWSTR lpNewFileName, [In] [Optional] LPPROGRESS_ROUTINE lpProgressRoutine, [In] [Optional] void* lpData, [In] [Out] [Optional] int* pbCancel, [In] uint dwCopyFlags);
BOOL CopyFileTransactedA([Const] [In] PSTR lpExistingFileName, [Const] [In] PSTR lpNewFileName, [In] [Optional] LPPROGRESS_ROUTINE lpProgressRoutine, [In] [Optional] void* lpData, [In] [Optional] int* pbCancel, [In] uint dwCopyFlags, [In] HANDLE hTransaction);
BOOL CopyFileTransactedW([Const] [In] PWSTR lpExistingFileName, [Const] [In] PWSTR lpNewFileName, [In] [Optional] LPPROGRESS_ROUTINE lpProgressRoutine, [In] [Optional] void* lpData, [In] [Optional] int* pbCancel, [In] uint dwCopyFlags, [In] HANDLE hTransaction);
HRESULT CopyFile2([Const] [In] PWSTR pwszExistingFileName, [Const] [In] PWSTR pwszNewFileName, [In] [Optional] COPYFILE2_EXTENDED_PARAMETERS* pExtendedParameters);
BOOL MoveFileA([Const] [In] PSTR lpExistingFileName, [Const] [In] PSTR lpNewFileName);
BOOL MoveFileW([Const] [In] PWSTR lpExistingFileName, [Const] [In] PWSTR lpNewFileName);
BOOL MoveFileExA([Const] [In] PSTR lpExistingFileName, [Const] [In] [Optional] PSTR lpNewFileName, [In] MOVE_FILE_FLAGS dwFlags);
BOOL MoveFileExW([Const] [In] PWSTR lpExistingFileName, [Const] [In] [Optional] PWSTR lpNewFileName, [In] MOVE_FILE_FLAGS dwFlags);
BOOL MoveFileWithProgressA([Const] [In] PSTR lpExistingFileName, [Const] [In] [Optional] PSTR lpNewFileName, [In] [Optional] LPPROGRESS_ROUTINE lpProgressRoutine, [In] [Optional] void* lpData, [In] MOVE_FILE_FLAGS dwFlags);
BOOL MoveFileWithProgressW([Const] [In] PWSTR lpExistingFileName, [Const] [In] [Optional] PWSTR lpNewFileName, [In] [Optional] LPPROGRESS_ROUTINE lpProgressRoutine, [In] [Optional] void* lpData, [In] MOVE_FILE_FLAGS dwFlags);
BOOL MoveFileTransactedA([Const] [In] PSTR lpExistingFileName, [Const] [In] [Optional] PSTR lpNewFileName, [In] [Optional] LPPROGRESS_ROUTINE lpProgressRoutine, [In] [Optional] void* lpData, [In] MOVE_FILE_FLAGS dwFlags, [In] HANDLE hTransaction);
BOOL MoveFileTransactedW([Const] [In] PWSTR lpExistingFileName, [Const] [In] [Optional] PWSTR lpNewFileName, [In] [Optional] LPPROGRESS_ROUTINE lpProgressRoutine, [In] [Optional] void* lpData, [In] MOVE_FILE_FLAGS dwFlags, [In] HANDLE hTransaction);
BOOL ReplaceFileA([Const] [In] PSTR lpReplacedFileName, [Const] [In] PSTR lpReplacementFileName, [Const] [In] [Optional] PSTR lpBackupFileName, [In] REPLACE_FILE_FLAGS dwReplaceFlags, [Reserved] [In] [Out] void* lpExclude, [Reserved] [In] [Out] void* lpReserved);
BOOL ReplaceFileW([Const] [In] PWSTR lpReplacedFileName, [Const] [In] PWSTR lpReplacementFileName, [Const] [In] [Optional] PWSTR lpBackupFileName, [In] REPLACE_FILE_FLAGS dwReplaceFlags, [Reserved] [In] [Out] void* lpExclude, [Reserved] [In] [Out] void* lpReserved);
BOOL CreateHardLinkA([Const] [In] PSTR lpFileName, [Const] [In] PSTR lpExistingFileName, [Reserved] [In] [Out] SECURITY_ATTRIBUTES* lpSecurityAttributes);
BOOL CreateHardLinkW([Const] [In] PWSTR lpFileName, [Const] [In] PWSTR lpExistingFileName, [Reserved] [In] [Out] SECURITY_ATTRIBUTES* lpSecurityAttributes);
BOOL CreateHardLinkTransactedA([Const] [In] PSTR lpFileName, [Const] [In] PSTR lpExistingFileName, [Reserved] [In] [Out] SECURITY_ATTRIBUTES* lpSecurityAttributes, [In] HANDLE hTransaction);
BOOL CreateHardLinkTransactedW([Const] [In] PWSTR lpFileName, [Const] [In] PWSTR lpExistingFileName, [Reserved] [In] [Out] SECURITY_ATTRIBUTES* lpSecurityAttributes, [In] HANDLE hTransaction);
FindStreamHandle FindFirstStreamTransactedW([Const] [In] PWSTR lpFileName, [In] STREAM_INFO_LEVELS InfoLevel, [Out] void* lpFindStreamData, [Reserved] [In] uint dwFlags, [In] HANDLE hTransaction);
FindFileNameHandle FindFirstFileNameTransactedW([Const] [In] PWSTR lpFileName, [In] uint dwFlags, [In] [Out] uint* StringLength, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR LinkName, [In] [Optional] HANDLE hTransaction);
BOOL SetVolumeLabelA([Const] [In] [Optional] PSTR lpRootPathName, [Const] [In] [Optional] PSTR lpVolumeName);
BOOL SetVolumeLabelW([Const] [In] [Optional] PWSTR lpRootPathName, [Const] [In] [Optional] PWSTR lpVolumeName);
BOOL SetFileBandwidthReservation([In] HANDLE hFile, [In] uint nPeriodMilliseconds, [In] uint nBytesPerPeriod, [In] BOOL bDiscardable, [Out] uint* lpTransferSize, [Out] uint* lpNumOutstandingRequests);
BOOL GetFileBandwidthReservation([In] HANDLE hFile, [Out] uint* lpPeriodMilliseconds, [Out] uint* lpBytesPerPeriod, [Out] int* pDiscardable, [Out] uint* lpTransferSize, [Out] uint* lpNumOutstandingRequests);
BOOL ReadDirectoryChangesW([In] HANDLE hDirectory, [MemorySize(BytesParamIndex = 2)] [Out] void* lpBuffer, [In] uint nBufferLength, [In] BOOL bWatchSubtree, [In] FILE_NOTIFY_CHANGE dwNotifyFilter, [Out] [Optional] uint* lpBytesReturned, [In] [Out] [Optional] OVERLAPPED* lpOverlapped, [In] [Optional] LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
BOOL ReadDirectoryChangesExW([In] HANDLE hDirectory, [MemorySize(BytesParamIndex = 2)] [Out] void* lpBuffer, [In] uint nBufferLength, [In] BOOL bWatchSubtree, [In] FILE_NOTIFY_CHANGE dwNotifyFilter, [Out] [Optional] uint* lpBytesReturned, [In] [Out] [Optional] OVERLAPPED* lpOverlapped, [In] [Optional] LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, [In] READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass);
FindVolumeHandle FindFirstVolumeA([NativeArrayInfo(CountParamIndex = 1)] [Out] PSTR lpszVolumeName, [In] uint cchBufferLength);
BOOL FindNextVolumeA([In] FindVolumeHandle hFindVolume, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpszVolumeName, [In] uint cchBufferLength);
FindVolumeMointPointHandle FindFirstVolumeMountPointA([Const] [In] PSTR lpszRootPathName, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpszVolumeMountPoint, [In] uint cchBufferLength);
FindVolumeMointPointHandle FindFirstVolumeMountPointW([Const] [In] PWSTR lpszRootPathName, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpszVolumeMountPoint, [In] uint cchBufferLength);
BOOL FindNextVolumeMountPointA([In] FindVolumeMointPointHandle hFindVolumeMountPoint, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpszVolumeMountPoint, [In] uint cchBufferLength);
BOOL FindNextVolumeMountPointW([In] FindVolumeMointPointHandle hFindVolumeMountPoint, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpszVolumeMountPoint, [In] uint cchBufferLength);
BOOL FindVolumeMountPointClose([In] FindVolumeMointPointHandle hFindVolumeMountPoint);
BOOL SetVolumeMountPointA([Const] [In] PSTR lpszVolumeMountPoint, [Const] [In] PSTR lpszVolumeName);
BOOL SetVolumeMountPointW([Const] [In] PWSTR lpszVolumeMountPoint, [Const] [In] PWSTR lpszVolumeName);
BOOL DeleteVolumeMountPointA([Const] [In] PSTR lpszVolumeMountPoint);
BOOL GetVolumeNameForVolumeMountPointA([Const] [In] PSTR lpszVolumeMountPoint, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpszVolumeName, [In] uint cchBufferLength);
BOOL GetVolumePathNameA([Const] [In] PSTR lpszFileName, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpszVolumePathName, [In] uint cchBufferLength);
BOOL GetVolumePathNamesForVolumeNameA([Const] [In] PSTR lpszVolumeName, [NotNullTerminated] [NativeArrayInfo(CountParamIndex = 2)] [NullNullTerminated] [Out] [Optional] PSTR lpszVolumePathNames, [In] uint cchBufferLength, [Out] uint* lpcchReturnLength);
BOOL GetFileInformationByHandleEx([In] HANDLE hFile, [In] FILE_INFO_BY_HANDLE_CLASS FileInformationClass, [MemorySize(BytesParamIndex = 3)] [Out] void* lpFileInformation, [In] uint dwBufferSize);
HANDLE OpenFileById([In] HANDLE hVolumeHint, [In] FILE_ID_DESCRIPTOR* lpFileId, [In] FILE_ACCESS_FLAGS dwDesiredAccess, [In] FILE_SHARE_MODE dwShareMode, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [In] FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
BOOLEAN CreateSymbolicLinkA([Const] [In] PSTR lpSymlinkFileName, [Const] [In] PSTR lpTargetFileName, [In] SYMBOLIC_LINK_FLAGS dwFlags);
BOOLEAN CreateSymbolicLinkW([Const] [In] PWSTR lpSymlinkFileName, [Const] [In] PWSTR lpTargetFileName, [In] SYMBOLIC_LINK_FLAGS dwFlags);
BOOLEAN CreateSymbolicLinkTransactedA([Const] [In] PSTR lpSymlinkFileName, [Const] [In] PSTR lpTargetFileName, [In] SYMBOLIC_LINK_FLAGS dwFlags, [In] HANDLE hTransaction);
BOOLEAN CreateSymbolicLinkTransactedW([Const] [In] PWSTR lpSymlinkFileName, [Const] [In] PWSTR lpTargetFileName, [In] SYMBOLIC_LINK_FLAGS dwFlags, [In] HANDLE hTransaction);
WIN32_ERROR GetCurrentPackageId([In] [Out] uint* bufferLength, [MemorySize(BytesParamIndex = 0)] [Out] [Optional] byte* buffer);
WIN32_ERROR GetCurrentPackageFullName([In] [Out] uint* packageFullNameLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PWSTR packageFullName);
WIN32_ERROR GetCurrentPackageFamilyName([In] [Out] uint* packageFamilyNameLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PWSTR packageFamilyName);
WIN32_ERROR GetCurrentPackagePath([In] [Out] uint* pathLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PWSTR path);
WIN32_ERROR GetPackageId([In] HANDLE hProcess, [In] [Out] uint* bufferLength, [MemorySize(BytesParamIndex = 1)] [Out] [Optional] byte* buffer);
WIN32_ERROR GetPackageFullName([In] HANDLE hProcess, [In] [Out] uint* packageFullNameLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR packageFullName);
WIN32_ERROR GetPackageFamilyName([In] HANDLE hProcess, [In] [Out] uint* packageFamilyNameLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR packageFamilyName);
WIN32_ERROR GetPackagePath([Const] [In] PACKAGE_ID* packageId, [Const] [Reserved] [In] uint reserved, [In] [Out] uint* pathLength, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR path);
WIN32_ERROR GetPackagePathByFullName([Const] [In] PWSTR packageFullName, [In] [Out] uint* pathLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR path);
WIN32_ERROR GetStagedPackagePathByFullName([Const] [In] PWSTR packageFullName, [In] [Out] uint* pathLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR path);
WIN32_ERROR GetCurrentApplicationUserModelId([In] [Out] uint* applicationUserModelIdLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PWSTR applicationUserModelId);
WIN32_ERROR GetApplicationUserModelId([In] HANDLE hProcess, [In] [Out] uint* applicationUserModelIdLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR applicationUserModelId);
WIN32_ERROR PackageIdFromFullName([Const] [In] PWSTR packageFullName, [Const] [In] uint flags, [In] [Out] uint* bufferLength, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] byte* buffer);
WIN32_ERROR PackageFullNameFromId([Const] [In] PACKAGE_ID* packageId, [In] [Out] uint* packageFullNameLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR packageFullName);
WIN32_ERROR PackageFamilyNameFromId([Const] [In] PACKAGE_ID* packageId, [In] [Out] uint* packageFamilyNameLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR packageFamilyName);
WIN32_ERROR PackageFamilyNameFromFullName([Const] [In] PWSTR packageFullName, [In] [Out] uint* packageFamilyNameLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR packageFamilyName);
WIN32_ERROR PackageNameAndPublisherIdFromFamilyName([Const] [In] PWSTR packageFamilyName, [In] [Out] uint* packageNameLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR packageName, [In] [Out] uint* packagePublisherIdLength, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR packagePublisherId);
WIN32_ERROR FormatApplicationUserModelId([Const] [In] PWSTR packageFamilyName, [Const] [In] PWSTR packageRelativeApplicationId, [In] [Out] uint* applicationUserModelIdLength, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR applicationUserModelId);
WIN32_ERROR ParseApplicationUserModelId([Const] [In] PWSTR applicationUserModelId, [In] [Out] uint* packageFamilyNameLength, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR packageFamilyName, [In] [Out] uint* packageRelativeApplicationIdLength, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR packageRelativeApplicationId);
WIN32_ERROR GetPackagesByPackageFamily([Const] [In] PWSTR packageFamilyName, [In] [Out] uint* count, [NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR* packageFullNames, [In] [Out] uint* bufferLength, [NativeArrayInfo(CountParamIndex = 3)] [Out] [Optional] PWSTR buffer);
WIN32_ERROR FindPackagesByPackageFamily([Const] [In] PWSTR packageFamilyName, [In] uint packageFilters, [In] [Out] uint* count, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR* packageFullNames, [In] [Out] uint* bufferLength, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PWSTR buffer, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] uint* packageProperties);
WIN32_ERROR GetCurrentPackageInfo([Const] [In] uint flags, [In] [Out] uint* bufferLength, [MemorySize(BytesParamIndex = 1)] [Out] [Optional] byte* buffer, [Out] [Optional] uint* count);
WIN32_ERROR OpenPackageInfoByFullName([Const] [In] PWSTR packageFullName, [Const] [Reserved] [In] uint reserved, [Out] _PACKAGE_INFO_REFERENCE** packageInfoReference);
WIN32_ERROR ClosePackageInfo([In] _PACKAGE_INFO_REFERENCE* packageInfoReference);
WIN32_ERROR GetPackageInfo([In] _PACKAGE_INFO_REFERENCE* packageInfoReference, [Const] [In] uint flags, [In] [Out] uint* bufferLength, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] byte* buffer, [Out] [Optional] uint* count);
WIN32_ERROR GetPackageApplicationIds([In] _PACKAGE_INFO_REFERENCE* packageInfoReference, [In] [Out] uint* bufferLength, [MemorySize(BytesParamIndex = 1)] [Out] [Optional] byte* buffer, [Out] [Optional] uint* count);
HRESULT CheckIsMSIXPackage([Const] [In] PWSTR packageFullName, [Out] BOOL* isMSIXPackage);
WIN32_ERROR AppPolicyGetLifecycleManagement([In] HANDLE processToken, [Out] AppPolicyLifecycleManagement* policy);
WIN32_ERROR AppPolicyGetWindowingModel([In] HANDLE processToken, [Out] AppPolicyWindowingModel* policy);
WIN32_ERROR AppPolicyGetMediaFoundationCodecLoading([In] HANDLE processToken, [Out] AppPolicyMediaFoundationCodecLoading* policy);
WIN32_ERROR AppPolicyGetClrCompat([In] HANDLE processToken, [Out] AppPolicyClrCompat* policy);
WIN32_ERROR AppPolicyGetThreadInitializationType([In] HANDLE processToken, [Out] AppPolicyThreadInitializationType* policy);
WIN32_ERROR AppPolicyGetShowDeveloperDiagnostic([In] HANDLE processToken, [Out] AppPolicyShowDeveloperDiagnostic* policy);
WIN32_ERROR AppPolicyGetProcessTerminationMethod([In] HANDLE processToken, [Out] AppPolicyProcessTerminationMethod* policy);
WIN32_ERROR AppPolicyGetCreateFileAccess([In] HANDLE processToken, [Out] AppPolicyCreateFileAccess* policy);
HRESULT CreatePackageVirtualizationContext([Const] [In] [Optional] PWSTR packageFamilyName, [Out] PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__** context);
HRESULT ActivatePackageVirtualizationContext([In] PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__* context, [Out] nuint* cookie);
void ReleasePackageVirtualizationContext([In] PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__* context);
void DeactivatePackageVirtualizationContext([In] nuint cookie);
HRESULT DuplicatePackageVirtualizationContext([In] PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__* sourceContext, [Out] PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__** destContext);
PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__* GetCurrentPackageVirtualizationContext();
HRESULT GetProcessesInVirtualizationContext([Const] [In] PWSTR packageFamilyName, [Out] uint* count, [Out] HANDLE** processes);
BOOL InstallELAMCertificateInfo([In] HANDLE ELAMFile);
HANDLE CreateActCtxA([In] ACTCTXA* pActCtx);
HANDLE CreateActCtxW([In] ACTCTXW* pActCtx);
void AddRefActCtx([In] HANDLE hActCtx);
void ReleaseActCtx([In] HANDLE hActCtx);
BOOL ZombifyActCtx([In] HANDLE hActCtx);
BOOL ActivateActCtx([In] [Optional] HANDLE hActCtx, [Out] nuint* lpCookie);
BOOL DeactivateActCtx([In] uint dwFlags, [In] nuint ulCookie);
BOOL GetCurrentActCtx([Out] HANDLE* lphActCtx);
BOOL FindActCtxSectionStringA([In] uint dwFlags, [Const] [Reserved] [In] Guid* lpExtensionGuid, [In] uint ulSectionId, [Const] [In] PSTR lpStringToFind, [Out] ACTCTX_SECTION_KEYED_DATA* ReturnedData);
BOOL FindActCtxSectionStringW([In] uint dwFlags, [Const] [Reserved] [In] Guid* lpExtensionGuid, [In] uint ulSectionId, [Const] [In] PWSTR lpStringToFind, [Out] ACTCTX_SECTION_KEYED_DATA* ReturnedData);
BOOL FindActCtxSectionGuid([In] uint dwFlags, [Const] [Reserved] [In] Guid* lpExtensionGuid, [In] uint ulSectionId, [Const] [In] [Optional] Guid* lpGuidToFind, [Out] ACTCTX_SECTION_KEYED_DATA* ReturnedData);
BOOL QueryActCtxW([In] uint dwFlags, [In] HANDLE hActCtx, [In] [Optional] void* pvSubInstance, [In] uint ulInfoClass, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] void* pvBuffer, [In] nuint cbBuffer, [Out] [Optional] nuint* pcbWrittenOrRequired);
BOOL QueryActCtxSettingsW([In] [Optional] uint dwFlags, [In] [Optional] HANDLE hActCtx, [Const] [In] [Optional] PWSTR settingsNameSpace, [Const] [In] PWSTR settingName, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] PWSTR pvBuffer, [In] nuint dwBuffer, [Out] [Optional] nuint* pdwWrittenOrRequired);
BOOL AllocConsole();
BOOL FreeConsole();
BOOL AttachConsole([In] uint dwProcessId);
uint GetConsoleCP();
uint GetConsoleOutputCP();
BOOL GetConsoleMode([In] HANDLE hConsoleHandle, [Out] CONSOLE_MODE* lpMode);
BOOL SetConsoleMode([In] HANDLE hConsoleHandle, [In] CONSOLE_MODE dwMode);
BOOL GetNumberOfConsoleInputEvents([In] HANDLE hConsoleInput, [Out] uint* lpNumberOfEvents);
BOOL ReadConsoleInputA([In] HANDLE hConsoleInput, [NativeArrayInfo(CountParamIndex = 2)] [Out] INPUT_RECORD* lpBuffer, [In] uint nLength, [Out] uint* lpNumberOfEventsRead);
BOOL ReadConsoleInputW([In] HANDLE hConsoleInput, [NativeArrayInfo(CountParamIndex = 2)] [Out] INPUT_RECORD* lpBuffer, [In] uint nLength, [Out] uint* lpNumberOfEventsRead);
BOOL PeekConsoleInputA([In] HANDLE hConsoleInput, [NativeArrayInfo(CountParamIndex = 2)] [Out] INPUT_RECORD* lpBuffer, [In] uint nLength, [Out] uint* lpNumberOfEventsRead);
BOOL PeekConsoleInputW([In] HANDLE hConsoleInput, [NativeArrayInfo(CountParamIndex = 2)] [Out] INPUT_RECORD* lpBuffer, [In] uint nLength, [Out] uint* lpNumberOfEventsRead);
BOOL ReadConsoleA([In] HANDLE hConsoleInput, [Out] void* lpBuffer, [In] uint nNumberOfCharsToRead, [Out] uint* lpNumberOfCharsRead, [In] [Optional] CONSOLE_READCONSOLE_CONTROL* pInputControl);
BOOL ReadConsoleW([In] HANDLE hConsoleInput, [Out] void* lpBuffer, [In] uint nNumberOfCharsToRead, [Out] uint* lpNumberOfCharsRead, [In] [Optional] CONSOLE_READCONSOLE_CONTROL* pInputControl);
BOOL WriteConsoleA([In] HANDLE hConsoleOutput, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] void* lpBuffer, [In] uint nNumberOfCharsToWrite, [Out] [Optional] uint* lpNumberOfCharsWritten, [Reserved] [In] [Out] void* lpReserved);
BOOL WriteConsoleW([In] HANDLE hConsoleOutput, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] void* lpBuffer, [In] uint nNumberOfCharsToWrite, [Out] [Optional] uint* lpNumberOfCharsWritten, [Reserved] [In] [Out] void* lpReserved);
BOOL SetConsoleCtrlHandler([In] [Optional] PHANDLER_ROUTINE HandlerRoutine, [In] BOOL Add);
HRESULT CreatePseudoConsole([In] COORD size, [In] HANDLE hInput, [In] HANDLE hOutput, [In] uint dwFlags, [Out] HPCON* phPC);
HRESULT ResizePseudoConsole([In] HPCON hPC, [In] COORD size);
void ClosePseudoConsole([In] HPCON hPC);
BOOL FillConsoleOutputCharacterA([In] HANDLE hConsoleOutput, [In] CHAR cCharacter, [In] uint nLength, [In] COORD dwWriteCoord, [Out] uint* lpNumberOfCharsWritten);
BOOL FillConsoleOutputCharacterW([In] HANDLE hConsoleOutput, [In] wchar cCharacter, [In] uint nLength, [In] COORD dwWriteCoord, [Out] uint* lpNumberOfCharsWritten);
BOOL FillConsoleOutputAttribute([In] HANDLE hConsoleOutput, [In] ushort wAttribute, [In] uint nLength, [In] COORD dwWriteCoord, [Out] uint* lpNumberOfAttrsWritten);
BOOL GenerateConsoleCtrlEvent([In] uint dwCtrlEvent, [In] uint dwProcessGroupId);
HANDLE CreateConsoleScreenBuffer([In] uint dwDesiredAccess, [In] uint dwShareMode, [Const] [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes, [In] uint dwFlags, [Reserved] [In] [Out] void* lpScreenBufferData);
BOOL SetConsoleActiveScreenBuffer([In] HANDLE hConsoleOutput);
BOOL FlushConsoleInputBuffer([In] HANDLE hConsoleInput);
BOOL SetConsoleCP([In] uint wCodePageID);
BOOL SetConsoleOutputCP([In] uint wCodePageID);
BOOL GetConsoleCursorInfo([In] HANDLE hConsoleOutput, [Out] CONSOLE_CURSOR_INFO* lpConsoleCursorInfo);
BOOL SetConsoleCursorInfo([In] HANDLE hConsoleOutput, [Const] [In] CONSOLE_CURSOR_INFO* lpConsoleCursorInfo);
BOOL GetConsoleScreenBufferInfo([In] HANDLE hConsoleOutput, [Out] CONSOLE_SCREEN_BUFFER_INFO* lpConsoleScreenBufferInfo);
BOOL GetConsoleScreenBufferInfoEx([In] HANDLE hConsoleOutput, [In] [Out] CONSOLE_SCREEN_BUFFER_INFOEX* lpConsoleScreenBufferInfoEx);
BOOL SetConsoleScreenBufferInfoEx([In] HANDLE hConsoleOutput, [In] CONSOLE_SCREEN_BUFFER_INFOEX* lpConsoleScreenBufferInfoEx);
BOOL SetConsoleScreenBufferSize([In] HANDLE hConsoleOutput, [In] COORD dwSize);
BOOL SetConsoleCursorPosition([In] HANDLE hConsoleOutput, [In] COORD dwCursorPosition);
COORD GetLargestConsoleWindowSize([In] HANDLE hConsoleOutput);
BOOL SetConsoleTextAttribute([In] HANDLE hConsoleOutput, [In] CONSOLE_CHARACTER_ATTRIBUTES wAttributes);
BOOL SetConsoleWindowInfo([In] HANDLE hConsoleOutput, [In] BOOL bAbsolute, [Const] [In] SMALL_RECT* lpConsoleWindow);
BOOL WriteConsoleOutputCharacterA([In] HANDLE hConsoleOutput, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] PSTR lpCharacter, [In] uint nLength, [In] COORD dwWriteCoord, [Out] uint* lpNumberOfCharsWritten);
BOOL WriteConsoleOutputCharacterW([In] HANDLE hConsoleOutput, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] PWSTR lpCharacter, [In] uint nLength, [In] COORD dwWriteCoord, [Out] uint* lpNumberOfCharsWritten);
BOOL WriteConsoleOutputAttribute([In] HANDLE hConsoleOutput, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] ushort* lpAttribute, [In] uint nLength, [In] COORD dwWriteCoord, [Out] uint* lpNumberOfAttrsWritten);
BOOL ReadConsoleOutputCharacterA([In] HANDLE hConsoleOutput, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpCharacter, [In] uint nLength, [In] COORD dwReadCoord, [Out] uint* lpNumberOfCharsRead);
BOOL ReadConsoleOutputCharacterW([In] HANDLE hConsoleOutput, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpCharacter, [In] uint nLength, [In] COORD dwReadCoord, [Out] uint* lpNumberOfCharsRead);
BOOL ReadConsoleOutputAttribute([In] HANDLE hConsoleOutput, [NativeArrayInfo(CountParamIndex = 2)] [Out] ushort* lpAttribute, [In] uint nLength, [In] COORD dwReadCoord, [Out] uint* lpNumberOfAttrsRead);
BOOL WriteConsoleInputA([In] HANDLE hConsoleInput, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] INPUT_RECORD* lpBuffer, [In] uint nLength, [Out] uint* lpNumberOfEventsWritten);
BOOL WriteConsoleInputW([In] HANDLE hConsoleInput, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] INPUT_RECORD* lpBuffer, [In] uint nLength, [Out] uint* lpNumberOfEventsWritten);
BOOL ScrollConsoleScreenBufferA([In] HANDLE hConsoleOutput, [Const] [In] SMALL_RECT* lpScrollRectangle, [Const] [In] [Optional] SMALL_RECT* lpClipRectangle, [In] COORD dwDestinationOrigin, [Const] [In] CHAR_INFO* lpFill);
BOOL ScrollConsoleScreenBufferW([In] HANDLE hConsoleOutput, [Const] [In] SMALL_RECT* lpScrollRectangle, [Const] [In] [Optional] SMALL_RECT* lpClipRectangle, [In] COORD dwDestinationOrigin, [Const] [In] CHAR_INFO* lpFill);
BOOL WriteConsoleOutputA([In] HANDLE hConsoleOutput, [Const] [In] CHAR_INFO* lpBuffer, [In] COORD dwBufferSize, [In] COORD dwBufferCoord, [In] [Out] SMALL_RECT* lpWriteRegion);
BOOL WriteConsoleOutputW([In] HANDLE hConsoleOutput, [Const] [In] CHAR_INFO* lpBuffer, [In] COORD dwBufferSize, [In] COORD dwBufferCoord, [In] [Out] SMALL_RECT* lpWriteRegion);
BOOL ReadConsoleOutputA([In] HANDLE hConsoleOutput, [Out] CHAR_INFO* lpBuffer, [In] COORD dwBufferSize, [In] COORD dwBufferCoord, [In] [Out] SMALL_RECT* lpReadRegion);
BOOL ReadConsoleOutputW([In] HANDLE hConsoleOutput, [Out] CHAR_INFO* lpBuffer, [In] COORD dwBufferSize, [In] COORD dwBufferCoord, [In] [Out] SMALL_RECT* lpReadRegion);
uint GetConsoleTitleA([NativeArrayInfo(CountParamIndex = 1)] [Out] PSTR lpConsoleTitle, [In] uint nSize);
uint GetConsoleTitleW([NativeArrayInfo(CountParamIndex = 1)] [Out] PWSTR lpConsoleTitle, [In] uint nSize);
uint GetConsoleOriginalTitleA([NativeArrayInfo(CountParamIndex = 1)] [Out] PSTR lpConsoleTitle, [In] uint nSize);
uint GetConsoleOriginalTitleW([NativeArrayInfo(CountParamIndex = 1)] [Out] PWSTR lpConsoleTitle, [In] uint nSize);
BOOL SetConsoleTitleA([Const] [In] PSTR lpConsoleTitle);
BOOL SetConsoleTitleW([Const] [In] PWSTR lpConsoleTitle);
BOOL GetNumberOfConsoleMouseButtons([Out] uint* lpNumberOfMouseButtons);
COORD GetConsoleFontSize([In] HANDLE hConsoleOutput, [In] uint nFont);
BOOL GetCurrentConsoleFont([In] HANDLE hConsoleOutput, [In] BOOL bMaximumWindow, [Out] CONSOLE_FONT_INFO* lpConsoleCurrentFont);
BOOL GetCurrentConsoleFontEx([In] HANDLE hConsoleOutput, [In] BOOL bMaximumWindow, [Out] CONSOLE_FONT_INFOEX* lpConsoleCurrentFontEx);
BOOL SetCurrentConsoleFontEx([In] HANDLE hConsoleOutput, [In] BOOL bMaximumWindow, [In] CONSOLE_FONT_INFOEX* lpConsoleCurrentFontEx);
BOOL GetConsoleSelectionInfo([Out] CONSOLE_SELECTION_INFO* lpConsoleSelectionInfo);
BOOL GetConsoleHistoryInfo([Out] CONSOLE_HISTORY_INFO* lpConsoleHistoryInfo);
BOOL SetConsoleHistoryInfo([In] CONSOLE_HISTORY_INFO* lpConsoleHistoryInfo);
BOOL GetConsoleDisplayMode([Out] uint* lpModeFlags);
BOOL SetConsoleDisplayMode([In] HANDLE hConsoleOutput, [In] uint dwFlags, [Out] [Optional] COORD* lpNewScreenBufferDimensions);
HWND GetConsoleWindow();
BOOL AddConsoleAliasA([In] PSTR Source, [In] PSTR Target, [In] PSTR ExeName);
BOOL AddConsoleAliasW([In] PWSTR Source, [In] PWSTR Target, [In] PWSTR ExeName);
uint GetConsoleAliasA([In] PSTR Source, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR TargetBuffer, [In] uint TargetBufferLength, [In] PSTR ExeName);
uint GetConsoleAliasW([In] PWSTR Source, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR TargetBuffer, [In] uint TargetBufferLength, [In] PWSTR ExeName);
uint GetConsoleAliasesLengthA([In] PSTR ExeName);
uint GetConsoleAliasesLengthW([In] PWSTR ExeName);
uint GetConsoleAliasExesLengthA();
uint GetConsoleAliasExesLengthW();
uint GetConsoleAliasesA([NativeArrayInfo(CountParamIndex = 1)] [Out] PSTR AliasBuffer, [In] uint AliasBufferLength, [In] PSTR ExeName);
uint GetConsoleAliasesW([NativeArrayInfo(CountParamIndex = 1)] [Out] PWSTR AliasBuffer, [In] uint AliasBufferLength, [In] PWSTR ExeName);
uint GetConsoleAliasExesA([NativeArrayInfo(CountParamIndex = 1)] [Out] PSTR ExeNameBuffer, [In] uint ExeNameBufferLength);
uint GetConsoleAliasExesW([NativeArrayInfo(CountParamIndex = 1)] [Out] PWSTR ExeNameBuffer, [In] uint ExeNameBufferLength);
void ExpungeConsoleCommandHistoryA([In] PSTR ExeName);
void ExpungeConsoleCommandHistoryW([In] PWSTR ExeName);
BOOL SetConsoleNumberOfCommandsA([In] uint Number, [In] PSTR ExeName);
BOOL SetConsoleNumberOfCommandsW([In] uint Number, [In] PWSTR ExeName);
uint GetConsoleCommandHistoryLengthA([In] PSTR ExeName);
uint GetConsoleCommandHistoryLengthW([In] PWSTR ExeName);
uint GetConsoleCommandHistoryA([MemorySize(BytesParamIndex = 1)] [Out] PSTR Commands, [In] uint CommandBufferLength, [In] PSTR ExeName);
uint GetConsoleCommandHistoryW([MemorySize(BytesParamIndex = 1)] [Out] PWSTR Commands, [In] uint CommandBufferLength, [In] PWSTR ExeName);
uint GetConsoleProcessList([NativeArrayInfo(CountParamIndex = 1)] [Out] uint* lpdwProcessList, [In] uint dwProcessCount);
HANDLE GetStdHandle([In] STD_HANDLE nStdHandle);
BOOL SetStdHandle([In] STD_HANDLE nStdHandle, [In] HANDLE hHandle);
BOOL SetStdHandleEx([In] STD_HANDLE nStdHandle, [In] HANDLE hHandle, [Out] [Optional] HANDLE* phPrevValue);
ushort GlobalDeleteAtom([In] ushort nAtom);
BOOL InitAtomTable([In] uint nSize);
ushort DeleteAtom([In] ushort nAtom);
ushort GlobalAddAtomA([Const] [In] [Optional] PSTR lpString);
ushort GlobalAddAtomW([Const] [In] [Optional] PWSTR lpString);
ushort GlobalAddAtomExA([Const] [In] [Optional] PSTR lpString, [In] uint Flags);
ushort GlobalAddAtomExW([Const] [In] [Optional] PWSTR lpString, [In] uint Flags);
ushort GlobalFindAtomA([Const] [In] [Optional] PSTR lpString);
ushort GlobalFindAtomW([Const] [In] [Optional] PWSTR lpString);
uint GlobalGetAtomNameA([In] ushort nAtom, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpBuffer, [In] int nSize);
uint GlobalGetAtomNameW([In] ushort nAtom, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpBuffer, [In] int nSize);
ushort AddAtomA([Const] [In] [Optional] PSTR lpString);
ushort AddAtomW([Const] [In] [Optional] PWSTR lpString);
ushort FindAtomA([Const] [In] [Optional] PSTR lpString);
ushort FindAtomW([Const] [In] [Optional] PWSTR lpString);
uint GetAtomNameA([In] ushort nAtom, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpBuffer, [In] int nSize);
uint GetAtomNameW([In] ushort nAtom, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpBuffer, [In] int nSize);
BOOL CeipIsOptedIn();
BOOLEAN RtlAddFunctionTable([NativeArrayInfo(CountParamIndex = 1)] [In] IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY* FunctionTable, [In] uint EntryCount, [In] nuint BaseAddress);
BOOLEAN RtlDeleteFunctionTable([In] IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY* FunctionTable);
BOOLEAN RtlInstallFunctionTableCallback([In] ulong TableIdentifier, [In] ulong BaseAddress, [In] uint Length, [In] PGET_RUNTIME_FUNCTION_CALLBACK Callback, [In] [Optional] void* Context, [Const] [In] [Optional] PWSTR OutOfProcessCallbackDll);
IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY* RtlLookupFunctionEntry([In] nuint ControlPc, [Out] nuint* ImageBase, [In] [Out] [Optional] UNWIND_HISTORY_TABLE* HistoryTable);
EXCEPTION_ROUTINE RtlVirtualUnwind([In] RTL_VIRTUAL_UNWIND_HANDLER_TYPE HandlerType, [In] nuint ImageBase, [In] nuint ControlPc, [In] IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY* FunctionEntry, [In] [Out] CONTEXT* ContextRecord, [Out] void** HandlerData, [Out] nuint* EstablisherFrame, [In] [Out] [Optional] KNONVOLATILE_CONTEXT_POINTERS_ARM64* ContextPointers);
BOOL ReadProcessMemory([In] HANDLE hProcess, [Const] [In] void* lpBaseAddress, [MemorySize(BytesParamIndex = 3)] [Out] void* lpBuffer, [In] nuint nSize, [Out] [Optional] nuint* lpNumberOfBytesRead);
BOOL WriteProcessMemory([In] HANDLE hProcess, [In] void* lpBaseAddress, [Const] [MemorySize(BytesParamIndex = 3)] [In] void* lpBuffer, [In] nuint nSize, [Out] [Optional] nuint* lpNumberOfBytesWritten);
BOOL GetThreadContext([In] HANDLE hThread, [In] [Out] CONTEXT* lpContext);
BOOL SetThreadContext([In] HANDLE hThread, [Const] [In] CONTEXT* lpContext);
BOOL FlushInstructionCache([In] HANDLE hProcess, [Const] [MemorySize(BytesParamIndex = 2)] [In] [Optional] void* lpBaseAddress, [In] nuint dwSize);
BOOL Wow64GetThreadContext([In] HANDLE hThread, [In] [Out] WOW64_CONTEXT* lpContext);
BOOL Wow64SetThreadContext([In] HANDLE hThread, [Const] [In] WOW64_CONTEXT* lpContext);
void RtlCaptureContext2([In] [Out] CONTEXT* ContextRecord);
BOOLEAN RtlAddFunctionTable([NativeArrayInfo(CountParamIndex = 1)] [In] IMAGE_RUNTIME_FUNCTION_ENTRY* FunctionTable, [In] uint EntryCount, [In] ulong BaseAddress);
BOOLEAN RtlDeleteFunctionTable([In] IMAGE_RUNTIME_FUNCTION_ENTRY* FunctionTable);
BOOLEAN RtlInstallFunctionTableCallback([In] ulong TableIdentifier, [In] ulong BaseAddress, [In] uint Length, [In] PGET_RUNTIME_FUNCTION_CALLBACK Callback, [In] [Optional] void* Context, [Const] [In] [Optional] PWSTR OutOfProcessCallbackDll);
IMAGE_RUNTIME_FUNCTION_ENTRY* RtlLookupFunctionEntry([In] ulong ControlPc, [Out] ulong* ImageBase, [In] [Out] [Optional] UNWIND_HISTORY_TABLE* HistoryTable);
void RtlUnwindEx([In] [Optional] void* TargetFrame, [In] [Optional] void* TargetIp, [In] [Optional] EXCEPTION_RECORD* ExceptionRecord, [In] void* ReturnValue, [In] CONTEXT* ContextRecord, [In] [Optional] UNWIND_HISTORY_TABLE* HistoryTable);
EXCEPTION_ROUTINE RtlVirtualUnwind([In] RTL_VIRTUAL_UNWIND_HANDLER_TYPE HandlerType, [In] ulong ImageBase, [In] ulong ControlPc, [In] IMAGE_RUNTIME_FUNCTION_ENTRY* FunctionEntry, [In] [Out] CONTEXT* ContextRecord, [Out] void** HandlerData, [Out] ulong* EstablisherFrame, [In] [Out] [Optional] KNONVOLATILE_CONTEXT_POINTERS* ContextPointers);
ushort RtlCaptureStackBackTrace([In] uint FramesToSkip, [In] uint FramesToCapture, [NativeArrayInfo(CountParamIndex = 1)] [Out] void** BackTrace, [Out] [Optional] uint* BackTraceHash);
void RtlCaptureContext([Out] CONTEXT* ContextRecord);
void RtlUnwind([In] [Optional] void* TargetFrame, [In] [Optional] void* TargetIp, [In] [Optional] EXCEPTION_RECORD* ExceptionRecord, [In] void* ReturnValue);
void RtlRestoreContext([In] CONTEXT* ContextRecord, [In] [Optional] EXCEPTION_RECORD* ExceptionRecord);
void RtlRaiseException([In] EXCEPTION_RECORD* ExceptionRecord);
void* RtlPcToFileHeader([In] void* PcValue, [Out] void** BaseOfImage);
BOOL IsDebuggerPresent();
void DebugBreak();
void OutputDebugStringA([Const] [In] [Optional] PSTR lpOutputString);
void OutputDebugStringW([Const] [In] [Optional] PWSTR lpOutputString);
BOOL ContinueDebugEvent([In] uint dwProcessId, [In] uint dwThreadId, [In] uint dwContinueStatus);
BOOL WaitForDebugEvent([Out] DEBUG_EVENT* lpDebugEvent, [In] uint dwMilliseconds);
BOOL DebugActiveProcess([In] uint dwProcessId);
BOOL DebugActiveProcessStop([In] uint dwProcessId);
BOOL CheckRemoteDebuggerPresent([In] HANDLE hProcess, [Out] BOOL* pbDebuggerPresent);
BOOL WaitForDebugEventEx([Out] DEBUG_EVENT* lpDebugEvent, [In] uint dwMilliseconds);
void* EncodePointer([In] [Optional] void* Ptr);
void* DecodePointer([In] [Optional] void* Ptr);
void* EncodeSystemPointer([In] [Optional] void* Ptr);
void* DecodeSystemPointer([In] [Optional] void* Ptr);
BOOL Beep([In] uint dwFreq, [In] uint dwDuration);
void RaiseException([In] uint dwExceptionCode, [In] uint dwExceptionFlags, [In] uint nNumberOfArguments, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] [Optional] nuint* lpArguments);
int UnhandledExceptionFilter([In] EXCEPTION_POINTERS* ExceptionInfo);
LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter([In] [Optional] LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
uint GetErrorMode();
uint SetErrorMode([In] THREAD_ERROR_MODE uMode);
void* AddVectoredExceptionHandler([In] uint First, [In] PVECTORED_EXCEPTION_HANDLER Handler);
uint RemoveVectoredExceptionHandler([In] void* Handle);
void* AddVectoredContinueHandler([In] uint First, [In] PVECTORED_EXCEPTION_HANDLER Handler);
uint RemoveVectoredContinueHandler([In] void* Handle);
void RaiseFailFastException([In] [Optional] EXCEPTION_RECORD* pExceptionRecord, [In] [Optional] CONTEXT* pContextRecord, [In] uint dwFlags);
void FatalAppExitA([In] uint uAction, [Const] [In] PSTR lpMessageText);
void FatalAppExitW([In] uint uAction, [Const] [In] PWSTR lpMessageText);
uint GetThreadErrorMode();
BOOL SetThreadErrorMode([In] THREAD_ERROR_MODE dwNewMode, [In] [Optional] THREAD_ERROR_MODE* lpOldMode);
void FatalExit([In] int ExitCode);
BOOL GetThreadSelectorEntry([In] HANDLE hThread, [In] uint dwSelector, [Out] LDT_ENTRY* lpSelectorEntry);
BOOL Wow64GetThreadSelectorEntry([In] HANDLE hThread, [In] uint dwSelector, [Out] WOW64_LDT_ENTRY* lpSelectorEntry);
BOOL DebugSetProcessKillOnExit([In] BOOL KillOnExit);
BOOL DebugBreakProcess([In] HANDLE Process);
uint FormatMessageA([In] FORMAT_MESSAGE_OPTIONS dwFlags, [Const] [In] [Optional] void* lpSource, [In] uint dwMessageId, [In] uint dwLanguageId, [Out] PSTR lpBuffer, [In] uint nSize, [In] [Optional] sbyte** Arguments);
uint FormatMessageW([In] FORMAT_MESSAGE_OPTIONS dwFlags, [Const] [In] [Optional] void* lpSource, [In] uint dwMessageId, [In] uint dwLanguageId, [Out] PWSTR lpBuffer, [In] uint nSize, [In] [Optional] sbyte** Arguments);
BOOL CopyContext([In] [Out] CONTEXT* Destination, [In] uint ContextFlags, [In] CONTEXT* Source);
BOOL InitializeContext([MemorySize(BytesParamIndex = 3)] [Out] [Optional] void* Buffer, [In] uint ContextFlags, [Out] CONTEXT** Context, [In] [Out] uint* ContextLength);
BOOL InitializeContext2([MemorySize(BytesParamIndex = 3)] [Out] [Optional] void* Buffer, [In] uint ContextFlags, [Out] CONTEXT** Context, [In] [Out] uint* ContextLength, [In] ulong XStateCompactionMask);
ulong GetEnabledXStateFeatures();
BOOL GetXStateFeaturesMask([In] CONTEXT* Context, [Out] ulong* FeatureMask);
void* LocateXStateFeature([In] CONTEXT* Context, [In] uint FeatureId, [Out] [Optional] uint* Length);
BOOL SetXStateFeaturesMask([In] [Out] CONTEXT* Context, [In] ulong FeatureMask);
uint PssCaptureSnapshot([In] HANDLE ProcessHandle, [In] PSS_CAPTURE_FLAGS CaptureFlags, [In] [Optional] uint ThreadContextFlags, [Out] HPSS* SnapshotHandle);
uint PssFreeSnapshot([In] HANDLE ProcessHandle, [In] HPSS SnapshotHandle);
uint PssQuerySnapshot([In] HPSS SnapshotHandle, [In] PSS_QUERY_INFORMATION_CLASS InformationClass, [MemorySize(BytesParamIndex = 3)] [Out] void* Buffer, [In] uint BufferLength);
uint PssWalkSnapshot([In] HPSS SnapshotHandle, [In] PSS_WALK_INFORMATION_CLASS InformationClass, [In] HPSSWALK WalkMarkerHandle, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] void* Buffer, [In] uint BufferLength);
uint PssDuplicateSnapshot([In] HANDLE SourceProcessHandle, [In] HPSS SnapshotHandle, [In] HANDLE TargetProcessHandle, [Out] HPSS* TargetSnapshotHandle, [In] [Optional] PSS_DUPLICATE_FLAGS Flags);
uint PssWalkMarkerCreate([Const] [In] [Optional] PSS_ALLOCATOR* Allocator, [Out] HPSSWALK* WalkMarkerHandle);
uint PssWalkMarkerFree([In] HPSSWALK WalkMarkerHandle);
uint PssWalkMarkerGetPosition([In] HPSSWALK WalkMarkerHandle, [Out] nuint* Position);
uint PssWalkMarkerSetPosition([In] HPSSWALK WalkMarkerHandle, [In] nuint Position);
uint PssWalkMarkerSeekToBeginning([In] HPSSWALK WalkMarkerHandle);
HANDLE CreateToolhelp32Snapshot([In] CREATE_TOOLHELP_SNAPSHOT_FLAGS dwFlags, [In] uint th32ProcessID);
BOOL Heap32ListFirst([In] HANDLE hSnapshot, [In] [Out] HEAPLIST32* lphl);
BOOL Heap32ListNext([In] HANDLE hSnapshot, [In] [Out] HEAPLIST32* lphl);
BOOL Heap32First([In] [Out] HEAPENTRY32* lphe, [In] uint th32ProcessID, [In] nuint th32HeapID);
BOOL Heap32Next([In] [Out] HEAPENTRY32* lphe);
BOOL Toolhelp32ReadProcessMemory([In] uint th32ProcessID, [Const] [In] void* lpBaseAddress, [In] [Out] void* lpBuffer, [In] nuint cbRead, [In] [Out] nuint* lpNumberOfBytesRead);
BOOL Process32FirstW([In] HANDLE hSnapshot, [In] [Out] PROCESSENTRY32W* lppe);
BOOL Process32NextW([In] HANDLE hSnapshot, [In] [Out] PROCESSENTRY32W* lppe);
BOOL Process32First([In] HANDLE hSnapshot, [In] [Out] PROCESSENTRY32* lppe);
BOOL Process32Next([In] HANDLE hSnapshot, [In] [Out] PROCESSENTRY32* lppe);
BOOL Thread32First([In] HANDLE hSnapshot, [In] [Out] THREADENTRY32* lpte);
BOOL Thread32Next([In] HANDLE hSnapshot, [In] [Out] THREADENTRY32* lpte);
BOOL Module32FirstW([In] HANDLE hSnapshot, [In] [Out] MODULEENTRY32W* lpme);
BOOL Module32NextW([In] HANDLE hSnapshot, [In] [Out] MODULEENTRY32W* lpme);
BOOL Module32First([In] HANDLE hSnapshot, [In] [Out] MODULEENTRY32* lpme);
BOOL Module32Next([In] HANDLE hSnapshot, [In] [Out] MODULEENTRY32* lpme);
BOOL SetEnvironmentStringsW([NotNullTerminated] [NullNullTerminated] [In] PWSTR NewEnvironment);
PSTR GetCommandLineA();
PWSTR GetCommandLineW();
PSTR GetEnvironmentStrings();
PWSTR GetEnvironmentStringsW();
BOOL FreeEnvironmentStringsA([NotNullTerminated] [NullNullTerminated] [In] PSTR penv);
BOOL FreeEnvironmentStringsW([NotNullTerminated] [NullNullTerminated] [In] PWSTR penv);
uint GetEnvironmentVariableA([Const] [In] [Optional] PSTR lpName, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpBuffer, [In] uint nSize);
uint GetEnvironmentVariableW([Const] [In] [Optional] PWSTR lpName, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpBuffer, [In] uint nSize);
BOOL SetEnvironmentVariableA([Const] [In] PSTR lpName, [Const] [In] [Optional] PSTR lpValue);
BOOL SetEnvironmentVariableW([Const] [In] PWSTR lpName, [Const] [In] [Optional] PWSTR lpValue);
uint ExpandEnvironmentStringsA([Const] [In] PSTR lpSrc, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpDst, [In] uint nSize);
uint ExpandEnvironmentStringsW([Const] [In] PWSTR lpSrc, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpDst, [In] uint nSize);
BOOL SetCurrentDirectoryA([Const] [In] PSTR lpPathName);
BOOL SetCurrentDirectoryW([Const] [In] PWSTR lpPathName);
uint GetCurrentDirectoryA([In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PSTR lpBuffer);
uint GetCurrentDirectoryW([In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PWSTR lpBuffer);
BOOL NeedCurrentDirectoryForExePathA([Const] [In] PSTR ExeName);
BOOL NeedCurrentDirectoryForExePathW([Const] [In] PWSTR ExeName);
BOOL IsEnclaveTypeSupported([In] uint flEnclaveType);
void* CreateEnclave([In] HANDLE hProcess, [In] [Optional] void* lpAddress, [In] nuint dwSize, [In] nuint dwInitialCommitment, [In] uint flEnclaveType, [Const] [MemorySize(BytesParamIndex = 6)] [In] void* lpEnclaveInformation, [In] uint dwInfoLength, [Out] [Optional] uint* lpEnclaveError);
BOOL LoadEnclaveData([In] HANDLE hProcess, [In] void* lpAddress, [Const] [MemorySize(BytesParamIndex = 3)] [In] void* lpBuffer, [In] nuint nSize, [In] uint flProtect, [Const] [MemorySize(BytesParamIndex = 6)] [In] void* lpPageInformation, [In] uint dwInfoLength, [Out] nuint* lpNumberOfBytesWritten, [Out] [Optional] uint* lpEnclaveError);
BOOL InitializeEnclave([In] HANDLE hProcess, [In] void* lpAddress, [Const] [MemorySize(BytesParamIndex = 3)] [In] void* lpEnclaveInformation, [In] uint dwInfoLength, [Out] [Optional] uint* lpEnclaveError);
HRESULT WerRegisterFile([Const] [In] PWSTR pwzFile, [In] WER_REGISTER_FILE_TYPE regFileType, [In] WER_FILE dwFlags);
HRESULT WerUnregisterFile([Const] [In] PWSTR pwzFilePath);
HRESULT WerRegisterMemoryBlock([In] void* pvAddress, [In] uint dwSize);
HRESULT WerUnregisterMemoryBlock([In] void* pvAddress);
HRESULT WerRegisterExcludedMemoryBlock([Const] [In] void* address, [In] uint size);
HRESULT WerUnregisterExcludedMemoryBlock([Const] [In] void* address);
HRESULT WerRegisterCustomMetadata([Const] [In] PWSTR key, [Const] [In] PWSTR value);
HRESULT WerUnregisterCustomMetadata([Const] [In] PWSTR key);
HRESULT WerRegisterAdditionalProcess([In] uint processId, [In] uint captureExtraInfoForThreadId);
HRESULT WerUnregisterAdditionalProcess([In] uint processId);
HRESULT WerRegisterAppLocalDump([Const] [In] PWSTR localAppDataRelativePath);
HRESULT WerUnregisterAppLocalDump();
HRESULT WerSetFlags([In] WER_FAULT_REPORTING dwFlags);
HRESULT WerGetFlags([In] HANDLE hProcess, [Out] WER_FAULT_REPORTING* pdwFlags);
HRESULT WerRegisterRuntimeExceptionModule([Const] [In] PWSTR pwszOutOfProcessCallbackDll, [In] void* pContext);
HRESULT WerUnregisterRuntimeExceptionModule([Const] [In] PWSTR pwszOutOfProcessCallbackDll, [In] void* pContext);
BOOL QueryPerformanceCounter([Out] LARGE_INTEGER* lpPerformanceCount);
BOOL QueryPerformanceFrequency([Out] LARGE_INTEGER* lpFrequency);
uint EnableThreadProfiling([In] HANDLE ThreadHandle, [In] uint Flags, [In] ulong HardwareCounters, [Out] HANDLE* PerformanceDataHandle);
uint DisableThreadProfiling([In] HANDLE PerformanceDataHandle);
uint QueryThreadProfiling([In] HANDLE ThreadHandle, [Out] BOOLEAN* Enabled);
uint ReadThreadProfilingData([In] HANDLE PerformanceDataHandle, [In] uint Flags, [Out] PERFORMANCE_DATA* PerformanceData);
BOOL CreatePipe([Out] HANDLE* hReadPipe, [Out] HANDLE* hWritePipe, [In] [Optional] SECURITY_ATTRIBUTES* lpPipeAttributes, [In] uint nSize);
BOOL ConnectNamedPipe([In] HANDLE hNamedPipe, [In] [Out] [Optional] OVERLAPPED* lpOverlapped);
BOOL DisconnectNamedPipe([In] HANDLE hNamedPipe);
BOOL SetNamedPipeHandleState([In] HANDLE hNamedPipe, [In] [Optional] NAMED_PIPE_MODE* lpMode, [In] [Optional] uint* lpMaxCollectionCount, [In] [Optional] uint* lpCollectDataTimeout);
BOOL PeekNamedPipe([In] HANDLE hNamedPipe, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] void* lpBuffer, [In] uint nBufferSize, [Out] [Optional] uint* lpBytesRead, [Out] [Optional] uint* lpTotalBytesAvail, [Out] [Optional] uint* lpBytesLeftThisMessage);
BOOL TransactNamedPipe([In] HANDLE hNamedPipe, [MemorySize(BytesParamIndex = 2)] [In] [Optional] void* lpInBuffer, [In] uint nInBufferSize, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] void* lpOutBuffer, [In] uint nOutBufferSize, [Out] uint* lpBytesRead, [In] [Out] [Optional] OVERLAPPED* lpOverlapped);
HANDLE CreateNamedPipeW([Const] [In] PWSTR lpName, [In] FILE_FLAGS_AND_ATTRIBUTES dwOpenMode, [In] NAMED_PIPE_MODE dwPipeMode, [In] uint nMaxInstances, [In] uint nOutBufferSize, [In] uint nInBufferSize, [In] uint nDefaultTimeOut, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes);
BOOL WaitNamedPipeW([Const] [In] PWSTR lpNamedPipeName, [In] uint nTimeOut);
BOOL GetNamedPipeClientComputerNameW([In] HANDLE Pipe, [MemorySize(BytesParamIndex = 2)] [Out] PWSTR ClientComputerName, [In] uint ClientComputerNameLength);
BOOL GetNamedPipeInfo([In] HANDLE hNamedPipe, [Out] [Optional] NAMED_PIPE_MODE* lpFlags, [Out] [Optional] uint* lpOutBufferSize, [Out] [Optional] uint* lpInBufferSize, [Out] [Optional] uint* lpMaxInstances);
BOOL GetNamedPipeHandleStateW([In] HANDLE hNamedPipe, [Out] [Optional] NAMED_PIPE_MODE* lpState, [Out] [Optional] uint* lpCurInstances, [Out] [Optional] uint* lpMaxCollectionCount, [Out] [Optional] uint* lpCollectDataTimeout, [NativeArrayInfo(CountParamIndex = 6)] [Out] [Optional] PWSTR lpUserName, [In] uint nMaxUserNameSize);
BOOL CallNamedPipeW([Const] [In] PWSTR lpNamedPipeName, [MemorySize(BytesParamIndex = 2)] [In] [Optional] void* lpInBuffer, [In] uint nInBufferSize, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] void* lpOutBuffer, [In] uint nOutBufferSize, [Out] uint* lpBytesRead, [In] uint nTimeOut);
HANDLE CreateNamedPipeA([Const] [In] PSTR lpName, [In] FILE_FLAGS_AND_ATTRIBUTES dwOpenMode, [In] NAMED_PIPE_MODE dwPipeMode, [In] uint nMaxInstances, [In] uint nOutBufferSize, [In] uint nInBufferSize, [In] uint nDefaultTimeOut, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes);
BOOL GetNamedPipeHandleStateA([In] HANDLE hNamedPipe, [Out] [Optional] NAMED_PIPE_MODE* lpState, [Out] [Optional] uint* lpCurInstances, [Out] [Optional] uint* lpMaxCollectionCount, [Out] [Optional] uint* lpCollectDataTimeout, [NativeArrayInfo(CountParamIndex = 6)] [Out] [Optional] PSTR lpUserName, [In] uint nMaxUserNameSize);
BOOL CallNamedPipeA([Const] [In] PSTR lpNamedPipeName, [MemorySize(BytesParamIndex = 2)] [In] [Optional] void* lpInBuffer, [In] uint nInBufferSize, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] void* lpOutBuffer, [In] uint nOutBufferSize, [Out] uint* lpBytesRead, [In] uint nTimeOut);
BOOL WaitNamedPipeA([Const] [In] PSTR lpNamedPipeName, [In] uint nTimeOut);
BOOL GetNamedPipeClientComputerNameA([In] HANDLE Pipe, [MemorySize(BytesParamIndex = 2)] [Out] PSTR ClientComputerName, [In] uint ClientComputerNameLength);
BOOL GetNamedPipeClientProcessId([In] HANDLE Pipe, [Out] uint* ClientProcessId);
BOOL GetNamedPipeClientSessionId([In] HANDLE Pipe, [Out] uint* ClientSessionId);
BOOL GetNamedPipeServerProcessId([In] HANDLE Pipe, [Out] uint* ServerProcessId);
BOOL GetNamedPipeServerSessionId([In] HANDLE Pipe, [Out] uint* ServerSessionId);
BOOL RequestWakeupLatency([In] LATENCY_TIME latency);
BOOL IsSystemResumeAutomatic();
EXECUTION_STATE SetThreadExecutionState([In] EXECUTION_STATE esFlags);
HANDLE PowerCreateRequest([In] REASON_CONTEXT* Context);
BOOL PowerSetRequest([In] HANDLE PowerRequest, [In] POWER_REQUEST_TYPE RequestType);
BOOL PowerClearRequest([In] HANDLE PowerRequest, [In] POWER_REQUEST_TYPE RequestType);
BOOL GetDevicePowerState([In] HANDLE hDevice, [Out] BOOL* pfOn);
BOOL SetSystemPowerState([In] BOOL fSuspend, [In] BOOL fForce);
BOOL GetSystemPowerStatus([Out] SYSTEM_POWER_STATUS* lpSystemPowerStatus);
BOOL K32EnumProcesses([MemorySize(BytesParamIndex = 1)] [Out] uint* lpidProcess, [In] uint cb, [Out] uint* lpcbNeeded);
BOOL K32EnumProcessModules([In] HANDLE hProcess, [MemorySize(BytesParamIndex = 2)] [Out] HINSTANCE* lphModule, [In] uint cb, [Out] uint* lpcbNeeded);
BOOL K32EnumProcessModulesEx([In] HANDLE hProcess, [MemorySize(BytesParamIndex = 2)] [Out] HINSTANCE* lphModule, [In] uint cb, [Out] uint* lpcbNeeded, [In] ENUM_PROCESS_MODULES_EX_FLAGS dwFilterFlag);
uint K32GetModuleBaseNameA([In] HANDLE hProcess, [In] [Optional] HINSTANCE hModule, [NativeArrayInfo(CountParamIndex = 3)] [Out] PSTR lpBaseName, [In] uint nSize);
uint K32GetModuleBaseNameW([In] HANDLE hProcess, [In] [Optional] HINSTANCE hModule, [NativeArrayInfo(CountParamIndex = 3)] [Out] PWSTR lpBaseName, [In] uint nSize);
uint K32GetModuleFileNameExA([In] [Optional] HANDLE hProcess, [In] [Optional] HINSTANCE hModule, [NativeArrayInfo(CountParamIndex = 3)] [Out] PSTR lpFilename, [In] uint nSize);
uint K32GetModuleFileNameExW([In] [Optional] HANDLE hProcess, [In] [Optional] HINSTANCE hModule, [NativeArrayInfo(CountParamIndex = 3)] [Out] PWSTR lpFilename, [In] uint nSize);
BOOL K32GetModuleInformation([In] HANDLE hProcess, [In] HINSTANCE hModule, [Out] MODULEINFO* lpmodinfo, [In] uint cb);
BOOL K32EmptyWorkingSet([In] HANDLE hProcess);
BOOL K32InitializeProcessForWsWatch([In] HANDLE hProcess);
BOOL K32GetWsChanges([In] HANDLE hProcess, [MemorySize(BytesParamIndex = 2)] [Out] PSAPI_WS_WATCH_INFORMATION* lpWatchInfo, [In] uint cb);
BOOL K32GetWsChangesEx([In] HANDLE hProcess, [MemorySize(BytesParamIndex = 2)] [Out] PSAPI_WS_WATCH_INFORMATION_EX* lpWatchInfoEx, [In] [Out] uint* cb);
uint K32GetMappedFileNameW([In] HANDLE hProcess, [In] void* lpv, [NativeArrayInfo(CountParamIndex = 3)] [Out] PWSTR lpFilename, [In] uint nSize);
uint K32GetMappedFileNameA([In] HANDLE hProcess, [In] void* lpv, [NativeArrayInfo(CountParamIndex = 3)] [Out] PSTR lpFilename, [In] uint nSize);
BOOL K32EnumDeviceDrivers([MemorySize(BytesParamIndex = 1)] [Out] void** lpImageBase, [In] uint cb, [Out] uint* lpcbNeeded);
uint K32GetDeviceDriverBaseNameA([In] void* ImageBase, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpFilename, [In] uint nSize);
uint K32GetDeviceDriverBaseNameW([In] void* ImageBase, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpBaseName, [In] uint nSize);
uint K32GetDeviceDriverFileNameA([In] void* ImageBase, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpFilename, [In] uint nSize);
uint K32GetDeviceDriverFileNameW([In] void* ImageBase, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpFilename, [In] uint nSize);
BOOL K32QueryWorkingSet([In] HANDLE hProcess, [MemorySize(BytesParamIndex = 2)] [Out] void* pv, [In] uint cb);
BOOL K32QueryWorkingSetEx([In] HANDLE hProcess, [MemorySize(BytesParamIndex = 2)] [Out] void* pv, [In] uint cb);
BOOL K32GetProcessMemoryInfo([In] HANDLE Process, [In] [Out] PROCESS_MEMORY_COUNTERS* ppsmemCounters, [In] uint cb);
BOOL K32GetPerformanceInfo([In] [Out] PERFORMANCE_INFORMATION* pPerformanceInformation, [In] uint cb);
BOOL K32EnumPageFilesW([In] PENUM_PAGE_FILE_CALLBACKW pCallBackRoutine, [In] [Out] void* pContext);
BOOL K32EnumPageFilesA([In] PENUM_PAGE_FILE_CALLBACKA pCallBackRoutine, [In] [Out] void* pContext);
uint K32GetProcessImageFileNameA([In] HANDLE hProcess, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpImageFileName, [In] uint nSize);
uint K32GetProcessImageFileNameW([In] HANDLE hProcess, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpImageFileName, [In] uint nSize);
HRESULT RegisterApplicationRecoveryCallback([In] APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, [In] [Optional] void* pvParameter, [In] uint dwPingInterval, [In] uint dwFlags);
HRESULT UnregisterApplicationRecoveryCallback();
HRESULT RegisterApplicationRestart([Const] [In] [Optional] PWSTR pwzCommandline, [In] REGISTER_APPLICATION_RESTART_FLAGS dwFlags);
HRESULT UnregisterApplicationRestart();
HRESULT GetApplicationRecoveryCallback([In] HANDLE hProcess, [Out] APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback, [Out] [Optional] void** ppvParameter, [Out] [Optional] uint* pdwPingInterval, [Out] [Optional] uint* pdwFlags);
HRESULT GetApplicationRestartSettings([In] HANDLE hProcess, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR pwzCommandline, [In] [Out] uint* pcchSize, [Out] [Optional] uint* pdwFlags);
HRESULT ApplicationRecoveryInProgress([Out] BOOL* pbCancelled);
void ApplicationRecoveryFinished([In] BOOL bSuccess);
BOOL ProcessIdToSessionId([In] uint dwProcessId, [Out] uint* pSessionId);
uint WTSGetActiveConsoleSessionId();
HANDLE CreateIoCompletionPort([In] HANDLE FileHandle, [In] [Optional] HANDLE ExistingCompletionPort, [In] nuint CompletionKey, [In] uint NumberOfConcurrentThreads);
BOOL GetQueuedCompletionStatus([In] HANDLE CompletionPort, [Out] uint* lpNumberOfBytesTransferred, [Out] nuint* lpCompletionKey, [Out] OVERLAPPED** lpOverlapped, [In] uint dwMilliseconds);
BOOL GetQueuedCompletionStatusEx([In] HANDLE CompletionPort, [NativeArrayInfo(CountParamIndex = 2)] [Out] OVERLAPPED_ENTRY* lpCompletionPortEntries, [In] uint ulCount, [Out] uint* ulNumEntriesRemoved, [In] uint dwMilliseconds, [In] BOOL fAlertable);
BOOL PostQueuedCompletionStatus([In] HANDLE CompletionPort, [In] uint dwNumberOfBytesTransferred, [In] nuint dwCompletionKey, [In] [Optional] OVERLAPPED* lpOverlapped);
BOOL DeviceIoControl([In] HANDLE hDevice, [In] uint dwIoControlCode, [MemorySize(BytesParamIndex = 3)] [In] [Optional] void* lpInBuffer, [In] uint nInBufferSize, [MemorySize(BytesParamIndex = 5)] [Out] [Optional] void* lpOutBuffer, [In] uint nOutBufferSize, [Out] [Optional] uint* lpBytesReturned, [In] [Out] [Optional] OVERLAPPED* lpOverlapped);
BOOL GetOverlappedResult([In] HANDLE hFile, [In] OVERLAPPED* lpOverlapped, [Out] uint* lpNumberOfBytesTransferred, [In] BOOL bWait);
BOOL CancelIoEx([In] HANDLE hFile, [In] [Optional] OVERLAPPED* lpOverlapped);
BOOL CancelIo([In] HANDLE hFile);
BOOL GetOverlappedResultEx([In] HANDLE hFile, [In] OVERLAPPED* lpOverlapped, [Out] uint* lpNumberOfBytesTransferred, [In] uint dwMilliseconds, [In] BOOL bAlertable);
BOOL CancelSynchronousIo([In] HANDLE hThread);
BOOL BindIoCompletionCallback([In] HANDLE FileHandle, [In] LPOVERLAPPED_COMPLETION_ROUTINE Function, [In] uint Flags);
BOOL IsProcessInJob([In] HANDLE ProcessHandle, [In] [Optional] HANDLE JobHandle, [Out] BOOL* Result);
HANDLE CreateJobObjectW([In] [Optional] SECURITY_ATTRIBUTES* lpJobAttributes, [Const] [In] [Optional] PWSTR lpName);
void FreeMemoryJobObject([In] void* Buffer);
HANDLE OpenJobObjectW([In] uint dwDesiredAccess, [In] BOOL bInheritHandle, [Const] [In] PWSTR lpName);
BOOL AssignProcessToJobObject([In] HANDLE hJob, [In] HANDLE hProcess);
BOOL TerminateJobObject([In] HANDLE hJob, [In] uint uExitCode);
BOOL SetInformationJobObject([In] HANDLE hJob, [In] JOBOBJECTINFOCLASS JobObjectInformationClass, [MemorySize(BytesParamIndex = 3)] [In] void* lpJobObjectInformation, [In] uint cbJobObjectInformationLength);
uint SetIoRateControlInformationJobObject([In] HANDLE hJob, [In] JOBOBJECT_IO_RATE_CONTROL_INFORMATION* IoRateControlInfo);
BOOL QueryInformationJobObject([In] [Optional] HANDLE hJob, [In] JOBOBJECTINFOCLASS JobObjectInformationClass, [MemorySize(BytesParamIndex = 3)] [Out] void* lpJobObjectInformation, [In] uint cbJobObjectInformationLength, [Out] [Optional] uint* lpReturnLength);
uint QueryIoRateControlInformationJobObject([In] [Optional] HANDLE hJob, [Const] [In] [Optional] PWSTR VolumeName, [Out] JOBOBJECT_IO_RATE_CONTROL_INFORMATION** InfoBlocks, [Out] uint* InfoBlockCount);
HANDLE CreateJobObjectA([In] [Optional] SECURITY_ATTRIBUTES* lpJobAttributes, [Const] [In] [Optional] PSTR lpName);
HANDLE OpenJobObjectA([In] uint dwDesiredAccess, [In] BOOL bInheritHandle, [Const] [In] PSTR lpName);
BOOL CreateJobSet([In] uint NumJob, [NativeArrayInfo(CountParamIndex = 0)] [In] JOB_SET_ARRAY* UserJobSet, [In] uint Flags);
BOOL DisableThreadLibraryCalls([In] HINSTANCE hLibModule);
HRSRC FindResourceExW([In] [Optional] HINSTANCE hModule, [Const] [In] PWSTR lpType, [Const] [In] PWSTR lpName, [In] ushort wLanguage);
BOOL FreeLibrary([In] HINSTANCE hLibModule);
void FreeLibraryAndExitThread([In] HINSTANCE hLibModule, [In] uint dwExitCode);
BOOL FreeResource([In] nint hResData);
uint GetModuleFileNameA([In] [Optional] HINSTANCE hModule, [NativeArrayInfo(CountParamIndex = 2)] [Out] PSTR lpFilename, [In] uint nSize);
uint GetModuleFileNameW([In] [Optional] HINSTANCE hModule, [NativeArrayInfo(CountParamIndex = 2)] [Out] PWSTR lpFilename, [In] uint nSize);
HINSTANCE GetModuleHandleA([Const] [In] [Optional] PSTR lpModuleName);
HINSTANCE GetModuleHandleW([Const] [In] [Optional] PWSTR lpModuleName);
BOOL GetModuleHandleExA([In] uint dwFlags, [Const] [In] [Optional] PSTR lpModuleName, [Out] HINSTANCE* phModule);
BOOL GetModuleHandleExW([In] uint dwFlags, [Const] [In] [Optional] PWSTR lpModuleName, [Out] HINSTANCE* phModule);
FARPROC GetProcAddress([In] HINSTANCE hModule, [Const] [In] PSTR lpProcName);
HINSTANCE LoadLibraryExA([Const] [In] PSTR lpLibFileName, [Reserved] [In] HANDLE hFile, [In] LOAD_LIBRARY_FLAGS dwFlags);
HINSTANCE LoadLibraryExW([Const] [In] PWSTR lpLibFileName, [Reserved] [In] HANDLE hFile, [In] LOAD_LIBRARY_FLAGS dwFlags);
nint LoadResource([In] [Optional] HINSTANCE hModule, [In] HRSRC hResInfo);
void* LockResource([In] nint hResData);
uint SizeofResource([In] [Optional] HINSTANCE hModule, [In] HRSRC hResInfo);
void* AddDllDirectory([Const] [In] PWSTR NewDirectory);
BOOL RemoveDllDirectory([In] void* Cookie);
BOOL SetDefaultDllDirectories([In] LOAD_LIBRARY_FLAGS DirectoryFlags);
BOOL EnumResourceLanguagesExA([In] [Optional] HINSTANCE hModule, [Const] [In] PSTR lpType, [Const] [In] PSTR lpName, [In] ENUMRESLANGPROCA lpEnumFunc, [In] [Optional] nint lParam, [In] uint dwFlags, [In] ushort LangId);
BOOL EnumResourceLanguagesExW([In] [Optional] HINSTANCE hModule, [Const] [In] PWSTR lpType, [Const] [In] PWSTR lpName, [In] ENUMRESLANGPROCW lpEnumFunc, [In] [Optional] nint lParam, [In] uint dwFlags, [In] ushort LangId);
BOOL EnumResourceNamesExA([In] [Optional] HINSTANCE hModule, [Const] [In] PSTR lpType, [In] ENUMRESNAMEPROCA lpEnumFunc, [In] nint lParam, [In] uint dwFlags, [In] ushort LangId);
BOOL EnumResourceNamesExW([In] [Optional] HINSTANCE hModule, [Const] [In] PWSTR lpType, [In] ENUMRESNAMEPROCW lpEnumFunc, [In] nint lParam, [In] uint dwFlags, [In] ushort LangId);
BOOL EnumResourceTypesExA([In] [Optional] HINSTANCE hModule, [In] ENUMRESTYPEPROCA lpEnumFunc, [In] nint lParam, [In] uint dwFlags, [In] ushort LangId);
BOOL EnumResourceTypesExW([In] [Optional] HINSTANCE hModule, [In] ENUMRESTYPEPROCW lpEnumFunc, [In] nint lParam, [In] uint dwFlags, [In] ushort LangId);
HRSRC FindResourceW([In] [Optional] HINSTANCE hModule, [Const] [In] PWSTR lpName, [Const] [In] PWSTR lpType);
HINSTANCE LoadLibraryA([Const] [In] PSTR lpLibFileName);
HINSTANCE LoadLibraryW([Const] [In] PWSTR lpLibFileName);
BOOL EnumResourceNamesW([In] [Optional] HINSTANCE hModule, [Const] [In] PWSTR lpType, [In] ENUMRESNAMEPROCW lpEnumFunc, [In] nint lParam);
BOOL EnumResourceNamesA([In] [Optional] HINSTANCE hModule, [Const] [In] PSTR lpType, [In] ENUMRESNAMEPROCA lpEnumFunc, [In] nint lParam);
uint LoadModule([Const] [In] PSTR lpModuleName, [In] void* lpParameterBlock);
HINSTANCE LoadPackagedLibrary([Const] [In] PWSTR lpwLibFileName, [Reserved] [In] uint Reserved);
HRSRC FindResourceA([In] [Optional] HINSTANCE hModule, [Const] [In] PSTR lpName, [Const] [In] PSTR lpType);
HRSRC FindResourceExA([In] [Optional] HINSTANCE hModule, [Const] [In] PSTR lpType, [Const] [In] PSTR lpName, [In] ushort wLanguage);
BOOL EnumResourceTypesA([In] [Optional] HINSTANCE hModule, [In] ENUMRESTYPEPROCA lpEnumFunc, [In] nint lParam);
BOOL EnumResourceTypesW([In] [Optional] HINSTANCE hModule, [In] ENUMRESTYPEPROCW lpEnumFunc, [In] nint lParam);
BOOL EnumResourceLanguagesA([In] [Optional] HINSTANCE hModule, [Const] [In] PSTR lpType, [Const] [In] PSTR lpName, [In] ENUMRESLANGPROCA lpEnumFunc, [In] nint lParam);
BOOL EnumResourceLanguagesW([In] [Optional] HINSTANCE hModule, [Const] [In] PWSTR lpType, [Const] [In] PWSTR lpName, [In] ENUMRESLANGPROCW lpEnumFunc, [In] nint lParam);
HANDLE BeginUpdateResourceA([Const] [In] PSTR pFileName, [In] BOOL bDeleteExistingResources);
HANDLE BeginUpdateResourceW([Const] [In] PWSTR pFileName, [In] BOOL bDeleteExistingResources);
BOOL UpdateResourceA([In] HANDLE hUpdate, [Const] [In] PSTR lpType, [Const] [In] PSTR lpName, [In] ushort wLanguage, [MemorySize(BytesParamIndex = 5)] [In] [Optional] void* lpData, [In] uint cb);
BOOL UpdateResourceW([In] HANDLE hUpdate, [Const] [In] PWSTR lpType, [Const] [In] PWSTR lpName, [In] ushort wLanguage, [MemorySize(BytesParamIndex = 5)] [In] [Optional] void* lpData, [In] uint cb);
BOOL EndUpdateResourceA([In] HANDLE hUpdate, [In] BOOL fDiscard);
BOOL EndUpdateResourceW([In] HANDLE hUpdate, [In] BOOL fDiscard);
BOOL SetDllDirectoryA([Const] [In] [Optional] PSTR lpPathName);
BOOL SetDllDirectoryW([Const] [In] [Optional] PWSTR lpPathName);
uint GetDllDirectoryA([In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PSTR lpBuffer);
uint GetDllDirectoryW([In] uint nBufferLength, [NativeArrayInfo(CountParamIndex = 0)] [Out] [Optional] PWSTR lpBuffer);
HANDLE CreateMailslotA([Const] [In] PSTR lpName, [In] uint nMaxMessageSize, [In] uint lReadTimeout, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes);
HANDLE CreateMailslotW([Const] [In] PWSTR lpName, [In] uint nMaxMessageSize, [In] uint lReadTimeout, [In] [Optional] SECURITY_ATTRIBUTES* lpSecurityAttributes);
BOOL GetMailslotInfo([In] HANDLE hMailslot, [Out] [Optional] uint* lpMaxMessageSize, [Out] [Optional] uint* lpNextSize, [Out] [Optional] uint* lpMessageCount, [Out] [Optional] uint* lpReadTimeout);
BOOL SetMailslotInfo([In] HANDLE hMailslot, [In] uint lReadTimeout);
HeapHandle HeapCreate([In] HEAP_FLAGS flOptions, [In] nuint dwInitialSize, [In] nuint dwMaximumSize);
BOOL HeapDestroy([In] HeapHandle hHeap);
void* HeapAlloc([In] HeapHandle hHeap, [In] HEAP_FLAGS dwFlags, [In] nuint dwBytes);
void* HeapReAlloc([In] HeapHandle hHeap, [In] HEAP_FLAGS dwFlags, [Optional] void* lpMem, [In] nuint dwBytes);
BOOL HeapFree([In] HeapHandle hHeap, [In] HEAP_FLAGS dwFlags, [Optional] void* lpMem);
nuint HeapSize([In] HeapHandle hHeap, [In] HEAP_FLAGS dwFlags, [Const] [In] void* lpMem);
HeapHandle GetProcessHeap();
nuint HeapCompact([In] HeapHandle hHeap, [In] HEAP_FLAGS dwFlags);
BOOL HeapSetInformation([In] [Optional] HeapHandle HeapHandle, [In] HEAP_INFORMATION_CLASS HeapInformationClass, [MemorySize(BytesParamIndex = 3)] [In] [Optional] void* HeapInformation, [In] nuint HeapInformationLength);
BOOL HeapValidate([In] HeapHandle hHeap, [In] HEAP_FLAGS dwFlags, [Const] [In] [Optional] void* lpMem);
BOOL HeapSummary([In] HANDLE hHeap, [In] uint dwFlags, [Out] HEAP_SUMMARY* lpSummary);
uint GetProcessHeaps([In] uint NumberOfHeaps, [NativeArrayInfo(CountParamIndex = 0)] [DoNotRelease] [Out] HeapHandle* ProcessHeaps);
BOOL HeapLock([In] HeapHandle hHeap);
BOOL HeapUnlock([In] HeapHandle hHeap);
BOOL HeapWalk([In] HeapHandle hHeap, [In] [Out] PROCESS_HEAP_ENTRY* lpEntry);
BOOL HeapQueryInformation([In] [Optional] HeapHandle HeapHandle, [In] HEAP_INFORMATION_CLASS HeapInformationClass, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] void* HeapInformation, [In] nuint HeapInformationLength, [Out] [Optional] nuint* ReturnLength);
void* VirtualAlloc([In] [Optional] void* lpAddress, [In] nuint dwSize, [In] VIRTUAL_ALLOCATION_TYPE flAllocationType, [In] PAGE_PROTECTION_FLAGS flProtect);
BOOL VirtualProtect([In] void* lpAddress, [In] nuint dwSize, [In] PAGE_PROTECTION_FLAGS flNewProtect, [Out] PAGE_PROTECTION_FLAGS* lpflOldProtect);
BOOL VirtualFree([In] [Out] void* lpAddress, [In] nuint dwSize, [In] VIRTUAL_FREE_TYPE dwFreeType);
nuint VirtualQuery([Const] [In] [Optional] void* lpAddress, [MemorySize(BytesParamIndex = 2)] [Out] MEMORY_BASIC_INFORMATION* lpBuffer, [In] nuint dwLength);
void* VirtualAllocEx([In] HANDLE hProcess, [In] [Optional] void* lpAddress, [In] nuint dwSize, [In] VIRTUAL_ALLOCATION_TYPE flAllocationType, [In] PAGE_PROTECTION_FLAGS flProtect);
BOOL VirtualProtectEx([In] HANDLE hProcess, [In] void* lpAddress, [In] nuint dwSize, [In] PAGE_PROTECTION_FLAGS flNewProtect, [Out] PAGE_PROTECTION_FLAGS* lpflOldProtect);
nuint VirtualQueryEx([In] HANDLE hProcess, [Const] [In] [Optional] void* lpAddress, [MemorySize(BytesParamIndex = 3)] [Out] MEMORY_BASIC_INFORMATION* lpBuffer, [In] nuint dwLength);
HANDLE CreateFileMappingW([In] HANDLE hFile, [In] [Optional] SECURITY_ATTRIBUTES* lpFileMappingAttributes, [In] PAGE_PROTECTION_FLAGS flProtect, [In] uint dwMaximumSizeHigh, [In] uint dwMaximumSizeLow, [Const] [In] [Optional] PWSTR lpName);
HANDLE OpenFileMappingW([In] uint dwDesiredAccess, [In] BOOL bInheritHandle, [Const] [In] PWSTR lpName);
void* MapViewOfFile([In] HANDLE hFileMappingObject, [In] FILE_MAP dwDesiredAccess, [In] uint dwFileOffsetHigh, [In] uint dwFileOffsetLow, [In] nuint dwNumberOfBytesToMap);
void* MapViewOfFileEx([In] HANDLE hFileMappingObject, [In] FILE_MAP dwDesiredAccess, [In] uint dwFileOffsetHigh, [In] uint dwFileOffsetLow, [In] nuint dwNumberOfBytesToMap, [In] [Optional] void* lpBaseAddress);
BOOL VirtualFreeEx([In] HANDLE hProcess, [In] [Out] void* lpAddress, [In] nuint dwSize, [In] VIRTUAL_FREE_TYPE dwFreeType);
BOOL FlushViewOfFile([Const] [In] void* lpBaseAddress, [In] nuint dwNumberOfBytesToFlush);
BOOL UnmapViewOfFile([Const] [In] void* lpBaseAddress);
nuint GetLargePageMinimum();
BOOL GetProcessWorkingSetSizeEx([In] HANDLE hProcess, [Out] nuint* lpMinimumWorkingSetSize, [Out] nuint* lpMaximumWorkingSetSize, [Out] uint* Flags);
BOOL SetProcessWorkingSetSizeEx([In] HANDLE hProcess, [In] nuint dwMinimumWorkingSetSize, [In] nuint dwMaximumWorkingSetSize, [In] uint Flags);
BOOL VirtualLock([In] void* lpAddress, [In] nuint dwSize);
BOOL VirtualUnlock([In] void* lpAddress, [In] nuint dwSize);
uint GetWriteWatch([In] uint dwFlags, [In] void* lpBaseAddress, [In] nuint dwRegionSize, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] void** lpAddresses, [In] [Out] [Optional] nuint* lpdwCount, [Out] [Optional] uint* lpdwGranularity);
uint ResetWriteWatch([In] void* lpBaseAddress, [In] nuint dwRegionSize);
HANDLE CreateMemoryResourceNotification([In] MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType);
BOOL QueryMemoryResourceNotification([In] HANDLE ResourceNotificationHandle, [Out] BOOL* ResourceState);
BOOL GetSystemFileCacheSize([Out] nuint* lpMinimumFileCacheSize, [Out] nuint* lpMaximumFileCacheSize, [Out] uint* lpFlags);
BOOL SetSystemFileCacheSize([In] nuint MinimumFileCacheSize, [In] nuint MaximumFileCacheSize, [In] uint Flags);
HANDLE CreateFileMappingNumaW([In] HANDLE hFile, [In] [Optional] SECURITY_ATTRIBUTES* lpFileMappingAttributes, [In] PAGE_PROTECTION_FLAGS flProtect, [In] uint dwMaximumSizeHigh, [In] uint dwMaximumSizeLow, [Const] [In] [Optional] PWSTR lpName, [In] uint nndPreferred);
BOOL PrefetchVirtualMemory([In] HANDLE hProcess, [In] nuint NumberOfEntries, [NativeArrayInfo(CountParamIndex = 1)] [In] WIN32_MEMORY_RANGE_ENTRY* VirtualAddresses, [In] uint Flags);
HANDLE CreateFileMappingFromApp([In] HANDLE hFile, [In] [Optional] SECURITY_ATTRIBUTES* SecurityAttributes, [In] PAGE_PROTECTION_FLAGS PageProtection, [In] ulong MaximumSize, [Const] [In] [Optional] PWSTR Name);
void* MapViewOfFileFromApp([In] HANDLE hFileMappingObject, [In] FILE_MAP DesiredAccess, [In] ulong FileOffset, [In] nuint NumberOfBytesToMap);
BOOL UnmapViewOfFileEx([In] void* BaseAddress, [In] UNMAP_VIEW_OF_FILE_FLAGS UnmapFlags);
BOOL AllocateUserPhysicalPages([In] HANDLE hProcess, [In] [Out] nuint* NumberOfPages, [NativeArrayInfo(CountParamIndex = 1)] [Out] nuint* PageArray);
BOOL FreeUserPhysicalPages([In] HANDLE hProcess, [In] [Out] nuint* NumberOfPages, [NativeArrayInfo(CountParamIndex = 1)] [In] nuint* PageArray);
BOOL MapUserPhysicalPages([In] void* VirtualAddress, [In] nuint NumberOfPages, [NativeArrayInfo(CountParamIndex = 1)] [In] [Optional] nuint* PageArray);
BOOL AllocateUserPhysicalPagesNuma([In] HANDLE hProcess, [In] [Out] nuint* NumberOfPages, [NativeArrayInfo(CountParamIndex = 1)] [Out] nuint* PageArray, [In] uint nndPreferred);
void* VirtualAllocExNuma([In] HANDLE hProcess, [In] [Optional] void* lpAddress, [In] nuint dwSize, [In] VIRTUAL_ALLOCATION_TYPE flAllocationType, [In] uint flProtect, [In] uint nndPreferred);
BOOL GetMemoryErrorHandlingCapabilities([Out] uint* Capabilities);
void* RegisterBadMemoryNotification([In] PBAD_MEMORY_CALLBACK_ROUTINE Callback);
BOOL UnregisterBadMemoryNotification([In] void* RegistrationHandle);
uint OfferVirtualMemory([NativeArrayInfo(CountParamIndex = 1)] [In] [Out] void* VirtualAddress, [In] nuint Size, [In] OFFER_PRIORITY Priority);
uint ReclaimVirtualMemory([Const] [NativeArrayInfo(CountParamIndex = 1)] [In] void* VirtualAddress, [In] nuint Size);
uint DiscardVirtualMemory([NativeArrayInfo(CountParamIndex = 1)] [In] [Out] void* VirtualAddress, [In] nuint Size);
nuint RtlCompareMemory([Const] [In] void* Source1, [Const] [In] void* Source2, [In] nuint Length);
nint GlobalAlloc([In] GLOBAL_ALLOC_FLAGS uFlags, [In] nuint dwBytes);
nint GlobalReAlloc([In] nint hMem, [In] nuint dwBytes, [In] uint uFlags);
nuint GlobalSize([In] nint hMem);
BOOL GlobalUnlock([In] nint hMem);
void* GlobalLock([In] nint hMem);
uint GlobalFlags([In] nint hMem);
nint GlobalHandle([Const] [In] void* pMem);
nint GlobalFree([Optional] nint hMem);
nint LocalAlloc([In] LOCAL_ALLOC_FLAGS uFlags, [In] nuint uBytes);
nint LocalReAlloc([Optional] nint hMem, [In] nuint uBytes, [In] uint uFlags);
void* LocalLock([In] nint hMem);
nint LocalHandle([Const] [In] void* pMem);
BOOL LocalUnlock([In] nint hMem);
nuint LocalSize([In] nint hMem);
uint LocalFlags([In] nint hMem);
nint LocalFree([Optional] nint hMem);
HANDLE CreateFileMappingA([In] HANDLE hFile, [In] [Optional] SECURITY_ATTRIBUTES* lpFileMappingAttributes, [In] PAGE_PROTECTION_FLAGS flProtect, [In] uint dwMaximumSizeHigh, [In] uint dwMaximumSizeLow, [Const] [In] [Optional] PSTR lpName);
HANDLE CreateFileMappingNumaA([In] HANDLE hFile, [In] [Optional] SECURITY_ATTRIBUTES* lpFileMappingAttributes, [In] PAGE_PROTECTION_FLAGS flProtect, [In] uint dwMaximumSizeHigh, [In] uint dwMaximumSizeLow, [Const] [In] [Optional] PSTR lpName, [In] uint nndPreferred);
HANDLE OpenFileMappingA([In] uint dwDesiredAccess, [In] BOOL bInheritHandle, [Const] [In] PSTR lpName);
void* MapViewOfFileExNuma([In] HANDLE hFileMappingObject, [In] FILE_MAP dwDesiredAccess, [In] uint dwFileOffsetHigh, [In] uint dwFileOffsetLow, [In] nuint dwNumberOfBytesToMap, [In] [Optional] void* lpBaseAddress, [In] uint nndPreferred);
BOOL IsBadReadPtr([Const] [In] [Optional] void* lp, [In] nuint ucb);
BOOL IsBadWritePtr([In] [Optional] void* lp, [In] nuint ucb);
BOOL IsBadCodePtr([In] [Optional] FARPROC lpfn);
BOOL IsBadStringPtrA([Const] [In] [Optional] PSTR lpsz, [In] nuint ucchMax);
BOOL IsBadStringPtrW([Const] [In] [Optional] PWSTR lpsz, [In] nuint ucchMax);
BOOL MapUserPhysicalPagesScatter([NativeArrayInfo(CountParamIndex = 1)] [In] void** VirtualAddresses, [In] nuint NumberOfPages, [NativeArrayInfo(CountParamIndex = 1)] [In] [Optional] nuint* PageArray);
BOOL AddSecureMemoryCacheCallback([In] PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);
BOOL RemoveSecureMemoryCacheCallback([In] PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);
BOOL OOBEComplete([Out] BOOL* isOOBEComplete);
BOOL RegisterWaitUntilOOBECompleted([In] OOBE_COMPLETED_CALLBACK OOBECompletedCallback, [In] [Optional] void* CallbackContext, [Out] void** WaitHandle);
BOOL UnregisterWaitUntilOOBECompleted([In] void* WaitHandle);
BOOL GlobalMemoryStatusEx([Out] MEMORYSTATUSEX* lpBuffer);
void GetSystemInfo([Out] SYSTEM_INFO* lpSystemInfo);
void GetSystemTime([Out] SYSTEMTIME* lpSystemTime);
void GetSystemTimeAsFileTime([Out] FILETIME* lpSystemTimeAsFileTime);
void GetLocalTime([Out] SYSTEMTIME* lpSystemTime);
BOOL IsUserCetAvailableInEnvironment([In] USER_CET_ENVIRONMENT UserCetEnvironment);
BOOL GetSystemLeapSecondInformation([Out] BOOL* Enabled, [Out] uint* Flags);
uint GetVersion();
BOOL SetLocalTime([Const] [In] SYSTEMTIME* lpSystemTime);
uint GetTickCount();
ulong GetTickCount64();
BOOL GetSystemTimeAdjustment([Out] uint* lpTimeAdjustment, [Out] uint* lpTimeIncrement, [Out] BOOL* lpTimeAdjustmentDisabled);
uint GetSystemDirectoryA([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PSTR lpBuffer, [In] uint uSize);
uint GetSystemDirectoryW([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR lpBuffer, [In] uint uSize);
uint GetWindowsDirectoryA([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PSTR lpBuffer, [In] uint uSize);
uint GetWindowsDirectoryW([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR lpBuffer, [In] uint uSize);
uint GetSystemWindowsDirectoryA([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PSTR lpBuffer, [In] uint uSize);
uint GetSystemWindowsDirectoryW([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR lpBuffer, [In] uint uSize);
BOOL GetComputerNameExA([In] COMPUTER_NAME_FORMAT NameType, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpBuffer, [In] [Out] uint* nSize);
BOOL GetComputerNameExW([In] COMPUTER_NAME_FORMAT NameType, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpBuffer, [In] [Out] uint* nSize);
BOOL SetComputerNameExW([In] COMPUTER_NAME_FORMAT NameType, [Const] [In] PWSTR lpBuffer);
BOOL SetSystemTime([Const] [In] SYSTEMTIME* lpSystemTime);
BOOL GetVersionExA([In] [Out] OSVERSIONINFOA* lpVersionInformation);
BOOL GetVersionExW([In] [Out] OSVERSIONINFOW* lpVersionInformation);
BOOL GetLogicalProcessorInformation([MemorySize(BytesParamIndex = 1)] [Out] [Optional] SYSTEM_LOGICAL_PROCESSOR_INFORMATION* Buffer, [In] [Out] uint* ReturnedLength);
BOOL GetLogicalProcessorInformationEx([In] LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX* Buffer, [In] [Out] uint* ReturnedLength);
void GetNativeSystemInfo([Out] SYSTEM_INFO* lpSystemInfo);
void GetSystemTimePreciseAsFileTime([Out] FILETIME* lpSystemTimeAsFileTime);
BOOL GetProductInfo([In] uint dwOSMajorVersion, [In] uint dwOSMinorVersion, [In] uint dwSpMajorVersion, [In] uint dwSpMinorVersion, [Out] OS_PRODUCT_TYPE* pdwReturnedProductType);
ulong VerSetConditionMask([In] ulong ConditionMask, [In] VER_FLAGS TypeMask, [In] byte Condition);
uint EnumSystemFirmwareTables([In] FIRMWARE_TABLE_PROVIDER FirmwareTableProviderSignature, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] FIRMWARE_TABLE_ID* pFirmwareTableEnumBuffer, [In] uint BufferSize);
uint GetSystemFirmwareTable([In] FIRMWARE_TABLE_PROVIDER FirmwareTableProviderSignature, [In] FIRMWARE_TABLE_ID FirmwareTableID, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] void* pFirmwareTableBuffer, [In] uint BufferSize);
BOOL DnsHostnameToComputerNameExW([Const] [In] PWSTR Hostname, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR ComputerName, [In] [Out] uint* nSize);
BOOL GetPhysicallyInstalledSystemMemory([Out] ulong* TotalMemoryInKilobytes);
BOOL SetComputerNameEx2W([In] COMPUTER_NAME_FORMAT NameType, [In] uint Flags, [Const] [In] PWSTR lpBuffer);
BOOL SetSystemTimeAdjustment([In] uint dwTimeAdjustment, [In] BOOL bTimeAdjustmentDisabled);
BOOL GetProcessorSystemCycleTime([In] ushort Group, [MemorySize(BytesParamIndex = 2)] [Out] [Optional] SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION* Buffer, [In] [Out] uint* ReturnedLength);
BOOL SetComputerNameA([Const] [In] PSTR lpComputerName);
BOOL SetComputerNameW([Const] [In] PWSTR lpComputerName);
BOOL SetComputerNameExA([In] COMPUTER_NAME_FORMAT NameType, [Const] [In] PSTR lpBuffer);
BOOL GetSystemCpuSetInformation([MemorySize(BytesParamIndex = 1)] [Out] [Optional] SYSTEM_CPU_SET_INFORMATION* Information, [In] uint BufferLength, [Out] uint* ReturnedLength, [In] [Optional] HANDLE Process, [Reserved] [In] uint Flags);
uint GetSystemWow64DirectoryA([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PSTR lpBuffer, [In] uint uSize);
uint GetSystemWow64DirectoryW([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR lpBuffer, [In] uint uSize);
HRESULT IsWow64GuestMachineSupported([In] IMAGE_FILE_MACHINE WowGuestMachine, [Out] BOOL* MachineIsSupported);
void GlobalMemoryStatus([Out] MEMORYSTATUS* lpBuffer);
DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy();
BOOL GetFirmwareType([In] [Out] FIRMWARE_TYPE* FirmwareType);
BOOL VerifyVersionInfoA([In] [Out] OSVERSIONINFOEXA* lpVersionInformation, [In] VER_FLAGS dwTypeMask, [In] ulong dwlConditionMask);
BOOL VerifyVersionInfoW([In] [Out] OSVERSIONINFOEXW* lpVersionInformation, [In] VER_FLAGS dwTypeMask, [In] ulong dwlConditionMask);
BOOL GetProcessWorkingSetSize([In] HANDLE hProcess, [Out] nuint* lpMinimumWorkingSetSize, [Out] nuint* lpMaximumWorkingSetSize);
BOOL SetProcessWorkingSetSize([In] HANDLE hProcess, [In] nuint dwMinimumWorkingSetSize, [In] nuint dwMaximumWorkingSetSize);
uint FlsAlloc([In] [Optional] PFLS_CALLBACK_FUNCTION lpCallback);
void* FlsGetValue([In] uint dwFlsIndex);
BOOL FlsSetValue([In] uint dwFlsIndex, [In] [Optional] void* lpFlsData);
BOOL FlsFree([In] uint dwFlsIndex);
BOOL IsThreadAFiber();
void InitializeSRWLock([Out] RTL_SRWLOCK* SRWLock);
void ReleaseSRWLockExclusive([In] [Out] RTL_SRWLOCK* SRWLock);
void ReleaseSRWLockShared([In] [Out] RTL_SRWLOCK* SRWLock);
void AcquireSRWLockExclusive([In] [Out] RTL_SRWLOCK* SRWLock);
void AcquireSRWLockShared([In] [Out] RTL_SRWLOCK* SRWLock);
BOOLEAN TryAcquireSRWLockExclusive([In] [Out] RTL_SRWLOCK* SRWLock);
BOOLEAN TryAcquireSRWLockShared([In] [Out] RTL_SRWLOCK* SRWLock);
void InitializeCriticalSection([Out] RTL_CRITICAL_SECTION* lpCriticalSection);
void EnterCriticalSection([In] [Out] RTL_CRITICAL_SECTION* lpCriticalSection);
void LeaveCriticalSection([In] [Out] RTL_CRITICAL_SECTION* lpCriticalSection);
BOOL InitializeCriticalSectionAndSpinCount([Out] RTL_CRITICAL_SECTION* lpCriticalSection, [In] uint dwSpinCount);
BOOL InitializeCriticalSectionEx([Out] RTL_CRITICAL_SECTION* lpCriticalSection, [In] uint dwSpinCount, [In] uint Flags);
uint SetCriticalSectionSpinCount([In] [Out] RTL_CRITICAL_SECTION* lpCriticalSection, [In] uint dwSpinCount);
BOOL TryEnterCriticalSection([In] [Out] RTL_CRITICAL_SECTION* lpCriticalSection);
void DeleteCriticalSection([In] [Out] RTL_CRITICAL_SECTION* lpCriticalSection);
void InitOnceInitialize([Out] RTL_RUN_ONCE* InitOnce);
BOOL InitOnceExecuteOnce([In] [Out] RTL_RUN_ONCE* InitOnce, [In] PINIT_ONCE_FN InitFn, [In] [Out] [Optional] void* Parameter, [Out] [Optional] void** Context);
BOOL InitOnceBeginInitialize([In] [Out] RTL_RUN_ONCE* lpInitOnce, [In] uint dwFlags, [Out] BOOL* fPending, [Out] [Optional] void** lpContext);
BOOL InitOnceComplete([In] [Out] RTL_RUN_ONCE* lpInitOnce, [In] uint dwFlags, [In] [Optional] void* lpContext);
void InitializeConditionVariable([Out] RTL_CONDITION_VARIABLE* ConditionVariable);
void WakeConditionVariable([In] [Out] RTL_CONDITION_VARIABLE* ConditionVariable);
void WakeAllConditionVariable([In] [Out] RTL_CONDITION_VARIABLE* ConditionVariable);
BOOL SleepConditionVariableCS([In] [Out] RTL_CONDITION_VARIABLE* ConditionVariable, [In] [Out] RTL_CRITICAL_SECTION* CriticalSection, [In] uint dwMilliseconds);
BOOL SleepConditionVariableSRW([In] [Out] RTL_CONDITION_VARIABLE* ConditionVariable, [In] [Out] RTL_SRWLOCK* SRWLock, [In] uint dwMilliseconds, [In] uint Flags);
BOOL SetEvent([In] HANDLE hEvent);
BOOL ResetEvent([In] HANDLE hEvent);
BOOL ReleaseSemaphore([In] HANDLE hSemaphore, [In] int lReleaseCount, [Out] [Optional] int* lpPreviousCount);
BOOL ReleaseMutex([In] HANDLE hMutex);
WIN32_ERROR WaitForSingleObject([In] HANDLE hHandle, [In] uint dwMilliseconds);
uint SleepEx([In] uint dwMilliseconds, [In] BOOL bAlertable);
WIN32_ERROR WaitForSingleObjectEx([In] HANDLE hHandle, [In] uint dwMilliseconds, [In] BOOL bAlertable);
WIN32_ERROR WaitForMultipleObjectsEx([In] uint nCount, [Const] [NativeArrayInfo(CountParamIndex = 0)] [In] HANDLE* lpHandles, [In] BOOL bWaitAll, [In] uint dwMilliseconds, [In] BOOL bAlertable);
HANDLE CreateMutexA([In] [Optional] SECURITY_ATTRIBUTES* lpMutexAttributes, [In] BOOL bInitialOwner, [Const] [In] [Optional] PSTR lpName);
HANDLE CreateMutexW([In] [Optional] SECURITY_ATTRIBUTES* lpMutexAttributes, [In] BOOL bInitialOwner, [Const] [In] [Optional] PWSTR lpName);
HANDLE OpenMutexW([In] SYNCHRONIZATION_ACCESS_RIGHTS dwDesiredAccess, [In] BOOL bInheritHandle, [Const] [In] PWSTR lpName);
HANDLE CreateEventA([In] [Optional] SECURITY_ATTRIBUTES* lpEventAttributes, [In] BOOL bManualReset, [In] BOOL bInitialState, [Const] [In] [Optional] PSTR lpName);
HANDLE CreateEventW([In] [Optional] SECURITY_ATTRIBUTES* lpEventAttributes, [In] BOOL bManualReset, [In] BOOL bInitialState, [Const] [In] [Optional] PWSTR lpName);
HANDLE OpenEventA([In] SYNCHRONIZATION_ACCESS_RIGHTS dwDesiredAccess, [In] BOOL bInheritHandle, [Const] [In] PSTR lpName);
HANDLE OpenEventW([In] SYNCHRONIZATION_ACCESS_RIGHTS dwDesiredAccess, [In] BOOL bInheritHandle, [Const] [In] PWSTR lpName);
HANDLE OpenSemaphoreW([In] SYNCHRONIZATION_ACCESS_RIGHTS dwDesiredAccess, [In] BOOL bInheritHandle, [Const] [In] PWSTR lpName);
HANDLE OpenWaitableTimerW([In] SYNCHRONIZATION_ACCESS_RIGHTS dwDesiredAccess, [In] BOOL bInheritHandle, [Const] [In] PWSTR lpTimerName);
BOOL SetWaitableTimerEx([In] HANDLE hTimer, [Const] [In] LARGE_INTEGER* lpDueTime, [In] int lPeriod, [In] [Optional] PTIMERAPCROUTINE pfnCompletionRoutine, [In] [Optional] void* lpArgToCompletionRoutine, [In] [Optional] REASON_CONTEXT* WakeContext, [In] uint TolerableDelay);
BOOL SetWaitableTimer([In] HANDLE hTimer, [Const] [In] LARGE_INTEGER* lpDueTime, [In] int lPeriod, [In] [Optional] PTIMERAPCROUTINE pfnCompletionRoutine, [In] [Optional] void* lpArgToCompletionRoutine, [In] BOOL fResume);
BOOL CancelWaitableTimer([In] HANDLE hTimer);
HANDLE CreateMutexExA([In] [Optional] SECURITY_ATTRIBUTES* lpMutexAttributes, [Const] [In] [Optional] PSTR lpName, [In] uint dwFlags, [In] uint dwDesiredAccess);
HANDLE CreateMutexExW([In] [Optional] SECURITY_ATTRIBUTES* lpMutexAttributes, [Const] [In] [Optional] PWSTR lpName, [In] uint dwFlags, [In] uint dwDesiredAccess);
HANDLE CreateEventExA([In] [Optional] SECURITY_ATTRIBUTES* lpEventAttributes, [Const] [In] [Optional] PSTR lpName, [In] CREATE_EVENT dwFlags, [In] uint dwDesiredAccess);
HANDLE CreateEventExW([In] [Optional] SECURITY_ATTRIBUTES* lpEventAttributes, [Const] [In] [Optional] PWSTR lpName, [In] CREATE_EVENT dwFlags, [In] uint dwDesiredAccess);
HANDLE CreateSemaphoreExW([In] [Optional] SECURITY_ATTRIBUTES* lpSemaphoreAttributes, [In] int lInitialCount, [In] int lMaximumCount, [Const] [In] [Optional] PWSTR lpName, [Reserved] [In] uint dwFlags, [In] uint dwDesiredAccess);
HANDLE CreateWaitableTimerExW([In] [Optional] SECURITY_ATTRIBUTES* lpTimerAttributes, [Const] [In] [Optional] PWSTR lpTimerName, [In] uint dwFlags, [In] uint dwDesiredAccess);
BOOL EnterSynchronizationBarrier([In] [Out] RTL_BARRIER* lpBarrier, [In] uint dwFlags);
BOOL InitializeSynchronizationBarrier([Out] RTL_BARRIER* lpBarrier, [In] int lTotalThreads, [In] int lSpinCount);
BOOL DeleteSynchronizationBarrier([In] [Out] RTL_BARRIER* lpBarrier);
void Sleep([In] uint dwMilliseconds);
WIN32_ERROR WaitForMultipleObjects([In] uint nCount, [Const] [NativeArrayInfo(CountParamIndex = 0)] [In] HANDLE* lpHandles, [In] BOOL bWaitAll, [In] uint dwMilliseconds);
HANDLE CreateSemaphoreW([In] [Optional] SECURITY_ATTRIBUTES* lpSemaphoreAttributes, [In] int lInitialCount, [In] int lMaximumCount, [Const] [In] [Optional] PWSTR lpName);
HANDLE CreateWaitableTimerW([In] [Optional] SECURITY_ATTRIBUTES* lpTimerAttributes, [In] BOOL bManualReset, [Const] [In] [Optional] PWSTR lpTimerName);
void InitializeSListHead([Out] SLIST_HEADER* ListHead);
SLIST_ENTRY* InterlockedPopEntrySList([In] [Out] SLIST_HEADER* ListHead);
SLIST_ENTRY* InterlockedPushEntrySList([In] [Out] SLIST_HEADER* ListHead, [In] [Out] SLIST_ENTRY* ListEntry);
SLIST_ENTRY* InterlockedPushListSListEx([In] [Out] SLIST_HEADER* ListHead, [In] [Out] SLIST_ENTRY* List, [In] [Out] SLIST_ENTRY* ListEnd, [In] uint Count);
SLIST_ENTRY* InterlockedFlushSList([In] [Out] SLIST_HEADER* ListHead);
ushort QueryDepthSList([In] SLIST_HEADER* ListHead);
uint QueueUserAPC([In] PAPCFUNC pfnAPC, [In] HANDLE hThread, [In] nuint dwData);
BOOL QueueUserAPC2([In] PAPCFUNC ApcRoutine, [In] HANDLE Thread, [In] nuint Data, [In] QUEUE_USER_APC_FLAGS Flags);
BOOL GetProcessTimes([In] HANDLE hProcess, [Out] FILETIME* lpCreationTime, [Out] FILETIME* lpExitTime, [Out] FILETIME* lpKernelTime, [Out] FILETIME* lpUserTime);
HANDLE GetCurrentProcess();
uint GetCurrentProcessId();
void ExitProcess([In] uint uExitCode);
BOOL TerminateProcess([In] HANDLE hProcess, [In] uint uExitCode);
BOOL GetExitCodeProcess([In] HANDLE hProcess, [Out] uint* lpExitCode);
BOOL SwitchToThread();
HANDLE CreateThread([In] [Optional] SECURITY_ATTRIBUTES* lpThreadAttributes, [In] nuint dwStackSize, [In] LPTHREAD_START_ROUTINE lpStartAddress, [In] [Optional] void* lpParameter, [In] THREAD_CREATION_FLAGS dwCreationFlags, [Out] [Optional] uint* lpThreadId);
HANDLE CreateRemoteThread([In] HANDLE hProcess, [In] [Optional] SECURITY_ATTRIBUTES* lpThreadAttributes, [In] nuint dwStackSize, [In] LPTHREAD_START_ROUTINE lpStartAddress, [In] [Optional] void* lpParameter, [In] uint dwCreationFlags, [Out] [Optional] uint* lpThreadId);
HANDLE GetCurrentThread();
uint GetCurrentThreadId();
HANDLE OpenThread([In] THREAD_ACCESS_RIGHTS dwDesiredAccess, [In] BOOL bInheritHandle, [In] uint dwThreadId);
BOOL SetThreadPriority([In] HANDLE hThread, [In] THREAD_PRIORITY nPriority);
BOOL SetThreadPriorityBoost([In] HANDLE hThread, [In] BOOL bDisablePriorityBoost);
BOOL GetThreadPriorityBoost([In] HANDLE hThread, [Out] BOOL* pDisablePriorityBoost);
int GetThreadPriority([In] HANDLE hThread);
void ExitThread([In] uint dwExitCode);
BOOL TerminateThread([In] HANDLE hThread, [In] uint dwExitCode);
BOOL GetExitCodeThread([In] HANDLE hThread, [Out] uint* lpExitCode);
uint SuspendThread([In] HANDLE hThread);
uint ResumeThread([In] HANDLE hThread);
uint TlsAlloc();
void* TlsGetValue([In] uint dwTlsIndex);
BOOL TlsSetValue([In] uint dwTlsIndex, [In] [Optional] void* lpTlsValue);
BOOL TlsFree([In] uint dwTlsIndex);
BOOL CreateProcessA([Const] [In] [Optional] PSTR lpApplicationName, [In] [Out] [Optional] PSTR lpCommandLine, [In] [Optional] SECURITY_ATTRIBUTES* lpProcessAttributes, [In] [Optional] SECURITY_ATTRIBUTES* lpThreadAttributes, [In] BOOL bInheritHandles, [In] PROCESS_CREATION_FLAGS dwCreationFlags, [In] [Optional] void* lpEnvironment, [Const] [In] [Optional] PSTR lpCurrentDirectory, [In] STARTUPINFOA* lpStartupInfo, [Out] PROCESS_INFORMATION* lpProcessInformation);
BOOL CreateProcessW([Const] [In] [Optional] PWSTR lpApplicationName, [In] [Out] [Optional] PWSTR lpCommandLine, [In] [Optional] SECURITY_ATTRIBUTES* lpProcessAttributes, [In] [Optional] SECURITY_ATTRIBUTES* lpThreadAttributes, [In] BOOL bInheritHandles, [In] PROCESS_CREATION_FLAGS dwCreationFlags, [In] [Optional] void* lpEnvironment, [Const] [In] [Optional] PWSTR lpCurrentDirectory, [In] STARTUPINFOW* lpStartupInfo, [Out] PROCESS_INFORMATION* lpProcessInformation);
BOOL SetProcessShutdownParameters([In] uint dwLevel, [In] uint dwFlags);
uint GetProcessVersion([In] uint ProcessId);
void GetStartupInfoW([Out] STARTUPINFOW* lpStartupInfo);
BOOL SetPriorityClass([In] HANDLE hProcess, [In] PROCESS_CREATION_FLAGS dwPriorityClass);
uint GetPriorityClass([In] HANDLE hProcess);
BOOL SetThreadStackGuarantee([In] [Out] uint* StackSizeInBytes);
uint GetProcessId([In] HANDLE Process);
uint GetThreadId([In] HANDLE Thread);
void FlushProcessWriteBuffers();
uint GetProcessIdOfThread([In] HANDLE Thread);
BOOL InitializeProcThreadAttributeList([MemorySize(BytesParamIndex = 3)] [Out] [Optional] LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, [In] uint dwAttributeCount, [Reserved] [In] uint dwFlags, [In] [Out] nuint* lpSize);
void DeleteProcThreadAttributeList([In] [Out] LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList);
BOOL UpdateProcThreadAttribute([In] [Out] LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, [In] uint dwFlags, [In] nuint Attribute, [MemorySize(BytesParamIndex = 4)] [In] [Optional] void* lpValue, [In] nuint cbSize, [MemorySize(BytesParamIndex = 4)] [Out] [Optional] void* lpPreviousValue, [In] [Optional] nuint* lpReturnSize);
BOOL SetProcessDynamicEHContinuationTargets([In] HANDLE Process, [In] ushort NumberOfTargets, [NativeArrayInfo(CountParamIndex = 1)] [In] [Out] PROCESS_DYNAMIC_EH_CONTINUATION_TARGET* Targets);
BOOL SetProcessDynamicEnforcedCetCompatibleRanges([In] HANDLE Process, [In] ushort NumberOfRanges, [NativeArrayInfo(CountParamIndex = 1)] [In] [Out] PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE* Ranges);
BOOL SetProcessAffinityUpdateMode([In] HANDLE hProcess, [In] PROCESS_AFFINITY_AUTO_UPDATE_FLAGS dwFlags);
BOOL QueryProcessAffinityUpdateMode([In] HANDLE hProcess, [Out] [Optional] PROCESS_AFFINITY_AUTO_UPDATE_FLAGS* lpdwFlags);
HANDLE CreateRemoteThreadEx([In] HANDLE hProcess, [In] [Optional] SECURITY_ATTRIBUTES* lpThreadAttributes, [In] nuint dwStackSize, [In] LPTHREAD_START_ROUTINE lpStartAddress, [In] [Optional] void* lpParameter, [In] uint dwCreationFlags, [In] [Optional] LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, [Out] [Optional] uint* lpThreadId);
void GetCurrentThreadStackLimits([Out] nuint* LowLimit, [Out] nuint* HighLimit);
BOOL GetProcessMitigationPolicy([In] HANDLE hProcess, [In] PROCESS_MITIGATION_POLICY MitigationPolicy, [MemorySize(BytesParamIndex = 3)] [Out] void* lpBuffer, [In] nuint dwLength);
BOOL SetProcessMitigationPolicy([In] PROCESS_MITIGATION_POLICY MitigationPolicy, [MemorySize(BytesParamIndex = 2)] [In] void* lpBuffer, [In] nuint dwLength);
BOOL GetThreadTimes([In] HANDLE hThread, [Out] FILETIME* lpCreationTime, [Out] FILETIME* lpExitTime, [Out] FILETIME* lpKernelTime, [Out] FILETIME* lpUserTime);
HANDLE OpenProcess([In] PROCESS_ACCESS_RIGHTS dwDesiredAccess, [In] BOOL bInheritHandle, [In] uint dwProcessId);
BOOL IsProcessorFeaturePresent([In] PROCESSOR_FEATURE_ID ProcessorFeature);
BOOL GetProcessHandleCount([In] HANDLE hProcess, [Out] uint* pdwHandleCount);
uint GetCurrentProcessorNumber();
BOOL SetThreadIdealProcessorEx([In] HANDLE hThread, [In] PROCESSOR_NUMBER* lpIdealProcessor, [Out] [Optional] PROCESSOR_NUMBER* lpPreviousIdealProcessor);
BOOL GetThreadIdealProcessorEx([In] HANDLE hThread, [Out] PROCESSOR_NUMBER* lpIdealProcessor);
void GetCurrentProcessorNumberEx([Out] PROCESSOR_NUMBER* ProcNumber);
BOOL GetProcessPriorityBoost([In] HANDLE hProcess, [Out] BOOL* pDisablePriorityBoost);
BOOL SetProcessPriorityBoost([In] HANDLE hProcess, [In] BOOL bDisablePriorityBoost);
BOOL GetThreadIOPendingFlag([In] HANDLE hThread, [Out] BOOL* lpIOIsPending);
BOOL GetSystemTimes([Out] [Optional] FILETIME* lpIdleTime, [Out] [Optional] FILETIME* lpKernelTime, [Out] [Optional] FILETIME* lpUserTime);
BOOL GetThreadInformation([In] HANDLE hThread, [In] THREAD_INFORMATION_CLASS ThreadInformationClass, [MemorySize(BytesParamIndex = 3)] [Out] void* ThreadInformation, [In] uint ThreadInformationSize);
BOOL SetThreadInformation([In] HANDLE hThread, [In] THREAD_INFORMATION_CLASS ThreadInformationClass, [MemorySize(BytesParamIndex = 3)] [In] void* ThreadInformation, [In] uint ThreadInformationSize);
BOOL IsProcessCritical([In] HANDLE hProcess, [Out] BOOL* Critical);
BOOL SetProtectedPolicy([Const] [In] Guid* PolicyGuid, [In] nuint PolicyValue, [Out] [Optional] nuint* OldPolicyValue);
BOOL QueryProtectedPolicy([Const] [In] Guid* PolicyGuid, [Out] nuint* PolicyValue);
uint SetThreadIdealProcessor([In] HANDLE hThread, [In] uint dwIdealProcessor);
BOOL SetProcessInformation([In] HANDLE hProcess, [In] PROCESS_INFORMATION_CLASS ProcessInformationClass, [MemorySize(BytesParamIndex = 3)] [In] void* ProcessInformation, [In] uint ProcessInformationSize);
BOOL GetProcessInformation([In] HANDLE hProcess, [In] PROCESS_INFORMATION_CLASS ProcessInformationClass, [MemorySize(BytesParamIndex = 3)] [Out] void* ProcessInformation, [In] uint ProcessInformationSize);
BOOL GetProcessDefaultCpuSets([In] HANDLE Process, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] uint* CpuSetIds, [In] uint CpuSetIdCount, [Out] uint* RequiredIdCount);
BOOL SetProcessDefaultCpuSets([In] HANDLE Process, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] [Optional] uint* CpuSetIds, [In] uint CpuSetIdCount);
BOOL GetThreadSelectedCpuSets([In] HANDLE Thread, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] uint* CpuSetIds, [In] uint CpuSetIdCount, [Out] uint* RequiredIdCount);
BOOL SetThreadSelectedCpuSets([In] HANDLE Thread, [Const] [NativeArrayInfo(CountParamIndex = 2)] [In] uint* CpuSetIds, [In] uint CpuSetIdCount);
BOOL GetProcessShutdownParameters([Out] uint* lpdwLevel, [Out] uint* lpdwFlags);
BOOL GetProcessDefaultCpuSetMasks([In] HANDLE Process, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] GROUP_AFFINITY* CpuSetMasks, [In] ushort CpuSetMaskCount, [Out] ushort* RequiredMaskCount);
BOOL SetProcessDefaultCpuSetMasks([In] HANDLE Process, [NativeArrayInfo(CountParamIndex = 2)] [In] [Optional] GROUP_AFFINITY* CpuSetMasks, [In] ushort CpuSetMaskCount);
BOOL GetThreadSelectedCpuSetMasks([In] HANDLE Thread, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] GROUP_AFFINITY* CpuSetMasks, [In] ushort CpuSetMaskCount, [Out] ushort* RequiredMaskCount);
BOOL SetThreadSelectedCpuSetMasks([In] HANDLE Thread, [NativeArrayInfo(CountParamIndex = 2)] [In] [Optional] GROUP_AFFINITY* CpuSetMasks, [In] ushort CpuSetMaskCount);
HRESULT GetMachineTypeAttributes([In] ushort Machine, [Out] MACHINE_ATTRIBUTES* MachineTypeAttributes);
HRESULT SetThreadDescription([In] HANDLE hThread, [Const] [In] PWSTR lpThreadDescription);
HRESULT GetThreadDescription([In] HANDLE hThread, [Out] PWSTR* ppszThreadDescription);
BOOL QueueUserWorkItem([In] LPTHREAD_START_ROUTINE Function, [In] [Optional] void* Context, [In] WORKER_THREAD_FLAGS Flags);
BOOL UnregisterWaitEx([In] HANDLE WaitHandle, [In] [Optional] HANDLE CompletionEvent);
HANDLE CreateTimerQueue();
BOOL CreateTimerQueueTimer([Out] HANDLE* phNewTimer, [In] [Optional] HANDLE TimerQueue, [In] WAITORTIMERCALLBACK Callback, [In] [Optional] void* Parameter, [In] uint DueTime, [In] uint Period, [In] WORKER_THREAD_FLAGS Flags);
BOOL ChangeTimerQueueTimer([In] [Optional] HANDLE TimerQueue, [In] HANDLE Timer, [In] uint DueTime, [In] uint Period);
BOOL DeleteTimerQueueTimer([In] [Optional] HANDLE TimerQueue, [In] HANDLE Timer, [In] [Optional] HANDLE CompletionEvent);
BOOL DeleteTimerQueue([In] HANDLE TimerQueue);
BOOL DeleteTimerQueueEx([In] HANDLE TimerQueue, [In] [Optional] HANDLE CompletionEvent);
PTP_POOL CreateThreadpool([Reserved] [In] [Out] void* reserved);
void SetThreadpoolThreadMaximum([In] PTP_POOL ptpp, [In] uint cthrdMost);
BOOL SetThreadpoolThreadMinimum([In] PTP_POOL ptpp, [In] uint cthrdMic);
BOOL SetThreadpoolStackInformation([In] PTP_POOL ptpp, [In] TP_POOL_STACK_INFORMATION* ptpsi);
BOOL QueryThreadpoolStackInformation([In] PTP_POOL ptpp, [Out] TP_POOL_STACK_INFORMATION* ptpsi);
void CloseThreadpool([In] PTP_POOL ptpp);
nint CreateThreadpoolCleanupGroup();
void CloseThreadpoolCleanupGroupMembers([In] nint ptpcg, [In] BOOL fCancelPendingCallbacks, [In] [Out] [Optional] void* pvCleanupContext);
void CloseThreadpoolCleanupGroup([In] nint ptpcg);
void SetEventWhenCallbackReturns([In] [Out] TP_CALLBACK_INSTANCE* pci, [In] HANDLE evt);
void ReleaseSemaphoreWhenCallbackReturns([In] [Out] TP_CALLBACK_INSTANCE* pci, [In] HANDLE sem, [In] uint crel);
void ReleaseMutexWhenCallbackReturns([In] [Out] TP_CALLBACK_INSTANCE* pci, [In] HANDLE mut);
void LeaveCriticalSectionWhenCallbackReturns([In] [Out] TP_CALLBACK_INSTANCE* pci, [In] [Out] RTL_CRITICAL_SECTION* pcs);
void FreeLibraryWhenCallbackReturns([In] [Out] TP_CALLBACK_INSTANCE* pci, [In] HINSTANCE mod);
BOOL CallbackMayRunLong([In] [Out] TP_CALLBACK_INSTANCE* pci);
void DisassociateCurrentThreadFromCallback([In] [Out] TP_CALLBACK_INSTANCE* pci);
BOOL TrySubmitThreadpoolCallback([In] PTP_SIMPLE_CALLBACK pfns, [In] [Out] [Optional] void* pv, [In] [Optional] TP_CALLBACK_ENVIRON_V3* pcbe);
TP_WORK* CreateThreadpoolWork([In] PTP_WORK_CALLBACK pfnwk, [In] [Out] [Optional] void* pv, [In] [Optional] TP_CALLBACK_ENVIRON_V3* pcbe);
void SubmitThreadpoolWork([In] [Out] TP_WORK* pwk);
void WaitForThreadpoolWorkCallbacks([In] [Out] TP_WORK* pwk, [In] BOOL fCancelPendingCallbacks);
void CloseThreadpoolWork([In] [Out] TP_WORK* pwk);
TP_TIMER* CreateThreadpoolTimer([In] PTP_TIMER_CALLBACK pfnti, [In] [Out] [Optional] void* pv, [In] [Optional] TP_CALLBACK_ENVIRON_V3* pcbe);
void SetThreadpoolTimer([In] [Out] TP_TIMER* pti, [In] [Optional] FILETIME* pftDueTime, [In] uint msPeriod, [In] [Optional] uint msWindowLength);
BOOL IsThreadpoolTimerSet([In] [Out] TP_TIMER* pti);
void WaitForThreadpoolTimerCallbacks([In] [Out] TP_TIMER* pti, [In] BOOL fCancelPendingCallbacks);
void CloseThreadpoolTimer([In] [Out] TP_TIMER* pti);
TP_WAIT* CreateThreadpoolWait([In] PTP_WAIT_CALLBACK pfnwa, [In] [Out] [Optional] void* pv, [In] [Optional] TP_CALLBACK_ENVIRON_V3* pcbe);
void SetThreadpoolWait([In] [Out] TP_WAIT* pwa, [In] [Optional] HANDLE h, [In] [Optional] FILETIME* pftTimeout);
void WaitForThreadpoolWaitCallbacks([In] [Out] TP_WAIT* pwa, [In] BOOL fCancelPendingCallbacks);
void CloseThreadpoolWait([In] [Out] TP_WAIT* pwa);
TP_IO* CreateThreadpoolIo([In] HANDLE fl, [In] PTP_WIN32_IO_CALLBACK pfnio, [In] [Out] [Optional] void* pv, [In] [Optional] TP_CALLBACK_ENVIRON_V3* pcbe);
void StartThreadpoolIo([In] [Out] TP_IO* pio);
void CancelThreadpoolIo([In] [Out] TP_IO* pio);
void WaitForThreadpoolIoCallbacks([In] [Out] TP_IO* pio, [In] BOOL fCancelPendingCallbacks);
void CloseThreadpoolIo([In] [Out] TP_IO* pio);
BOOL SetThreadpoolTimerEx([In] [Out] TP_TIMER* pti, [In] [Optional] FILETIME* pftDueTime, [In] uint msPeriod, [In] [Optional] uint msWindowLength);
BOOL SetThreadpoolWaitEx([In] [Out] TP_WAIT* pwa, [In] [Optional] HANDLE h, [In] [Optional] FILETIME* pftTimeout, [Reserved] [In] [Out] void* Reserved);
BOOL IsWow64Process([In] HANDLE hProcess, [Out] BOOL* Wow64Process);
BOOL IsWow64Process2([In] HANDLE hProcess, [Out] IMAGE_FILE_MACHINE* pProcessMachine, [Out] [Optional] IMAGE_FILE_MACHINE* pNativeMachine);
uint Wow64SuspendThread([In] HANDLE hThread);
NamespaceHandle CreatePrivateNamespaceW([In] [Optional] SECURITY_ATTRIBUTES* lpPrivateNamespaceAttributes, [In] void* lpBoundaryDescriptor, [Const] [In] PWSTR lpAliasPrefix);
NamespaceHandle OpenPrivateNamespaceW([In] void* lpBoundaryDescriptor, [Const] [In] PWSTR lpAliasPrefix);
BOOLEAN ClosePrivateNamespace([In] NamespaceHandle Handle, [In] uint Flags);
BoundaryDescriptorHandle CreateBoundaryDescriptorW([Const] [In] PWSTR Name, [In] uint Flags);
BOOL AddSIDToBoundaryDescriptor([In] [Out] HANDLE* BoundaryDescriptor, [In] PSID RequiredSid);
void DeleteBoundaryDescriptor([In] BoundaryDescriptorHandle BoundaryDescriptor);
BOOL GetNumaHighestNodeNumber([Out] uint* HighestNodeNumber);
BOOL GetNumaNodeProcessorMaskEx([In] ushort Node, [Out] GROUP_AFFINITY* ProcessorMask);
BOOL GetNumaNodeProcessorMask2([In] ushort NodeNumber, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] GROUP_AFFINITY* ProcessorMasks, [In] ushort ProcessorMaskCount, [Out] ushort* RequiredMaskCount);
BOOL GetNumaProximityNodeEx([In] uint ProximityId, [Out] ushort* NodeNumber);
BOOL GetProcessGroupAffinity([In] HANDLE hProcess, [In] [Out] ushort* GroupCount, [NativeArrayInfo(CountParamIndex = 1)] [Out] ushort* GroupArray);
BOOL GetThreadGroupAffinity([In] HANDLE hThread, [Out] GROUP_AFFINITY* GroupAffinity);
BOOL SetThreadGroupAffinity([In] HANDLE hThread, [Const] [In] GROUP_AFFINITY* GroupAffinity, [Out] [Optional] GROUP_AFFINITY* PreviousGroupAffinity);
BOOL GetProcessAffinityMask([In] HANDLE hProcess, [Out] nuint* lpProcessAffinityMask, [Out] nuint* lpSystemAffinityMask);
BOOL SetProcessAffinityMask([In] HANDLE hProcess, [In] nuint dwProcessAffinityMask);
BOOL GetProcessIoCounters([In] HANDLE hProcess, [Out] IO_COUNTERS* lpIoCounters);
void SwitchToFiber([In] void* lpFiber);
void DeleteFiber([In] void* lpFiber);
BOOL ConvertFiberToThread();
void* CreateFiberEx([In] nuint dwStackCommitSize, [In] nuint dwStackReserveSize, [In] uint dwFlags, [In] LPFIBER_START_ROUTINE lpStartAddress, [In] [Optional] void* lpParameter);
void* ConvertThreadToFiberEx([In] [Optional] void* lpParameter, [In] uint dwFlags);
void* CreateFiber([In] nuint dwStackSize, [In] LPFIBER_START_ROUTINE lpStartAddress, [In] [Optional] void* lpParameter);
void* ConvertThreadToFiber([In] [Optional] void* lpParameter);
BOOL CreateUmsCompletionList([Out] void** UmsCompletionList);
BOOL DequeueUmsCompletionListItems([In] void* UmsCompletionList, [In] uint WaitTimeOut, [Out] void** UmsThreadList);
BOOL GetUmsCompletionListEvent([In] void* UmsCompletionList, [In] [Out] HANDLE* UmsCompletionEvent);
BOOL ExecuteUmsThread([In] [Out] void* UmsThread);
BOOL UmsThreadYield([In] void* SchedulerParam);
BOOL DeleteUmsCompletionList([In] void* UmsCompletionList);
void* GetCurrentUmsThread();
void* GetNextUmsListItem([In] [Out] void* UmsContext);
BOOL QueryUmsThreadInformation([In] void* UmsThread, [In] RTL_UMS_THREAD_INFO_CLASS UmsThreadInfoClass, [MemorySize(BytesParamIndex = 3)] [Out] void* UmsThreadInformation, [In] uint UmsThreadInformationLength, [Out] [Optional] uint* ReturnLength);
BOOL SetUmsThreadInformation([In] void* UmsThread, [In] RTL_UMS_THREAD_INFO_CLASS UmsThreadInfoClass, [In] void* UmsThreadInformation, [In] uint UmsThreadInformationLength);
BOOL DeleteUmsThreadContext([In] void* UmsThread);
BOOL CreateUmsThreadContext([Out] void** lpUmsThread);
BOOL EnterUmsSchedulingMode([In] UMS_SCHEDULER_STARTUP_INFO* SchedulerStartupInfo);
BOOL GetUmsSystemThreadInformation([In] HANDLE ThreadHandle, [In] [Out] UMS_SYSTEM_THREAD_INFORMATION* SystemThreadInfo);
nuint SetThreadAffinityMask([In] HANDLE hThread, [In] nuint dwThreadAffinityMask);
BOOL SetProcessDEPPolicy([In] PROCESS_DEP_FLAGS dwFlags);
BOOL GetProcessDEPPolicy([In] HANDLE hProcess, [Out] uint* lpFlags, [Out] BOOL* lpPermanent);
BOOL PulseEvent([In] HANDLE hEvent);
uint WinExec([Const] [In] PSTR lpCmdLine, [In] uint uCmdShow);
HANDLE CreateSemaphoreA([In] [Optional] SECURITY_ATTRIBUTES* lpSemaphoreAttributes, [In] int lInitialCount, [In] int lMaximumCount, [Const] [In] [Optional] PSTR lpName);
HANDLE CreateSemaphoreExA([In] [Optional] SECURITY_ATTRIBUTES* lpSemaphoreAttributes, [In] int lInitialCount, [In] int lMaximumCount, [Const] [In] [Optional] PSTR lpName, [Reserved] [In] uint dwFlags, [In] uint dwDesiredAccess);
BOOL QueryFullProcessImageNameA([In] HANDLE hProcess, [In] PROCESS_NAME_FORMAT dwFlags, [NativeArrayInfo(CountParamIndex = 3)] [Out] PSTR lpExeName, [In] [Out] uint* lpdwSize);
BOOL QueryFullProcessImageNameW([In] HANDLE hProcess, [In] PROCESS_NAME_FORMAT dwFlags, [NativeArrayInfo(CountParamIndex = 3)] [Out] PWSTR lpExeName, [In] [Out] uint* lpdwSize);
void GetStartupInfoA([Out] STARTUPINFOA* lpStartupInfo);
BOOL RegisterWaitForSingleObject([Out] HANDLE* phNewWaitObject, [In] HANDLE hObject, [In] WAITORTIMERCALLBACK Callback, [In] [Optional] void* Context, [In] uint dwMilliseconds, [In] WORKER_THREAD_FLAGS dwFlags);
BOOL UnregisterWait([In] HANDLE WaitHandle);
HANDLE SetTimerQueueTimer([In] [Optional] HANDLE TimerQueue, [In] WAITORTIMERCALLBACK Callback, [In] [Optional] void* Parameter, [In] uint DueTime, [In] uint Period, [In] BOOL PreferIo);
NamespaceHandle CreatePrivateNamespaceA([In] [Optional] SECURITY_ATTRIBUTES* lpPrivateNamespaceAttributes, [In] void* lpBoundaryDescriptor, [Const] [In] PSTR lpAliasPrefix);
NamespaceHandle OpenPrivateNamespaceA([In] void* lpBoundaryDescriptor, [Const] [In] PSTR lpAliasPrefix);
BoundaryDescriptorHandle CreateBoundaryDescriptorA([Const] [In] PSTR Name, [In] uint Flags);
BOOL AddIntegrityLabelToBoundaryDescriptor([In] [Out] HANDLE* BoundaryDescriptor, [In] PSID IntegrityLabel);
ushort GetActiveProcessorGroupCount();
ushort GetMaximumProcessorGroupCount();
uint GetActiveProcessorCount([In] ushort GroupNumber);
uint GetMaximumProcessorCount([In] ushort GroupNumber);
BOOL GetNumaProcessorNode([In] byte Processor, [Out] byte* NodeNumber);
BOOL GetNumaNodeNumberFromHandle([In] HANDLE hFile, [Out] ushort* NodeNumber);
BOOL GetNumaProcessorNodeEx([In] PROCESSOR_NUMBER* Processor, [Out] ushort* NodeNumber);
BOOL GetNumaNodeProcessorMask([In] byte Node, [Out] ulong* ProcessorMask);
BOOL GetNumaAvailableMemoryNode([In] byte Node, [Out] ulong* AvailableBytes);
BOOL GetNumaAvailableMemoryNodeEx([In] ushort Node, [Out] ulong* AvailableBytes);
BOOL GetNumaProximityNode([In] uint ProximityId, [Out] byte* NodeNumber);
BOOL SystemTimeToTzSpecificLocalTime([Const] [In] [Optional] TIME_ZONE_INFORMATION* lpTimeZoneInformation, [Const] [In] SYSTEMTIME* lpUniversalTime, [Out] SYSTEMTIME* lpLocalTime);
BOOL TzSpecificLocalTimeToSystemTime([Const] [In] [Optional] TIME_ZONE_INFORMATION* lpTimeZoneInformation, [Const] [In] SYSTEMTIME* lpLocalTime, [Out] SYSTEMTIME* lpUniversalTime);
BOOL FileTimeToSystemTime([Const] [In] FILETIME* lpFileTime, [Out] SYSTEMTIME* lpSystemTime);
BOOL SystemTimeToFileTime([Const] [In] SYSTEMTIME* lpSystemTime, [Out] FILETIME* lpFileTime);
uint GetTimeZoneInformation([Out] TIME_ZONE_INFORMATION* lpTimeZoneInformation);
BOOL SetTimeZoneInformation([Const] [In] TIME_ZONE_INFORMATION* lpTimeZoneInformation);
BOOL SetDynamicTimeZoneInformation([Const] [In] DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation);
uint GetDynamicTimeZoneInformation([Out] DYNAMIC_TIME_ZONE_INFORMATION* pTimeZoneInformation);
BOOL GetTimeZoneInformationForYear([In] ushort wYear, [In] [Optional] DYNAMIC_TIME_ZONE_INFORMATION* pdtzi, [Out] TIME_ZONE_INFORMATION* ptzi);
BOOL SystemTimeToTzSpecificLocalTimeEx([Const] [In] [Optional] DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation, [Const] [In] SYSTEMTIME* lpUniversalTime, [Out] SYSTEMTIME* lpLocalTime);
BOOL TzSpecificLocalTimeToSystemTimeEx([Const] [In] [Optional] DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation, [Const] [In] SYSTEMTIME* lpLocalTime, [Out] SYSTEMTIME* lpUniversalTime);
BOOL LocalFileTimeToLocalSystemTime([Const] [In] [Optional] TIME_ZONE_INFORMATION* timeZoneInformation, [Const] [In] FILETIME* localFileTime, [Out] SYSTEMTIME* localSystemTime);
BOOL LocalSystemTimeToLocalFileTime([Const] [In] [Optional] TIME_ZONE_INFORMATION* timeZoneInformation, [Const] [In] SYSTEMTIME* localSystemTime, [Out] FILETIME* localFileTime);
int uaw_lstrcmpW([In] ushort* String1, [In] ushort* String2);
int uaw_lstrcmpiW([In] ushort* String1, [In] ushort* String2);
int uaw_lstrlenW([In] ushort* String);
ushort* uaw_wcschr([In] ushort* String, [In] wchar Character);
ushort* uaw_wcscpy([Out] ushort* Destination, [In] ushort* Source);
int uaw_wcsicmp([In] ushort* String1, [In] ushort* String2);
nuint uaw_wcslen([In] ushort* String);
ushort* uaw_wcsrchr([In] ushort* String, [In] wchar Character);
BOOL QueryThreadCycleTime([In] HANDLE ThreadHandle, [Out] ulong* CycleTime);
BOOL QueryProcessCycleTime([In] HANDLE ProcessHandle, [Out] ulong* CycleTime);
BOOL QueryIdleProcessorCycleTime([In] [Out] uint* BufferLength, [MemorySize(BytesParamIndex = 0)] [Out] [Optional] ulong* ProcessorIdleCycleTime);
BOOL QueryIdleProcessorCycleTimeEx([In] ushort Group, [In] [Out] uint* BufferLength, [MemorySize(BytesParamIndex = 1)] [Out] [Optional] ulong* ProcessorIdleCycleTime);
BOOL QueryUnbiasedInterruptTime([Out] ulong* UnbiasedTime);
nuint GlobalCompact([In] uint dwMinFree);
void GlobalFix([In] nint hMem);
void GlobalUnfix([In] nint hMem);
void* GlobalWire([In] nint hMem);
BOOL GlobalUnWire([In] nint hMem);
nuint LocalShrink([In] nint hMem, [In] uint cbNewSize);
nuint LocalCompact([In] uint uMinFree);
BOOL SetEnvironmentStringsA([NotNullTerminated] [NullNullTerminated] [In] PSTR NewEnvironment);
uint SetHandleCount([In] uint uNumber);
BOOL RequestDeviceWakeup([In] HANDLE hDevice);
BOOL CancelDeviceWakeupRequest([In] HANDLE hDevice);
BOOL SetMessageWaitingIndicator([In] HANDLE hMsgIndicator, [In] uint ulMsgCount);
int MulDiv([In] int nNumber, [In] int nNumerator, [In] int nDenominator);
BOOL GetSystemRegistryQuota([Out] [Optional] uint* pdwQuotaAllowed, [Out] [Optional] uint* pdwQuotaUsed);
BOOL FileTimeToDosDateTime([Const] [In] FILETIME* lpFileTime, [Out] ushort* lpFatDate, [Out] ushort* lpFatTime);
BOOL DosDateTimeToFileTime([In] ushort wFatDate, [In] ushort wFatTime, [Out] FILETIME* lpFileTime);
int _lopen([Const] [In] PSTR lpPathName, [In] int iReadWrite);
int _lcreat([Const] [In] PSTR lpPathName, [In] int iAttribute);
uint _lread([In] int hFile, [MemorySize(BytesParamIndex = 2)] [Out] void* lpBuffer, [In] uint uBytes);
uint _lwrite([In] int hFile, [Const] [NotNullTerminated] [MemorySize(BytesParamIndex = 2)] [In] PSTR lpBuffer, [In] uint uBytes);
int _hread([In] int hFile, [MemorySize(BytesParamIndex = 2)] [Out] void* lpBuffer, [In] int lBytes);
int _hwrite([In] int hFile, [Const] [NotNullTerminated] [MemorySize(BytesParamIndex = 2)] [In] PSTR lpBuffer, [In] int lBytes);
int _lclose([In] int hFile);
int _llseek([In] int hFile, [In] int lOffset, [In] int iOrigin);
WIN32_ERROR SignalObjectAndWait([In] HANDLE hObjectToSignal, [In] HANDLE hObjectToWaitOn, [In] uint dwMilliseconds, [In] BOOL bAlertable);
HANDLE OpenMutexA([In] uint dwDesiredAccess, [In] BOOL bInheritHandle, [Const] [In] PSTR lpName);
HANDLE OpenSemaphoreA([In] uint dwDesiredAccess, [In] BOOL bInheritHandle, [Const] [In] PSTR lpName);
HANDLE CreateWaitableTimerA([In] [Optional] SECURITY_ATTRIBUTES* lpTimerAttributes, [In] BOOL bManualReset, [Const] [In] [Optional] PSTR lpTimerName);
HANDLE OpenWaitableTimerA([In] uint dwDesiredAccess, [In] BOOL bInheritHandle, [Const] [In] PSTR lpTimerName);
HANDLE CreateWaitableTimerExA([In] [Optional] SECURITY_ATTRIBUTES* lpTimerAttributes, [Const] [In] [Optional] PSTR lpTimerName, [In] uint dwFlags, [In] uint dwDesiredAccess);
uint GetFirmwareEnvironmentVariableA([Const] [In] PSTR lpName, [Const] [In] PSTR lpGuid, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] void* pBuffer, [In] uint nSize);
uint GetFirmwareEnvironmentVariableW([Const] [In] PWSTR lpName, [Const] [In] PWSTR lpGuid, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] void* pBuffer, [In] uint nSize);
uint GetFirmwareEnvironmentVariableExA([Const] [In] PSTR lpName, [Const] [In] PSTR lpGuid, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] void* pBuffer, [In] uint nSize, [Out] [Optional] uint* pdwAttribubutes);
uint GetFirmwareEnvironmentVariableExW([Const] [In] PWSTR lpName, [Const] [In] PWSTR lpGuid, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] void* pBuffer, [In] uint nSize, [Out] [Optional] uint* pdwAttribubutes);
BOOL SetFirmwareEnvironmentVariableA([Const] [In] PSTR lpName, [Const] [In] PSTR lpGuid, [MemorySize(BytesParamIndex = 3)] [In] [Optional] void* pValue, [In] uint nSize);
BOOL SetFirmwareEnvironmentVariableW([Const] [In] PWSTR lpName, [Const] [In] PWSTR lpGuid, [MemorySize(BytesParamIndex = 3)] [In] [Optional] void* pValue, [In] uint nSize);
BOOL SetFirmwareEnvironmentVariableExA([Const] [In] PSTR lpName, [Const] [In] PSTR lpGuid, [MemorySize(BytesParamIndex = 3)] [In] [Optional] void* pValue, [In] uint nSize, [In] uint dwAttributes);
BOOL SetFirmwareEnvironmentVariableExW([Const] [In] PWSTR lpName, [Const] [In] PWSTR lpGuid, [MemorySize(BytesParamIndex = 3)] [In] [Optional] void* pValue, [In] uint nSize, [In] uint dwAttributes);
BOOL IsNativeVhdBoot([Out] BOOL* NativeVhdBoot);
uint GetProfileIntA([Const] [In] PSTR lpAppName, [Const] [In] PSTR lpKeyName, [In] int nDefault);
uint GetProfileIntW([Const] [In] PWSTR lpAppName, [Const] [In] PWSTR lpKeyName, [In] int nDefault);
uint GetProfileStringA([Const] [In] [Optional] PSTR lpAppName, [Const] [In] [Optional] PSTR lpKeyName, [Const] [In] [Optional] PSTR lpDefault, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PSTR lpReturnedString, [In] uint nSize);
uint GetProfileStringW([Const] [In] [Optional] PWSTR lpAppName, [Const] [In] [Optional] PWSTR lpKeyName, [Const] [In] [Optional] PWSTR lpDefault, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PWSTR lpReturnedString, [In] uint nSize);
BOOL WriteProfileStringA([Const] [In] [Optional] PSTR lpAppName, [Const] [In] [Optional] PSTR lpKeyName, [Const] [In] [Optional] PSTR lpString);
BOOL WriteProfileStringW([Const] [In] [Optional] PWSTR lpAppName, [Const] [In] [Optional] PWSTR lpKeyName, [Const] [In] [Optional] PWSTR lpString);
uint GetProfileSectionA([Const] [In] PSTR lpAppName, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpReturnedString, [In] uint nSize);
uint GetProfileSectionW([Const] [In] PWSTR lpAppName, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpReturnedString, [In] uint nSize);
BOOL WriteProfileSectionA([Const] [In] PSTR lpAppName, [Const] [In] PSTR lpString);
BOOL WriteProfileSectionW([Const] [In] PWSTR lpAppName, [Const] [In] PWSTR lpString);
uint GetPrivateProfileIntA([Const] [In] PSTR lpAppName, [Const] [In] PSTR lpKeyName, [In] int nDefault, [Const] [In] [Optional] PSTR lpFileName);
uint GetPrivateProfileIntW([Const] [In] PWSTR lpAppName, [Const] [In] PWSTR lpKeyName, [In] int nDefault, [Const] [In] [Optional] PWSTR lpFileName);
uint GetPrivateProfileStringA([Const] [In] [Optional] PSTR lpAppName, [Const] [In] [Optional] PSTR lpKeyName, [Const] [In] [Optional] PSTR lpDefault, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PSTR lpReturnedString, [In] uint nSize, [Const] [In] [Optional] PSTR lpFileName);
uint GetPrivateProfileStringW([Const] [In] [Optional] PWSTR lpAppName, [Const] [In] [Optional] PWSTR lpKeyName, [Const] [In] [Optional] PWSTR lpDefault, [NativeArrayInfo(CountParamIndex = 4)] [Out] [Optional] PWSTR lpReturnedString, [In] uint nSize, [Const] [In] [Optional] PWSTR lpFileName);
BOOL WritePrivateProfileStringA([Const] [In] [Optional] PSTR lpAppName, [Const] [In] [Optional] PSTR lpKeyName, [Const] [In] [Optional] PSTR lpString, [Const] [In] [Optional] PSTR lpFileName);
BOOL WritePrivateProfileStringW([Const] [In] [Optional] PWSTR lpAppName, [Const] [In] [Optional] PWSTR lpKeyName, [Const] [In] [Optional] PWSTR lpString, [Const] [In] [Optional] PWSTR lpFileName);
uint GetPrivateProfileSectionA([Const] [In] PSTR lpAppName, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR lpReturnedString, [In] uint nSize, [Const] [In] [Optional] PSTR lpFileName);
uint GetPrivateProfileSectionW([Const] [In] PWSTR lpAppName, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR lpReturnedString, [In] uint nSize, [Const] [In] [Optional] PWSTR lpFileName);
BOOL WritePrivateProfileSectionA([Const] [In] [Optional] PSTR lpAppName, [Const] [In] [Optional] PSTR lpString, [Const] [In] [Optional] PSTR lpFileName);
BOOL WritePrivateProfileSectionW([Const] [In] [Optional] PWSTR lpAppName, [Const] [In] [Optional] PWSTR lpString, [Const] [In] [Optional] PWSTR lpFileName);
uint GetPrivateProfileSectionNamesA([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PSTR lpszReturnBuffer, [In] uint nSize, [Const] [In] [Optional] PSTR lpFileName);
uint GetPrivateProfileSectionNamesW([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR lpszReturnBuffer, [In] uint nSize, [Const] [In] [Optional] PWSTR lpFileName);
BOOL GetPrivateProfileStructA([Const] [In] PSTR lpszSection, [Const] [In] PSTR lpszKey, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] void* lpStruct, [In] uint uSizeStruct, [Const] [In] [Optional] PSTR szFile);
BOOL GetPrivateProfileStructW([Const] [In] PWSTR lpszSection, [Const] [In] PWSTR lpszKey, [MemorySize(BytesParamIndex = 3)] [Out] [Optional] void* lpStruct, [In] uint uSizeStruct, [Const] [In] [Optional] PWSTR szFile);
BOOL WritePrivateProfileStructA([Const] [In] PSTR lpszSection, [Const] [In] PSTR lpszKey, [MemorySize(BytesParamIndex = 3)] [In] [Optional] void* lpStruct, [In] uint uSizeStruct, [Const] [In] [Optional] PSTR szFile);
BOOL WritePrivateProfileStructW([Const] [In] PWSTR lpszSection, [Const] [In] PWSTR lpszKey, [MemorySize(BytesParamIndex = 3)] [In] [Optional] void* lpStruct, [In] uint uSizeStruct, [Const] [In] [Optional] PWSTR szFile);
BOOL IsBadHugeReadPtr([Const] [In] [Optional] void* lp, [In] nuint ucb);
BOOL IsBadHugeWritePtr([In] [Optional] void* lp, [In] nuint ucb);
BOOL GetComputerNameA([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PSTR lpBuffer, [In] [Out] uint* nSize);
BOOL GetComputerNameW([NativeArrayInfo(CountParamIndex = 1)] [Out] [Optional] PWSTR lpBuffer, [In] [Out] uint* nSize);
BOOL DnsHostnameToComputerNameA([Const] [In] PSTR Hostname, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PSTR ComputerName, [In] [Out] uint* nSize);
BOOL DnsHostnameToComputerNameW([Const] [In] PWSTR Hostname, [NativeArrayInfo(CountParamIndex = 2)] [Out] [Optional] PWSTR ComputerName, [In] [Out] uint* nSize);
BOOL CancelTimerQueueTimer([In] [Optional] HANDLE TimerQueue, [In] HANDLE Timer);
BOOL ReplacePartitionUnit([In] PWSTR TargetPartition, [In] PWSTR SparePartition, [In] uint Flags);
ulong GetThreadEnabledXStateFeatures();
BOOL EnableProcessOptionalXStateFeatures([In] ulong Features);
